<pre class="ql-syntax" spellcheck="false">#date（日期）返回日期时间的日期部分：
DATE(col_name)
#year（年）返回日期时间的年份：
YEAR(col_name)
#time（时间）返回日期时间的时间：
TIME(col_name)
#month（月份）返回日期时间的月份：
MONTH(col_name)
#day of week（星期）返回对应的是星期几，适用于MySQL：
DAYOFWEEK(col_name)
#day（日）返回日期时间的天数：
DAY(col_name)
#hour（小时）返回日期时间的小时：
HOUR(col_name)
#minute（分钟）返回日期时间的分钟：
MINUTE(col_name)
#second（秒）返回日期时间的秒钟：
SECOND(col_name)
</pre><p>闲话不多说，双十一刚过，想必大家也下了不少订单了【突然败家】，那么，我们不妨来举个找出双十一订单的例子来。</p><p>建个表</p><p>假如我们有一张淘宝店的订单表：</p><pre class="ql-syntax" spellcheck="false">CREATE TABLE 订单(订单号 int, 顾客ID char(100), 日期 date);
INSERT INTO 订单 
VALUE (183, '002', '2019-10-05'),
(184, '005', '2019-11-02'),
(184, '008', '2019-11-08'),
(185, '004', '2019-11-10'),
(186, '003', '2019-11-10'),
(187, '004', '2019-11-11'),
(188, '004', '2019-11-11'),
(189, '009', '2019-11-11'),
(190, '019', '2019-11-12');
</pre><p><span style="background-color: transparent;"><img src="https://pic4.zhimg.com/80/v2-2da3400b4c77604fe93ad631bd43f8b7_720w.jpg" width="761"></span></p><p>日期举例</p><p>那么它在双十一的订单有哪些呢：</p><pre class="ql-syntax" spellcheck="false">SELECT *
FROM 订单
WHERE 日期 = '2019-11-11'
</pre><p><span style="background-color: transparent;"><img src="https://pic1.zhimg.com/80/v2-8491de97e59ad8a4467999210e03a138_720w.jpg" width="684"></span></p><p>所以在双十一，这家淘宝店只有三个订单，而且其中两份还是由同一个顾客下的···可能是要凑个满四百？</p><p>月份举例</p><p>看样子这家店在双十一没能大肆销售一番呀，那让我们来看看它在十一月的整体业绩是为如何：</p><pre class="ql-syntax" spellcheck="false">SELECT *
FROM 订单
WHERE DATE(日期) 
BETWEEN '2019-11-01' 
AND '2019-11-30'
</pre><p><span style="background-color: transparent;"><img src="https://pic1.zhimg.com/80/v2-b2e65e2f026d250e02374e9f8e076788_720w.jpg" width="625"></span></p><p>好吧，看样子整体业绩也颇为一般，希望这家店日后多多努力呀～【等等，这张表不是你自己自说自话创出来的么！】</p><p>在上面的例子里【转移话题】，我们运用了BETWEEN... AND...（在···与···之中）的方法，灵活运用这个语句可以解决不少疑难杂症。但是，在日期的处理中，最为头疼的便是每月的天数并不唯一，尤其是那个让人操心的闰年二月。</p><p>机智的月份举例</p><pre class="ql-syntax" spellcheck="false">SELECT 订单号 AS 第二个例子, 顾客ID, 日期
FROM 订单
WHERE YEAR(日期) = 2019
AND MONTH(日期) = 11
</pre><p><em>为了区分上表，我用AS（作为）对订单号的column（列）进行了重命名。</em></p><p><span style="background-color: transparent;"><img src="https://pic4.zhimg.com/80/v2-d39070a65973fd811a86d3ab97cb24c3_720w.jpg" width="672"></span></p><p>结果与上表无异，但在这个例子中，我们便不用担心月份造成了日数差异了。</p><p>如果我们只想要列出日期，那么就应该利用DATE（日期），哪怕相应的列只包含日期。若是以后表中突然有了日期和时间值，我们的SQL代码也不用改变。其余的日期函数同理。</p><h2>斗转星移</h2><p>除了上文所提到的直接从数据中提取出相关的日期时间信息，我们也可以人为地在column（列）的基础上进行相关编写。</p><p>ADDDATE</p><p>adddate（增加日期）增加或减少一个日期（年季月日时），这里有三种写法：</p><pre class="ql-syntax" spellcheck="false">ADDDATE(date, INTERVAL value addunit)
</pre><p><em>date是需要修改的日期时间，value指要增减的日子时间，addunit则是要增改的类型。</em></p><p>又可写作：</p><pre class="ql-syntax" spellcheck="false">DATE_ADD(date, INTERVAL value addunit)
</pre><p>还可写作：</p><pre class="ql-syntax" spellcheck="false">ADDDATE(date, days)
</pre><p>* date是需要修改的日期时间，days则是要增减的天数。</p><p>其中，常见的addunit可取值有下表：</p><ul><li>Year（年）Quarter（季度）Month（月）Day（日）Week（星期）hour（小时）Minute（分钟）Second（秒钟）Millisecond（毫秒）</li></ul><p>ADDTIME</p><p>addtime（增加时间）增加或减少一个时间：</p><pre class="ql-syntax" spellcheck="false">ADDTIME(datetime, addtime)
</pre><p>日期增减举例</p><p>假如一不小心漏算了一个星期需要加回七天（一个星期）：</p><pre class="ql-syntax" spellcheck="false">SELECT 日期, 
ADDDATE(日期, 7) AS 新日期
FROM 订单
</pre><p>或者“繁琐”一些：</p><pre class="ql-syntax" spellcheck="false">SELECT 日期, 
ADDDATE(日期, INTERVAL 1 WEEK) AS 新日期
FROM 订单
</pre><p><span style="background-color: transparent;"><img src="https://pic4.zhimg.com/80/v2-eb4c5c2993051e062d0ee4b44ac60767_720w.jpg" width="696"></span></p><p>时间增减举例</p><p>减少五天两小时十分钟五秒三毫秒：</p><pre class="ql-syntax" spellcheck="false">SELECT "2017-06-15 09:34:21.000003" AS 旧时间, 
ADDTIME("2017-06-15 09:34:21.000003", "-5 2:10:5.000003") AS 新时间
</pre><p><span style="background-color: transparent;"><img src="https://pic3.zhimg.com/80/v2-e0003994562b002795c2a97c1bbcceb2_720w.png" width="765"></span></p><h2>活在当下</h2><p>在SQL中，我们也是可以用简单的语句让它直接列出当前的时间与日期的。</p><pre class="ql-syntax" spellcheck="false">#curdate(当前日期)返回当前日期：
CURDATE()
#curtime(当前时间)返回当前时间：
CURTIME()
#now(现在)返回当前日期时间：
NOW()
</pre><p><em>注意，上面的三个函数我们都可以直接使用，括号内无需添加任何数值，鉴于函数本身返回的便是当下的日期时间等。</em></p><p>“当下”举例</p><pre class="ql-syntax" spellcheck="false">SELECT NOW()
AS 当前日期时间
</pre><p><span style="background-color: transparent;"><img src="https://pic4.zhimg.com/80/v2-69b764827748c13486118abbdb488ff3_720w.jpg" width="386"></span></p><h2>朝三暮四</h2><p>除了直接从列表中找出我们所需要的值，或进行增减，找出当前的时间，我们还可以借助SQL做些别的杂活。</p><p>datediff(日期区别)计算两个日期的差值：</p><pre class="ql-syntax" spellcheck="false">DATEDIFF(date1, date2)
</pre><p>dayofweek(星期中的哪一天)返回日期为星期几：</p><pre class="ql-syntax" spellcheck="false">DAYOFWEEK(date)
</pre><p>date_format(格式)返回一个格式化的日期时间：</p><pre class="ql-syntax" spellcheck="false">DATE_FORMAT(date, format)
</pre><p>format（格式）可以取下表的值：</p><ul><li>％a：工作日缩写名称（星期日至星期六）％b：月份的缩写（1月至12月）％c：数字月份名称（0到12）％D：一个月的天，以数字值后跟后缀（第一，第二，第三，...）％d：月份中的天，以数值（01到31）％e：每月的天，以数值（0到31）％f：微秒（000000至999999）％H：小时（00到23）％h：小时（00到12）％I：小时（00到12）％i：分钟（00至59）％j：一年中的某天（001至366％k：小时（0到23）％l：小时（1到12）％M：月的全称（1月至12月）％m：月名称（作为数字值（00到12））％p：AM或PM％r：以12小时AM或PM格式显示的时间（hh：mm：ss AM / PM）％S：秒（00至59）％s：秒（00至59）％T：时间，以24小时格式（hh：mm：ss）％U：周，其中星期日是一周的第一天（00到53）％u ：Week，其中星期一是一周的第一天（00到53）％V：周，其中星期日是一周的第一天（01到53）。与％X一起使用％v：周，其中星期一是一周的第一天（01到53）。与％x一起使用％W：工作日名称的完整名称（星期日至星期六）％w：星期几，星期天= 0，星期六= 6％X：星期的年份，其中星期日是一周的第一天。与％V一起使用％x：一周的第一年中的一周的年份。与％v一起使用％Y：年，为4位数字％y：年，为2位数字数值</li></ul><p>再来建个表</p><pre class="ql-syntax" spellcheck="false">CREATE TABLE 时间表(订货时间 date, 发货时间 date);
INSERT INTO 时间表 
VALUE ('2019-11-10', '2019-11-15'),
('2019-11-10', '2019-11-18'),
('2019-11-11', '2019-11-19'),
('2019-11-11', '2019-11-21'),
('2019-11-11', '2019-11-23'),
('2019-11-12', '2019-11-28');
</pre><p><span style="background-color: transparent;"><img src="https://pic4.zhimg.com/80/v2-c04a2f76777651b37310405bb6784a27_720w.jpg" width="627"></span></p><p>时间差举例</p><p>借助DATEDIFF()，我们可以很轻松地看出店家用了多久才发货，并且是星期几发货的：</p><pre class="ql-syntax" spellcheck="false">SELECT *, 
DATEDIFF(发货时间, 订货时间) AS 发货所需天数, 
DAYOFWEEK(发货时间)AS 星期
FROM 时间表
</pre><p><span style="background-color: transparent;"><img src="https://pic3.zhimg.com/80/v2-f5152df1caec200b5bb2fd6f8c09de36_720w.jpg" width="760"></span></p><attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-1f6cf39e-05e6-42d9-a201-309230defc7f"></attachment><p><br></p>