### 一、函数和方法的认知
## 函数

# @classmethod下定义的func属于方法，@staticmethod下定义的func属于函数。
# 而类class中定义的普通func要分是类调用还是类对象调用。

```
函数是封装了一些独立的功能，可以直接调用，能将一些数据（参数）传递进去进行处理，然后返回一些数据（返回值），也可以没有返回值。可以直接在模块中进行定义使用。所有传递给函数的数据都是显式传递的。
```


## 方法
```
方法和函数类似，同样封装了独立的功能，但是方法是只能依靠类或者对象来调用的，表示针对性的操作。
### 方法中的数据self和cls是隐式传递的，即方法的调用者；
方法可以操作类内部的数据
```

```
当类实例化对象后，如`apple对象`，再调用function时，
普通func，如fun1，就被称为是`实例化方法`，
定义在@staticmethod下的func，与class和实例化对象无关，所以依然属于`函数`,
定义在@classmethod下的func，与class内部有关，属于类的方法。
```

# 测试函数还是方法
```
from types import FunctionType, MethodType
print(isinstance(lwd.func, FunctionType))  # False
print(isinstance(lwd.func, MethodType))   # True   #说明这是一个方法

print(isinstance(Lwd.func, FunctionType))  # True   #说明这是一个函数
print(isinstance(Lwd.func, MethodType))  # False
```
# 重写管理器对象（自定义manager）
```
class studentManager(models.Manager):
  def get_queryset(self):
    return super(studentManager,self).get_queryset().filter(isDelete=False)
```

参数是类
def xxx(cls,**yy):
	self = cls(**yy)(实例化对象)


取出请求方法同名的函数名赋值给handler
handler=getattr(self,request.method.lower((小写的意思)),self.http_method_not_allowed)
return handler(request,*args,**kwargs)
```

1. ### python cls self 讲解
一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。

而使用@staticmethod或@classmethod，就可以不需要实例化，直接类名.方法名()来调用。

这有利于组织代码，把某些应该属于某个类的函数给放到那个类里去，同时有利于命名空间的整洁。

```

class A(object):
    a = 'a'
    @staticmethod
    def foo1(name):
        print 'hello', name
    def foo2(self, name):
        print 'hello', name
    @classmethod
    def foo3(cls, name):
        print 'hello', name
```


### 1. Mongodb数据库操作
#### serilaizer：
```
from rest_framework_mongoengine import serializers


class ListSerializer(serializers.DocumentSerializer):

    class Meta:
        model = Spit
        fields = "__all__"
```
#### 
views:
```
from rest_framework_mongoengine.viewsets import ModelViewSet


class ListViewModelSet(ModelViewSet):
    # queryset = Spit.objects.all()需要转成    
    # def get_queryset(self):
    #         return Spit.objects.all()才能提取

    serializer_class = ListSerializer

    def get_queryset(self):
        return Spit.objects.all()

```


#Python 交换x ,y
x , y
int z=x; x=y, y=z
可以优化为(加空格)
x , y = y , x



#根据数据库生成模型类



创建一个项目，修改seting文件，在setting里面设置要连接的数据库

运行下面代码可以自动生成models模型文件 
Python manage.py inspectdb 
这样就可以在控制台的命令行中看到数据库的模型文件了

把模型文件导入到app中 
创建一个app 
django-admin.py startapp app 
python manage.py inspectdb > app/models.py 
ok模型文件已经生成好了。下面的工作就和之前一样了



简单介绍工厂模式和单例模式
工厂模式：

　　介绍：

　　　　工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程（new 关键字和具体的构造器）隐藏起来。用一个工厂方法来替代，对外提供的只是一个工厂方法，达到提高灵活性的目的。 　　

　　优点：

　　　　1.隐藏了new关键字和构造器 

           　2.降低了这个对象与别的类之间的耦合度，提高了程序的可扩展性。 原因：当子类被别的类替代，或者构造器的参数发生变化的时候，只需改动工厂方法内的new即可，改动量降到了最低，直接用new关键字的话，需要改动的地方就很多了 

           　3.把对象的设计和实现分割开来，从而代码扩展性强、灵活性高。 

　　适用范围： 
      　　 1.在编码时不能预见需要创建哪一个种类的实例。 
       　　2.一个类使用它的子类来创建对象。 
       　　3.开发人员不希望创建了那个类的实例以及如何创建实例的信息暴露给外部程序。 
     　　　　　除了上面提到的例子，工厂模式的实现方式还允许有一些小小的变化，例如： 
        　　　　基类可以是一个抽象类，在这种情况下，工厂类必须返回一个非抽象类。 
       　　　　 基类提供了一些缺省方法，只有当这些缺省方法不能满足特殊需求的情况下才能在子类中重写这些方法。 
        　　　　可以直接通过传递给工厂类的参数决定应该返回哪一个子类的实例。 

　　 结构：用一个方法来代替new关键字和构造器。 

 

单例模式：

　　介绍：

　　　　 1.声明一个私有的，静态的本类对象，但并不在声明的时候就初始化，因此，它的值为null。 
        　　2.私有化构造器 
        　　3.对外提供一个全局的，共有的，静态的，唯一的方法，用来获得该实例，但注意的是：必须要手动保持线程同步（synchronized） 
        　　4.在该方法里，判断对象是否为null，如果是null的话，表示这个类还没有被实例化，就会初始化这个对象，再返回如果不是null的话，就直接返回。

　　优点：

　　　　整个系统中的所有的类共用一个实例化对象，这样可以有效的节省资源。

　　适用特点：

　　　　它确保一个类在java虚拟机里只有一个实例，使一个类只有一个对象，整个系统共享这个对象。 

　　结构：将构造变成私有的-->做一个静态的生成对象的方法-->造一个静态的存储对象-->return 静态的对象


