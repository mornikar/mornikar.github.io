<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dr.GT_Mornikar</title>
  
  <subtitle>Hi Mornikar,Are you still peeping at me through the screen?</subtitle>
  <link href="http://mornikar.github.io/atom.xml" rel="self"/>
  
  <link href="http://mornikar.github.io/"/>
  <updated>2023-02-15T22:50:21.496Z</updated>
  <id>http://mornikar.github.io/</id>
  
  <author>
    <name>Mornikar</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E4%BA%91%E7%8E%AF%E5%A2%83/%E4%BA%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://mornikar.github.io/2025/09/11/%E4%BA%91%E7%8E%AF%E5%A2%83/%E4%BA%91%E7%8E%AF%E5%A2%83/</id>
    <published>2025-09-11T03:36:23.157Z</published>
    <updated>2023-02-15T22:50:21.496Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bistudio.com.cn/cloudDetail?cloud_id=1">https://www.bistudio.com.cn/cloudDetail?cloud_id=1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bistudio.com.cn/cloudDetail?cloud_id=1&quot;&gt;https://www.bistudio.com.cn/cloudDetail?cloud_id=1&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/restful%20%E9%A3%8E%E6%A0%BC%EF%BC%8C%E5%AE%9A%E4%B9%89http%E6%8E%A5%E5%8F%A3%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>http://mornikar.github.io/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/restful%20%E9%A3%8E%E6%A0%BC%EF%BC%8C%E5%AE%9A%E4%B9%89http%E6%8E%A5%E5%8F%A3%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</id>
    <published>2025-09-11T03:36:23.155Z</published>
    <updated>2023-02-15T22:50:21.500Z</updated>
    
    <content type="html"><![CDATA[<p>查询书本列表数据<br>get + &#x2F;books&#x2F;<br>请求方式 GET<br>请求路径 &#x2F;books&#x2F;<br>请求参数 无<br>请求返回 json</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">class <span class="hljs-keyword">Books(view):</span><br><span class="hljs-keyword"></span>def get(self, request):<br>  <span class="hljs-keyword">books </span>= <span class="hljs-keyword">books.objects.all()</span><br><span class="hljs-keyword"></span>  <span class="hljs-keyword">book_list </span>= []<br>  fro <span class="hljs-keyword">book </span>in <span class="hljs-keyword">books:</span><br><span class="hljs-keyword"></span>    <span class="hljs-keyword">book_list.addend(&#123;</span><br><span class="hljs-keyword"></span>        <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-keyword">book.id,</span><br><span class="hljs-keyword"></span>        <span class="hljs-string">&#x27;btitle&#x27;</span> : <span class="hljs-keyword">book.btitle,</span><br><span class="hljs-keyword"></span>    &#125;)<br>    <span class="hljs-built_in">context</span> =&#123;<br>        <span class="hljs-string">&#x27;book_list&#x27;</span>： <span class="hljs-keyword">book_list</span><br><span class="hljs-keyword"></span>        &#125;<br>   return <span class="hljs-keyword">JsonResopnse(context, </span>safe =False)<br></code></pre></td></tr></table></figure><p>post+ &#x2F;books&#x2F;<br>请求方式 POST<br>请求路径 &#x2F;books&#x2F;<br>请求参数 data<br>请求返回 json</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">self, request</span>):<br><span class="hljs-comment">#提取参数</span><br>books_info = json.loads(request.body.decode())<br>btile = books_info.get(<span class="hljs-string">&#x27;btile&#x27;</span>)<br>bp = books.get(<span class="hljs-string">&#x27;bp&#x27;</span>)<br><span class="hljs-comment">#校验</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ([bp,btile]):<br>reutrn JsonResopnse(&#123;<span class="hljs-string">&#x27;errmsg&#x27;</span>: <span class="hljs-string">&#x27;缺少必传字段&#x27;</span>&#125;, status = <span class="hljs-number">400</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(btile)&gt;<span class="hljs-number">20</span>:<br><span class="hljs-keyword">return</span> JsonResposne(&#123;<span class="hljs-string">&#x27;errmsg&#x27;</span>: <span class="hljs-string">&#x27;名字过长&#x27;</span>&#125;)<br><span class="hljs-comment">#逻辑业务</span><br><span class="hljs-keyword">try</span>:<br>book = BookInfo.objects.create(**book_info)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br><span class="hljs-keyword">return</span> (&#123;<span class="hljs-string">&#x27;errmsgg&#x27;</span>: <span class="hljs-string">&#x27;内部错误&#x27;</span>&#125;)<br><span class="hljs-comment">#构建返回--restful风格约定更新或者新建之后一定要吧最新资源返回</span><br><span class="hljs-keyword">return</span> JsonResopnse(&#123;<br><span class="hljs-string">&#x27;id&#x27;</span>: book.<span class="hljs-built_in">id</span><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;查询书本列表数据&lt;br&gt;get + &amp;#x2F;books&amp;#x2F;&lt;br&gt;请求方式 GET&lt;br&gt;请求路径 &amp;#x2F;books&amp;#x2F;&lt;br&gt;请求参数 无&lt;br&gt;请求返回 json&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/%E9%9A%8F%E7%AC%94/"/>
    <id>http://mornikar.github.io/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/%E9%9A%8F%E7%AC%94/</id>
    <published>2025-09-11T03:36:23.155Z</published>
    <updated>2023-02-15T22:50:21.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、函数和方法的认知"><a href="#一、函数和方法的认知" class="headerlink" title="一、函数和方法的认知"></a>一、函数和方法的认知</h3><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h1 id="classmethod下定义的func属于方法，-staticmethod下定义的func属于函数。"><a href="#classmethod下定义的func属于方法，-staticmethod下定义的func属于函数。" class="headerlink" title="@classmethod下定义的func属于方法，@staticmethod下定义的func属于函数。"></a>@classmethod下定义的func属于方法，@staticmethod下定义的func属于函数。</h1><h1 id="而类class中定义的普通func要分是类调用还是类对象调用。"><a href="#而类class中定义的普通func要分是类调用还是类对象调用。" class="headerlink" title="而类class中定义的普通func要分是类调用还是类对象调用。"></a>而类class中定义的普通func要分是类调用还是类对象调用。</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">函数是封装了一些独立的功能，可以直接调用，能将一些数据（参数）传递进去进行处理，然后返回一些数据（返回值），也可以没有返回值。可以直接在模块中进行定义使用。所有传递给函数的数据都是显式传递的。<br></code></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">方法和函数类似，同样封装了独立的功能，但是方法是只能依靠类或者对象来调用的，表示针对性的操作。<br>### 方法中的数据self和cls是隐式传递的，即方法的调用者；<br>方法可以操作类内部的数据<br></code></pre></td></tr></table></figure><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs d">当类实例化对象后，如<span class="hljs-string">`apple对象`</span>，再调用<span class="hljs-built_in">function</span>时，<br>普通func，如fun1，就被称为是<span class="hljs-string">`实例化方法`</span>，<br>定义在<span class="hljs-keyword">@staticmethod</span>下的func，与<span class="hljs-keyword">class</span>和实例化对象无关，所以依然属于<span class="hljs-string">`函数`</span>,<br>定义在<span class="hljs-keyword">@classmethod</span>下的func，与<span class="hljs-keyword">class</span>内部有关，属于类的方法。<br></code></pre></td></tr></table></figure><h1 id="测试函数还是方法"><a href="#测试函数还是方法" class="headerlink" title="测试函数还是方法"></a>测试函数还是方法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> FunctionType, MethodType<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(lwd.func, FunctionType))  <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(lwd.func, MethodType))   <span class="hljs-comment"># True   #说明这是一个方法</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(Lwd.func, FunctionType))  <span class="hljs-comment"># True   #说明这是一个函数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(Lwd.func, MethodType))  <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><h1 id="重写管理器对象（自定义manager）"><a href="#重写管理器对象（自定义manager）" class="headerlink" title="重写管理器对象（自定义manager）"></a>重写管理器对象（自定义manager）</h1><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> studentManager(<span class="hljs-title">models</span>.<span class="hljs-type">Manager</span>):</span><br><span class="hljs-class">  def get_queryset(<span class="hljs-title">self</span>):</span><br><span class="hljs-class">    return super(<span class="hljs-title">studentManager</span>,<span class="hljs-title">self</span>).get_queryset().filter(<span class="hljs-title">isDelete</span>=<span class="hljs-type">False</span>)</span><br></code></pre></td></tr></table></figure><p>参数是类<br>def xxx(cls,**yy):<br>self &#x3D; cls(**yy)(实例化对象)</p><p>取出请求方法同名的函数名赋值给handler<br>handler&#x3D;getattr(self,request.method.lower((小写的意思)),self.http_method_not_allowed)<br>return handler(request,*args,**kwargs)</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><br><span class="hljs-number">1</span>. <span class="hljs-comment">### python cls self 讲解</span><br>一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。<br><br>而使用<span class="hljs-variable">@staticmethod</span>或<span class="hljs-variable">@classmethod</span>，就可以不需要实例化，直接类名.方法名()来调用。<br><br>这有利于组织代码，把某些应该属于某个类的函数给放到那个类里去，同时有利于命名空间的整洁。<br><br></code></pre></td></tr></table></figure><p>class A(object):<br>    a &#x3D; ‘a’<br>    @staticmethod<br>    def foo1(name):<br>        print ‘hello’, name<br>    def foo2(self, name):<br>        print ‘hello’, name<br>    @classmethod<br>    def foo3(cls, name):<br>        print ‘hello’, name</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br><br>### <span class="hljs-number">1.</span> Mongodb数据库操作<br>#### serilaizer：<br></code></pre></td></tr></table></figure><p>from rest_framework_mongoengine import serializers</p><p>class ListSerializer(serializers.DocumentSerializer):</p><pre><code>class Meta:    model = Spit    fields = &quot;__all__&quot;</code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### <br>views:<br></code></pre></td></tr></table></figure><p>from rest_framework_mongoengine.viewsets import ModelViewSet</p><p>class ListViewModelSet(ModelViewSet):<br>    # queryset &#x3D; Spit.objects.all()需要转成<br>    # def get_queryset(self):<br>    #         return Spit.objects.all()才能提取</p><pre><code>serializer_class = ListSerializerdef get_queryset(self):    return Spit.objects.all()</code></pre><pre><code>#Python 交换x ,yx , yint z=x; x=y, y=z可以优化为(加空格)x , y = y , x#根据数据库生成模型类创建一个项目，修改seting文件，在setting里面设置要连接的数据库运行下面代码可以自动生成models模型文件 Python manage.py inspectdb 这样就可以在控制台的命令行中看到数据库的模型文件了把模型文件导入到app中 创建一个app django-admin.py startapp app python manage.py inspectdb &gt; app/models.py ok模型文件已经生成好了。下面的工作就和之前一样了简单介绍工厂模式和单例模式工厂模式：　　介绍：　　　　工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程（new 关键字和具体的构造器）隐藏起来。用一个工厂方法来替代，对外提供的只是一个工厂方法，达到提高灵活性的目的。 　　　　优点：　　　　1.隐藏了new关键字和构造器            　2.降低了这个对象与别的类之间的耦合度，提高了程序的可扩展性。 原因：当子类被别的类替代，或者构造器的参数发生变化的时候，只需改动工厂方法内的new即可，改动量降到了最低，直接用new关键字的话，需要改动的地方就很多了            　3.把对象的设计和实现分割开来，从而代码扩展性强、灵活性高。 　　适用范围：       　　 1.在编码时不能预见需要创建哪一个种类的实例。        　　2.一个类使用它的子类来创建对象。        　　3.开发人员不希望创建了那个类的实例以及如何创建实例的信息暴露给外部程序。      　　　　　除了上面提到的例子，工厂模式的实现方式还允许有一些小小的变化，例如：         　　　　基类可以是一个抽象类，在这种情况下，工厂类必须返回一个非抽象类。        　　　　 基类提供了一些缺省方法，只有当这些缺省方法不能满足特殊需求的情况下才能在子类中重写这些方法。         　　　　可以直接通过传递给工厂类的参数决定应该返回哪一个子类的实例。 　　 结构：用一个方法来代替new关键字和构造器。  单例模式：　　介绍：　　　　 1.声明一个私有的，静态的本类对象，但并不在声明的时候就初始化，因此，它的值为null。         　　2.私有化构造器         　　3.对外提供一个全局的，共有的，静态的，唯一的方法，用来获得该实例，但注意的是：必须要手动保持线程同步（synchronized）         　　4.在该方法里，判断对象是否为null，如果是null的话，表示这个类还没有被实例化，就会初始化这个对象，再返回如果不是null的话，就直接返回。　　优点：　　　　整个系统中的所有的类共用一个实例化对象，这样可以有效的节省资源。　　适用特点：　　　　它确保一个类在java虚拟机里只有一个实例，使一个类只有一个对象，整个系统共享这个对象。 　　结构：将构造变成私有的--&gt;做一个静态的生成对象的方法--&gt;造一个静态的存储对象--&gt;return 静态的对象</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、函数和方法的认知&quot;&gt;&lt;a href=&quot;#一、函数和方法的认知&quot; class=&quot;headerlink&quot; title=&quot;一、函数和方法的认知&quot;&gt;&lt;/a&gt;一、函数和方法的认知&lt;/h3&gt;&lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/git/"/>
    <id>http://mornikar.github.io/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/git/</id>
    <published>2025-09-11T03:36:23.154Z</published>
    <updated>2023-02-15T22:50:21.500Z</updated>
    
    <content type="html"><![CDATA[<p>版本查询:sit –version<br>查看当前仓库的状态信息：git status<br>将单个文件加入缓存区：git add(绿了)<br>将所有文件加入缓存区：git add.<br>提交这次变更：git commit -m<message>(message-描述)<br>查看日志：git log<br>将缓存区拿出来：(绿变红)git reset<filename></p><p>生成密钥：ssh-keygen -t rsa<br>查看公钥：cat ~&#x2F;.ssh&#x2F;id_rsa.pub<br>主题部署上线：hexo deploy</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;版本查询:sit –version&lt;br&gt;查看当前仓库的状态信息：git status&lt;br&gt;将单个文件加入缓存区：git add(绿了)&lt;br&gt;将所有文件加入缓存区：git add.&lt;br&gt;提交这次变更：git commit -m&lt;message&gt;(message-描述)</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/DRF%E6%A1%86%E6%9E%B6/"/>
    <id>http://mornikar.github.io/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/DRF%E6%A1%86%E6%9E%B6/</id>
    <published>2025-09-11T03:36:23.153Z</published>
    <updated>2023-02-15T22:50:21.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DRF框架就是RestFramework框架（rest-framework-导入的方式-）"><a href="#DRF框架就是RestFramework框架（rest-framework-导入的方式-）" class="headerlink" title="DRF框架就是RestFramework框架（rest_framework[导入的方式]）"></a>DRF框架就是RestFramework框架（rest_framework[导入的方式]）</h1><ul><li>REF开发模式：前后端分离模式开发的</li><li><ul><li>RESTful</li></ul></li><li>域名<br>  接口设计方法：【大型服务部署放在专有域名下（整个服务器提供此类服务）】</li></ul> <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//api.example.com</span><br></code></pre></td></tr></table></figure><p>小型 子应用：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">https:</span>//example<span class="hljs-meta">.org</span>/api/<br></code></pre></td></tr></table></figure><ul><li>版本（在app后面放版本号）</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://www.example.com/api/<span class="hljs-number">1</span>.<span class="hljs-number">0</span>/foo<br></code></pre></td></tr></table></figure><ul><li><p>路径(名词，复数)<br>遵循restful风格：&#x2F;books&#x2F;</p></li><li><p>#请求动作</p></li><li><p>没pk（id）：<br>get + &#x2F;books&#x2F; &#x3D;&#x3D;&gt; 获取全部对象<br>post + &#x2F;books&#x2F; &#x3D;&#x3D;&gt; 新建一数据</p></li><li><p>有pk：<br>get + &#x2F;books&#x2F; &#x3D;&#x3D;&gt; 获取单一对象<br>put + &#x2F;books&#x2F; &#x3D;&#x3D;&gt; 更新单一对象<br>delete + &#x2F;bookds&#x2F; &#x3D;&#x3D;&gt; 删除单一对象</p></li><li><p>过滤参数<br> 过滤的参数一般是放在查询字符串中携带</p></li><li><p>过滤的参数一般放在查询字符串中携带<br>查询字符串 &#x3D; page</p></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">get</span> + /books/?<span class="hljs-attribute">page</span>=1&amp;page_size = 5<br>分页就是过滤，根据page个page_size查询字符串参数去分页（过滤）<br></code></pre></td></tr></table></figure><ul><li>状态码</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs">200 获取数据成功<br>201 新建、更新成功<br>400 后端校验参数错误<br>401  没身份（匿名用户）<br>403  没有权限<br>404 资源找不到 <br>1（路由错了，路由映射错了）<br>2 （根据pk查询数据库找不到）<br>405 请求方式不被允许<br>（视图类没有重写视图方法）<br>500 后端代码错误<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DRF框架就是RestFramework框架（rest-framework-导入的方式-）&quot;&gt;&lt;a href=&quot;#DRF框架就是RestFramework框架（rest-framework-导入的方式-）&quot; class=&quot;headerlink&quot; title=&quot;DR</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/01/%E5%A4%8D%E4%B9%A0%E7%BB%83%E4%B9%A0%E9%9A%8F%E7%AC%94/"/>
    <id>http://mornikar.github.io/2025/09/11/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/01/%E5%A4%8D%E4%B9%A0%E7%BB%83%E4%B9%A0%E9%9A%8F%E7%AC%94/</id>
    <published>2025-09-11T03:36:23.151Z</published>
    <updated>2023-02-15T22:50:21.496Z</updated>
    
    <content type="html"><![CDATA[<p><attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-804df700-ad2f-4558-b30e-41a5ffda5121"></attachment><p>1.1 变量即是容器</p><p>1.2 变量赋值左赋值给右：变量名&#x3D;变量值</p><p><em>python解释器是由自上而下的，上面定义的函数如相同的变量名，下面会覆盖上面的定义，索引相同。</p><p>数据类型分为数字类型和非数字类型。</p><p>数字类型：int,float,bool,complex</p><p>非数字类型：str,list,tuple,set,dict</p><p>查看type（变量名）</p><p><br></p><p>1.2.1格式化输出:按照一定格式输出到控制台</p><p>1.2.2 类型转换 int（x）转整数 float（x）转浮点数str(x转字符串)</p><p>1.2.3 算术运算符 + - <em> &#x2F; &#x2F;&#x2F; % </em></em></p><p>优先级<em>*&gt;</em>&#x2F;%&#x2F;&#x2F;&gt;+-</p><p>1.3复合合运算符</p><p>+&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; %&#x3D; **&#x3D;</p><p>1.3</p><p>操作系统：承上启下：向下管理硬件，向上支持软件</p><p><br></p><p>python特点：解析性语言</p><p>缺点效率低</p><p>2.1比较运算符 &#x3D;&#x3D; !&#x3D; &gt;&#x3D;&lt;&#x3D;&lt; &gt;</p><p>逻辑运算符and or not</p><p><br></p><p>2.2判断语句：if…elif…else if嵌套</p><p>随机数包： import random</p><p>调用：num&#x3D;random.randint(1,3)【1，3】</p><p><br></p><p>循环语句：while:</p><p>i&#x3D;0</p><p>while i&lt;10:</p><p>pirnt(‘跑地%d圈’%(i+1))</p><p>i+&#x3D;1</p><p>累加</p><p>sum&#x3D;0</p><p>while i&lt;100:</p><p>if i%2:</p><p>sum+&#x3D;i</p><p>i+&#x3D;1</p><p><br></p><p>while循环嵌套</p><p><br></p><p>2.3：break continue</p><p>break 中断，跳出循环体</p><p>continue 跳出本次循环</p><p>就近原则作用</p><p><br></p><p>2.4三目运算</p><p>a if a&gt;b else b</p><p>条件作为中间线，判断左输出a，右输出b 中间条件于变量隔着关键字</p><p><br></p><p><br></p><p>3.列表[]：增删改查，排序</p><p>增加列表.append（值）尾追加</p><p>删除 列表.remove(值) 删除第一个出现的指定数据</p><p>修改：列表【索引】&#x3D;值 数据不存在则报错</p><p>查询：列表【索引】 不存在则报错</p><p>len（列表）列表长度</p><p>if值in列表 判断列表包不含包含值</p><p>列表.sort（）升序</p><p><br></p><p>列表+for循环遍历for…. lese</p><p>while i&lt;len(list):</p><p>bl&#x3D;list【i】</p><p>print(bl)</p><p><br></p><p>if…in &amp;for..in的区别</p><p>判断 遍历</p><p><br></p><p><br></p><p>3.2</p><p>tuple元组() 只包含一个元素的话（a，）元组不能修改</p><p>查询 元组【索引】</p><p>len【元组】</p><p>if 值 in 元组 值是否在元组里</p><p><br></p><p><br></p><p>3.3字典{} 储存多个数据，描述物体相关信息</p><p>用键值对储存”key”:”value”</p><p>值可以任何类型，但key只能字符串，数字，元组</p><p>key必须是唯一的</p><p><br></p><p>增删改查</p><p>增加：字典【键】&#x3D;值 dict1【“age”】&#x3D;20</p><p>删除：字典.pop（key）</p><p>改：字典【键】&#x3D;值</p><p>查：字典【key】 key 不存在报错</p><p>字典。get【key】 key不存在返回None</p><p>遍历字典获取键值对：for key，value in 字典.items()</p><p><br></p><p>3.4字符串</p><p>f-strings字符串新型格式化：</p><p>print（f‘我叫{name}’，年龄‘{age}’）</p><p><br></p><p>重点：</p><p>查找替换分割拼接</p><p>查找：find（目标字符串，开始索引，结束）</p><p><br></p><p>※替换：字符串.replace(旧，新，全局替换次数)</p><p><br></p><p>※分割：字符串.spilt(分隔符)</p><p><br></p><p>※拼接：字符串.join(字符串列表)</p><p>字符串逆序：【::-1】</p><p><br></p><p>3.5列表可以通过集合的类型转换进行去重</p><p><br></p><p>list（x） 转换列表</p><p><br></p><p>tuple（x） 转换元组</p><p><br></p><p>set（x） 转换集合</p><p><br></p><p>3.6运算符：</p><p>+合并*复制</p><p>【1，2】<em>2 &#x3D;【1，2，1，2】</p><p><br></p><p><br></p><p><br></p><p>4.4return返回值</p><p>函数一旦执行return后面代码不会再执行</p><p><br></p><p>4.7global修改全局变量</p><p>num&#x3D;10</p><p>def （）：</p><p>global num</p><p><br></p><p><br></p><p>4.8不定长参数</p><p>元组型不定长参数</em>args 接收任意数量</p><p>def func（*args）</p><p><br></p><p><br></p><p>字典型不定长参数 **kwargs</p><p>def func（name，*<em>kwargs）</p><p>形参name不会被包装在字典里</p><p><br></p><p>func（name&#x3D;“mike”，city&#x3D;‘sz’，age&#x3D;18）</p><p><br></p><p>5.1组包和拆包：</p><p>条件：变量数&#x3D;容器长度</p><p>支持元组、列表、字典拆包</p><p><br></p><p><br></p><p>5.2引用：</p><p>查看引用：print（id（a））</p><p>引用地址相同，说明指向同一个内存空间</p><p>只要每运行一次程序，那么它的地址就会改变</p><p><br></p><p>5.3可变与不可变类型</p><p>可变类型：</p><p>列表list集合set字典dict</p><p>不可变类型：字符串str元组type 数值类型 intbool float</p><p><br></p><p>5.4range</p><p>创建整数列表对象 一般用在for循环</p><p>用法与切片用法一样 range（1，5）[1，5)1-4</p><p><br></p><p><br></p><p><span style="color: rgb(77, 77, 77);">列表推倒式: [结果 for 变量 in 可迭代对象 if 条件筛选]</span></p><p><span style="color: rgb(77, 77, 77);">生成器表达式: (结果 for 变量 in 可迭代对象 if 条件筛选), 没有元组推倒式</span></p><p><span style="color: rgb(77, 77, 77);">字典推倒式: {结果(k:v) for 变量 in 可迭代对象 if 条件筛选}</span></p><p><span style="color: rgb(77, 77, 77);">集合推倒式: {结果(k) for 变量 in 可迭代对象 if 条件筛选} 自带去重功能</span></p><p><br></p><p><span style="color: rgb(77, 77, 77);">5.5列表推导式</span></p><p>每循环一次，将结果添加到列表中</p><p>计算公式可以使用遍历出的数据</p><p>for遍历出的数据必须满足if 判断，才会使用计算公式生成元素</p><p><br></p><p>优点：不会将所有的值一次性加载到内存中，延迟计算，对大数据处理非常有用</p><p>生成器可以使用yield关键字编写，也可以使用生成器表达式把【】改成（）</p><p><br></p><p><br></p><p>5.6匿名函数</p><p>lambda 【形参1】【形参2】：【单行表达式】or【函数调用】</p><p>匿名函数不能使用while循环，for循环，只能编写单行表达式，或者函数调用</p><p>不需要return 自动返回结果</p><p>#无参有返回值：</p><p>（）就是函数名字</p><p>ret &#x3D;（lambda：1+1）（）</p><p>print（ret）</p><p>起函数名字：</p><p>func &#x3D; lambda：1+1</p><p>ret &#x3D; func（）</p><p>print（ret）</p><p><br></p><p>#有参有返回值</p><p>ret &#x3D; （lambda a,b : a-b）(30,10)</p><p>print(ret)</p><p><br></p><p>func &#x3D;lambda a,b :a-b</p><p>ret &#x3D; func(30,10)</p><p>print(ret)</p><p><br></p><p><br></p><p>5.7递归函数</p><p>函数内部调用自身</p><p>一定要有出口</p><p><br></p><p><br></p><p>def func(n):</p><p>ret &#x3D; n</em>func(n-1)</p><p>returnret</p><p><br></p><p>_ret &#x3D; func(3)</p><p>print(_ret)</p><p><br></p><p><br></p><p>5.8enumerate del</p><p>for 配合enumerate 遍历容器时可以获得元素索引</p><p>del删除列表元素</p><p>del list[1]</p><p><br></p><p>5.9文件版学生名片管理系统</p><p>str（）</p><p>eval（）（返回传入字符串内容结果，字符串里面看到像是什么，就转换成什么）</p><p><br></p><p>6.1 文件打开与关闭</p><p>只读：r 写入: w</p><p>格式：with open(‘123.txt , ‘’w’)as f:</p><p>pass</p><p><br></p><p>6.2</p><p>写数据：</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;attachment contenteditable=&quot;false&quot; data-atts=&quot;%5B%5D&quot; data-aid=&quot;.atts-804df700-ad2f-4558-b30e-41a5ffda5121&quot;&gt;&lt;/attachment&gt;&lt;p&gt;1.1 变量即是容器&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/newnote_1602030880118/"/>
    <id>http://mornikar.github.io/2025/09/11/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/newnote_1602030880118/</id>
    <published>2025-09-11T03:36:23.148Z</published>
    <updated>2023-02-15T22:50:21.496Z</updated>
    
    <content type="html"><![CDATA[<p><attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-d3a7185c-ffab-46af-83f1-ba2b341e4abe"></attachment><p><br></p></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;attachment contenteditable=&quot;false&quot; data-atts=&quot;%5B%5D&quot; data-aid=&quot;.atts-d3a7185c-ffab-46af-83f1-ba2b341e4abe&quot;&gt;&lt;/attachment&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/"/>
    <id>http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/</id>
    <published>2025-09-11T03:36:23.145Z</published>
    <updated>2023-02-15T22:50:21.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="M行-N列-N行-L列-M行-L列"><a href="#M行-N列-N行-L列-M行-L列" class="headerlink" title="(M行, N列)*(N行, L列) &#x3D; (M行, L列)"></a>(M行, N列)*(N行, L列) &#x3D; (M行, L列)</h1><p>C &#x3D; A x B</p><h1 id="c-1-1-（1行1-1列1）-（1行2-1列2）…"><a href="#c-1-1-（1行1-1列1）-（1行2-1列2）…" class="headerlink" title="c(1,1) &#x3D; （1行1 * 1列1）+ （1行2 *1列2）…"></a>c(1,1) &#x3D; （1行1 * 1列1）+ （1行2 *1列2）…</h1><h1 id="c-1-2-（1行1-2列1）-（1行2-2列2）…"><a href="#c-1-2-（1行1-2列1）-（1行2-2列2）…" class="headerlink" title="c(1,2) &#x3D; （1行1 * 2列1）+ （1行2 *2列2）…"></a>c(1,2) &#x3D; （1行1 * 2列1）+ （1行2 *2列2）…</h1><h1 id="矩阵乘法的性质"><a href="#矩阵乘法的性质" class="headerlink" title="矩阵乘法的性质"></a>矩阵乘法的性质</h1><p>矩阵的乘法不满足交换律：A×B≠B×A</p><p>矩阵的乘法满足结合律。即：A×（B×C）&#x3D;（A×B）×C</p><p>单位矩阵：在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的 1,我们称 这种矩阵为单位矩阵．它是个方阵，一般用 I 或者 E 表示，从 左上角到右下角的对角线（称为主对角线）上的元素均为 1 以外全都为 0</p><h1 id="矩阵乘法api："><a href="#矩阵乘法api：" class="headerlink" title="矩阵乘法api："></a>矩阵乘法api：</h1><p>np.matmul<br>np.dot</p><h1 id="np-matmul和np-dot的区别"><a href="#np-matmul和np-dot的区别" class="headerlink" title="np.matmul和np.dot的区别:"></a>np.matmul和np.dot的区别:</h1><p>二者都是矩阵乘法。 np.matmul中禁止矩阵与标量的乘法。 在矢量乘矢量的內积运算中，np.matmul与np.dot没有区别。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;M行-N列-N行-L列-M行-L列&quot;&gt;&lt;a href=&quot;#M行-N列-N行-L列-M行-L列&quot; class=&quot;headerlink&quot; title=&quot;(M行, N列)*(N行, L列) &amp;#x3D; (M行, L列)&quot;&gt;&lt;/a&gt;(M行, N列)*(N行, L列) &amp;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</id>
    <published>2025-09-11T03:36:23.144Z</published>
    <updated>2023-02-15T22:50:21.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法分为："><a href="#算法分为：" class="headerlink" title="算法分为："></a>算法分为：</h1><ol><li>监督学习</li></ol><ul><li>定义：输入数据是由输入特征值和目标值所组成<ul><li>函数的输出可以是连续的值（回归）</li><li>或是输出有限个离散值（分类）</li></ul></li></ul><ol start="2"><li>无监督学习</li></ol><ul><li>定义：输入数据是由输入特征值组成，没有目标值<ul><li>输入数据没有被标记，也没有确定的结果。样本数据类别未知</li><li>需要根据样本间的相似性对样本集进行类别划分</li></ul></li></ul><ol start="3"><li>半监督学习</li></ol><ul><li>定义训练集同时包含有标记样本数据和未标记样本数据</li></ul><ol start="4"><li>强化学习</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">InOut目的案例<br>监督学习<br>(supervised learning)有标签有反馈 预测结果猫狗分类 房价预测<br>无监督学习<br>(unsupervised learning)无标签无反馈   发现潜在结构“物以类聚，人以群分”<br>半监督学习<br>(Semi-Supervised Learning) 部分  有标签，     部分无标签有反馈降低数据标记的难度<br>强化学习<br>(reinforcement learning) 决策流程及激励系统 一系列行动长期利益最大化学下棋<br></code></pre></td></tr></table></figure><h1 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h1><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">1.获取数据<br><br>2.数据基本处理<br><span class="hljs-bullet">- </span>1.缩小数据集范围DataFrame.query()<br><span class="hljs-bullet">- </span>2.选取有用的时间特征<br><span class="hljs-bullet">- </span>3.将签到位置少于n个用户的删除<br><br>3.特征工程<br><span class="hljs-bullet">- </span>特征提取<br><span class="hljs-bullet">- </span>特征预处理<br><span class="hljs-bullet">- </span>特征降维<br><span class="hljs-bullet">- </span>特征预处理(标准化)<br><br>4.机器学习(模型训练)<br><br>5.模型评估<br><span class="hljs-bullet">- </span>结果达到要求，上线服务<br><span class="hljs-bullet">- </span>没有达到要求，重新上面步骤<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法分为：&quot;&gt;&lt;a href=&quot;#算法分为：&quot; class=&quot;headerlink&quot; title=&quot;算法分为：&quot;&gt;&lt;/a&gt;算法分为：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;监督学习&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;定义：输入数据是由输入特征值和目标值所组成&lt;ul&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/pandas/"/>
    <id>http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/pandas/</id>
    <published>2025-09-11T03:36:23.143Z</published>
    <updated>2023-02-15T22:50:21.500Z</updated>
    
    <content type="html"><![CDATA[<p>创建Series</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <br>s = pd.Series([<span class="hljs-string">&#x27;banana&#x27;</span>,<span class="hljs-number">42</span>])<br></code></pre></td></tr></table></figure><p>创建DataFrame</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">name_list = pd<span class="hljs-selector-class">.DataFrame</span>(<br>&#123;<br><span class="hljs-string">&#x27;Name&#x27;</span>:<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Tome&#x27;</span>,<span class="hljs-string">&#x27;Bob&#x27;</span>]</span>, <br><span class="hljs-string">&#x27;Occupation&#x27;</span>:<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Teacher&#x27;</span>,<span class="hljs-string">&#x27;IT Engineer&#x27;</span>]</span>, <br><span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-selector-attr">[28,36]</span><br>&#125;<br>)<br></code></pre></td></tr></table></figure><h1 id="Series-常用操作"><a href="#Series-常用操作" class="headerlink" title="Series 常用操作"></a>Series 常用操作</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">loc使用索引值取子集<br>iloc 使用索引位置取子集<br>dtype或dtypes Series内容的类型<br>T Series的转置矩阵<br>shape 数据的维数<br>size Series中元素的数量<br>values Series的值<br><span class="hljs-selector-class">.value_counts</span>()统计value数量<br>director<span class="hljs-selector-class">.count</span>() 返回非空值<br><span class="hljs-function"><span class="hljs-title">describe</span><span class="hljs-params">()</span></span> 打印描述信息<br></code></pre></td></tr></table></figure><h1 id="Series的一些方法"><a href="#Series的一些方法" class="headerlink" title="Series的一些方法"></a>Series的一些方法</h1><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">方法 说明<br><span class="hljs-variable">append</span> 连接两个或多个<span class="hljs-built_in">Series</span><br><span class="hljs-variable">corr</span> 计算与另一个<span class="hljs-built_in">Series</span>的相关系数<br><span class="hljs-variable">cov</span> 计算与另一个<span class="hljs-built_in">Series</span>的协方差<br><span class="hljs-variable">describe</span> 计算常见统计量<br><span class="hljs-type">drop_duplicates</span> 返回去重之后的<span class="hljs-built_in">Series</span><br><span class="hljs-variable">equals</span> 判断两个<span class="hljs-built_in">Series</span>是否相同<br><span class="hljs-type">get_values</span> 获取<span class="hljs-built_in">Series</span>的值，作用与<span class="hljs-variable">values</span>属性相同<br><span class="hljs-variable">hist</span> 绘制直方图<br><span class="hljs-variable">isin</span> <span class="hljs-built_in">Series</span>中是否包含某些值<br><span class="hljs-variable">min</span> 返回最小值<br><span class="hljs-variable">max</span>返回最大值<br><span class="hljs-variable">mean</span>返回算术平均值<br><span class="hljs-variable">median</span>返回中位数<br><span class="hljs-variable">mode</span> 返回众数<br><span class="hljs-variable">quantile</span> 返回指定位置的分位数<br><span class="hljs-variable">replace</span> 用指定值代替<span class="hljs-built_in">Series</span>中的值<br><span class="hljs-variable">sample</span> 返回<span class="hljs-built_in">Series</span>的随机采样值<br><span class="hljs-type">sort_values</span> 对值进行排序<br><span class="hljs-type">to_frame</span>把<span class="hljs-built_in">Series</span>转换为<span class="hljs-variable">DataFrame</span><br><span class="hljs-variable">unique</span> 去重返回数组<br></code></pre></td></tr></table></figure><p>两个Series之间计算，如果Series元素个数相同，则将两个Series对应元素进行计算；元素不同则缺失用NaN表示</p><h1 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ndim 查看数集的维度<br>set_index 修改索引<br>drop 删除列<br>to_pickle 保存<br>read_pickle 读取<br>to_csv  保存成csv文件<br>格式：(<span class="hljs-string">&#x27;output/scientists_df.tsv&#x27;</span>,sep=<span class="hljs-string">&#x27;\t&#x27;</span>)<br><br><br><br>to_clipboard 把数据保存到系统剪贴板，方便粘贴<br>to_dict 把数据转换成Python字典<br>to_hdf 把数据保存为HDF格式<br>to_html 把数据转换成HTML<br>to_json 把数据转换成JSON字符串<br>to_sql 把数据保存到SQL数据库<br><br><span class="hljs-function"><span class="hljs-title">nlargest</span><span class="hljs-params">(<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;imdb_score&#x27;</span>)</span></span><br><br><span class="hljs-number">0.1</span><br>统计数值列，并进行转置<br>college<span class="hljs-selector-class">.describe</span>()<span class="hljs-selector-class">.T</span><br><br>统计多方式数值<br><span class="hljs-selector-class">.describe</span>()<br><br>nlargest方法显示出某列的排序<br><span class="hljs-function"><span class="hljs-title">nlargest</span><span class="hljs-params">(<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;imdb_score&#x27;</span>)</span></span><span class="hljs-selector-class">.head</span>()<br><br>传入一个字典<br><span class="hljs-function"><span class="hljs-title">agg</span><span class="hljs-params">(<span class="hljs-string">&#x27;key&#x27;</span>:<span class="hljs-string">&#x27;value&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><h1 id="聚合重点"><a href="#聚合重点" class="headerlink" title="聚合重点"></a>聚合重点</h1><p>agg</p><h1 id="数据链接"><a href="#数据链接" class="headerlink" title="数据链接"></a>数据链接</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">concat把<span class="hljs-built_in">dataframe</span>(简单叠堆)<br>ignore_index = True忽略后面DataFrame的索引<br><br>添加列（默认添加行）<br>，传入参数 axis = <span class="hljs-attribute">columns</span><br>col_concat = pd<span class="hljs-selector-class">.concat</span>(<span class="hljs-selector-attr">[df1,df2,df3]</span>,axis=<span class="hljs-number">1</span>)<br><br>向DataFrame添加一列，不需要调用函数，通过dataframe<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;列名&#x27;</span>]</span> = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;值&#x27;</span>]</span> 即可<br><br></code></pre></td></tr></table></figure><h1 id="链接数据库"><a href="#链接数据库" class="headerlink" title="链接数据库"></a>链接数据库</h1><p>pd.read_sql_table<br>从数据库中读取表，第一个参数是表名，第二个参数是数据库连接对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql">how <span class="hljs-operator">=</span> ’<span class="hljs-keyword">left</span>‘ 对应<span class="hljs-keyword">SQL</span>中的 <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> 保留左侧表中的所有key<br>how <span class="hljs-operator">=</span> ’<span class="hljs-keyword">right</span>‘ 对应<span class="hljs-keyword">SQL</span>中的 <span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> 保留右侧表中的所有key<br>how <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;outer&#x27;</span> 对应<span class="hljs-keyword">SQL</span>中的 <span class="hljs-keyword">full</span> <span class="hljs-keyword">outer</span> 保留左右两侧侧表中的所有key<br>how <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;inner&#x27;</span> 对应<span class="hljs-keyword">SQL</span>中的 <span class="hljs-keyword">inner</span> 只保留左右两侧都有的key<br><br>转换：<br>to_timedelta 将Milliseconds列转变为timedelta数据类型<br>dt.<span class="hljs-built_in">floor</span>(<span class="hljs-string">&#x27;s&#x27;</span>) dt.<span class="hljs-built_in">floor</span>() 时间类型数据，按指定单位截断数据<br><br>DataFrame的assign方法：创建新列<br>.assign<br><br><span class="hljs-keyword">join</span>合并，依据两个DataFrame的行索引，如果合并的两个数据有相同的列名，需要通过lsuffix，和rsuffix，指定合并后的列名<br>的前缀<br>stocks_2016.join(stocks_2017, lsuffix<span class="hljs-operator">=</span><span class="hljs-string">&#x27;_2016&#x27;</span>, rsuffix<span class="hljs-operator">=</span><span class="hljs-string">&#x27;_2017&#x27;</span>, how<span class="hljs-operator">=</span><span class="hljs-string">&#x27;outer&#x27;</span>)<br><br>concat, <span class="hljs-keyword">join</span>, 和<span class="hljs-keyword">merge</span>的区别<br><br>concat ：<br>Pandas函数<br>可以垂直和水平地连接两个或多个pandas对象<br>只用索引对齐<br>默认是外连接（也可以设为内连接）<br><span class="hljs-keyword">join</span> ：<br>DataFrame方法<br>只能水平连接两个或多个pandas对象<br>对齐是靠被调用的DataFrame的列索引或行索引和另一个对象的行索引（不能是列索引）<br>通过笛卡尔积处理重复的索引值<br>默认是左连接（也可以设为内连接、外连接和右连接）<br><span class="hljs-keyword">merge</span> ：<br>DataFrame方法<br>只能水平连接两个DataFrame对象<br>对齐是靠被调用的DataFrame的列或行索引和另一个DataFrame的列或行索引<br>通过笛卡尔积处理重复的索引值<br>默认是内连接（也可以设为左连接、外连接、右连接）<br></code></pre></td></tr></table></figure><h1 id="缺失数据处理"><a href="#缺失数据处理" class="headerlink" title="缺失数据处理"></a>缺失数据处理</h1><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">keep_default_na = <span class="hljs-keyword">False</span> 关闭NaN显示<br>ffill 填充，用时间序列中空值的上一个非空值填充<br>city_day.fillna(<span class="hljs-keyword">method</span>=&#x27;<span class="hljs-title function_">ffill</span>&#x27;,<span class="hljs-title function_">inplace</span>=<span class="hljs-title function_">True</span>) <span class="hljs-title function_">city_day</span>[&#x27;<span class="hljs-title function_">Xylene</span>&#x27;][50:<span class="hljs-number">65</span>]<br>用时间序列中空值的下一个非空值填充<br><span class="hljs-keyword">method</span>=&#x27;<span class="hljs-title function_">bfill</span>&#x27;<br>线性差值方法<br><span class="hljs-title function_">limit_direction</span>=&quot;<span class="hljs-title function_">both</span>&quot;<br></code></pre></td></tr></table></figure><h1 id="整理数据"><a href="#整理数据" class="headerlink" title="整理数据"></a>整理数据</h1><p>melt<br>既可以用pd.melt, 也可使用dataframe.melt()</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs smali">frame dataframe 被 melt 的数据集名称在 pd.melt() 中使用<br>id_vars tuple/list/ndarray 可选项不需要被转换的列名，在转换后作为标识符列（不是索引列）<br>value_vars tuple/list/ndarray 可选项需要被转换的现有列如果未指明，除 id_vars 之外的其他列都被转换<br>var_name string variable 默认值自定义列名名称设置由 &#x27;value_vars&#x27; 组成的新的 column name<br>value_name string value 默认值自定义列名名称设置由 &#x27;value_vars&#x27; 的数据组成的新的 column name<br>col_level<span class="hljs-built_in"> int/string </span>可选项如果列是MultiIndex，则使用此级别<br><br>数据整理（函数自动处理）<br>pew_long = pd.melt(pew,id_vars=&#x27;religion&#x27;)<br>pew_long<br></code></pre></td></tr></table></figure><h1 id="处理查询冗余"><a href="#处理查询冗余" class="headerlink" title="处理查询冗余"></a>处理查询冗余</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">对于同一首歌曲来说，歌曲信息是完全一样的，可以考虑单独保存歌曲信息<br>减少上表中保存的歌曲信息，可以节省存储空间，需要完整信息的时候，可以通过merge拼接数据<br>我们可以把year,artist,track,time和date.entered放入一个新的dataframe中<br><br><span class="hljs-number">1</span>.提取表信息，进行去重<br>illboard_songs = bill_borad_long<span class="hljs-selector-attr">[[<span class="hljs-string">&#x27;year&#x27;</span>,<span class="hljs-string">&#x27;artist&#x27;</span>,<span class="hljs-string">&#x27;track&#x27;</span>,<span class="hljs-string">&#x27;time&#x27;</span>,<span class="hljs-string">&#x27;date.entered&#x27;</span>]</span>] billboard_songs = billboard_songs<span class="hljs-selector-class">.drop_duplicates</span>()<br>billboard_songs<br><br><span class="hljs-number">2</span>.为新拆分处理出来的数据添加ID列（添加ID）<br>billboard_songs<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;id&#x27;</span>]</span> = <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(billboard_songs)) <br>billboard_songs<br><br><span class="hljs-number">3</span>.数据拆分成两个dataframe：billboard_songs和 billboard_ratings<br>取出每周评分，去掉冗余部分<br>billboard_ratings = bill_borad_long<span class="hljs-selector-class">.merge</span>(billboard_songs,on=<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;year&#x27;</span>,<span class="hljs-string">&#x27;artist&#x27;</span>,<span class="hljs-string">&#x27;track&#x27;</span>,<span class="hljs-string">&#x27;time&#x27;</span>,<span class="hljs-string">&#x27;date.entered&#x27;</span>]</span>) billboard_ratings = billboard_ratings<span class="hljs-selector-attr">[[<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-string">&#x27;week&#x27;</span>,<span class="hljs-string">&#x27;rating&#x27;</span>]</span>] billboard_ratings<br><br><span class="hljs-number">4</span>.用merage还原数据<br>billboard_songs<span class="hljs-selector-class">.merge</span>(billboard_ratings,on=<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;id&#x27;</span>]</span>)<br><br></code></pre></td></tr></table></figure><h1 id="stack整理数据"><a href="#stack整理数据" class="headerlink" title="stack整理数据"></a>stack整理数据</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">用rename_axis给不同的行索引层级命名<br><span class="hljs-function"><span class="hljs-title">reset_index</span><span class="hljs-params">()</span></span>，将结果变为DataFrame<br></code></pre></td></tr></table></figure><h1 id="wide-to-long整理数据"><a href="#wide-to-long整理数据" class="headerlink" title="wide_to_long整理数据"></a>wide_to_long整理数据</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">stubs = [<span class="hljs-string">&#x27;actor&#x27;</span>, <span class="hljs-string">&#x27;actor_facebook_likes&#x27;</span>]<br>actor2_tidy = pd.wide_to_long(actor2, <span class="hljs-attribute">stubnames</span>=stubs, i=[<span class="hljs-string">&#x27;movie_title&#x27;</span>], <span class="hljs-attribute">j</span>=<span class="hljs-string">&#x27;actor_num&#x27;</span>, <span class="hljs-attribute">sep</span>=<span class="hljs-string">&#x27;_&#x27;</span>).reset_index() <br>actor2_tidy.head()<br></code></pre></td></tr></table></figure><h1 id="unstack-处理数据"><a href="#unstack-处理数据" class="headerlink" title="unstack 处理数据"></a>unstack 处理数据</h1><p>之前介绍了stack，unstack可以将stack的结果恢复</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">state_fruit<span class="hljs-selector-class">.stack</span>()<span class="hljs-selector-class">.unstack</span>()<br></code></pre></td></tr></table></figure><h1 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h1><p>.apply(方法名)</p><h1 id="向量函数"><a href="#向量函数" class="headerlink" title="向量函数"></a>向量函数</h1><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gml">def avg_2_mod(<span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span>):<br> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">x</span>==<span class="hljs-number">20</span>): <br><span class="hljs-keyword">return</span> (np.<span class="hljs-symbol">NaN</span>) <br><span class="hljs-keyword">else</span>:<span class="hljs-keyword">return</span> (<span class="hljs-variable language_">x</span>+<span class="hljs-variable language_">y</span>)/<span class="hljs-number">2</span> <br>avg_2_mod(df[<span class="hljs-string">&#x27;a&#x27;</span>],df[<span class="hljs-string">&#x27;b&#x27;</span>])<br>上面函数中, <span class="hljs-variable language_">x</span>==<span class="hljs-number">20</span> , <span class="hljs-variable language_">x</span> 是向量, 但<span class="hljs-number">20</span>是标量, 不能直接计算. 这个时候可以使用np.vectorize将函数向量化<br>使用装饰器<br>@np.vectorize <br>def vec_avg_2_mod(<span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span>): <br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">x</span>==<span class="hljs-number">20</span>):<br> <span class="hljs-keyword">return</span> (np.<span class="hljs-symbol">NaN</span>) <br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">return</span> (<span class="hljs-variable language_">x</span>+<span class="hljs-variable language_">y</span>)/<span class="hljs-number">2</span> <br>vec_avg_2_mod(df[<span class="hljs-string">&#x27;a&#x27;</span>],df[<span class="hljs-string">&#x27;b&#x27;</span>])<br></code></pre></td></tr></table></figure><h1 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h1><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">df.apply(lambda <span class="hljs-variable language_">x</span>: <span class="hljs-variable language_">x</span>+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="Pandas内置的聚合方法"><a href="#Pandas内置的聚合方法" class="headerlink" title="Pandas内置的聚合方法"></a>Pandas内置的聚合方法</h1><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Pandas方法 Numpy函数 说明<br>count <span class="hljs-built_in">np</span>.count_nonzero 频率统计(不包含NaN值)<br>size 频率统计(包含NaN值)<br><span class="hljs-built_in">mean</span> <span class="hljs-built_in">np</span>.<span class="hljs-built_in">mean</span> 求平均值<br><span class="hljs-built_in">std</span> <span class="hljs-built_in">np</span>.<span class="hljs-built_in">std</span> 标准差<br><span class="hljs-built_in">min</span> <span class="hljs-built_in">np</span>.<span class="hljs-built_in">min</span> 最小值<br><span class="hljs-built_in">quantile</span>() <span class="hljs-built_in">np</span>.percentile() 分位数<br><span class="hljs-built_in">max</span> <span class="hljs-built_in">np</span>.<span class="hljs-built_in">max</span> 求最大值<br><span class="hljs-built_in">sum</span> <span class="hljs-built_in">np</span>.<span class="hljs-built_in">sum</span> 求和<br><span class="hljs-built_in">var</span> <span class="hljs-built_in">np</span>.<span class="hljs-built_in">var</span> 方差<br><span class="hljs-built_in">describe</span> 计数、平均值、标准差，最小值、分位数、最大值<br><span class="hljs-built_in">first</span> 返回第一行<br><span class="hljs-built_in">last</span> 返回最后一行<br>nth 返回第N行(Python从<span class="hljs-number">0</span>开始计数)<br></code></pre></td></tr></table></figure><p>agg<br>agg.(‘列名’:’方法名’).rename(‘原名’：’新名’)</p><h1 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h1><p>transform 转换，需要把DataFrame中的值传递给一个函数， 而后由该函数”转换”数据。<br>aggregate(聚合) 返回单个聚合值，但transform 不会减少数据量</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gml"># 计算z-<span class="hljs-variable language_">score</span> <span class="hljs-variable language_">x</span> - 平均值/标准差 <br>def my_zscore(<span class="hljs-variable language_">x</span>): <br><span class="hljs-keyword">return</span> (<span class="hljs-variable language_">x</span>-<span class="hljs-variable language_">x</span>.<span class="hljs-built_in">mean</span>())/<span class="hljs-variable language_">x</span>.std()<br> #按年分组 计算z-<span class="hljs-variable language_">score</span> <br>df.groupby(<span class="hljs-string">&#x27;year&#x27;</span>).lifeExp.transform(my_zscore)<br></code></pre></td></tr></table></figure><h1 id="transform分组填充缺失值"><a href="#transform分组填充缺失值" class="headerlink" title="transform分组填充缺失值"></a>transform分组填充缺失值</h1><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell">之前介绍了填充缺失值的各种方法，对于某些数据集，可以使用列的平均值来填充缺失值。某些情况下，可以考虑将列进行分组，分<br>组之后取平均再填充缺失值<br><span class="hljs-title">tips_10</span> = pd.read_csv(&#x27;<span class="hljs-class"><span class="hljs-keyword">data</span>/tips.csv&#x27;).sample(10,<span class="hljs-title">random_state</span> = 42) </span><br><span class="hljs-title">tips_10</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;创建Series&lt;/p&gt;
&lt;figure class=&quot;highlight clean&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Numpy/"/>
    <id>http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Numpy/</id>
    <published>2025-09-11T03:36:23.142Z</published>
    <updated>2023-02-15T22:50:21.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成数组"><a href="#生成数组" class="headerlink" title="生成数组"></a>生成数组</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-comment"># 从现有的数组当中创建</span><br><span class="hljs-attribute">a1</span> = np.array(a)<br><span class="hljs-comment"># 相当于索引的形式，并没有真正的创建一个新的</span><br><span class="hljs-attribute">a2</span> = np.asarray(a)<br></code></pre></td></tr></table></figure><p> 关于array和asarray的不同</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">等于创建一个软链接<br>当数组赋值给另外一个变量后，<br><span class="hljs-keyword">array</span>：修改变量不会改变<br>asarray： 会跟着改变<br></code></pre></td></tr></table></figure><p>生成各种不同的数组</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">生成固定范围的数组<br><br>np.linspace (<span class="hljs-built_in">start</span>, <span class="hljs-built_in">stop</span>, <span class="hljs-built_in">num</span>, endpoint)<br>参数:<br><span class="hljs-built_in">start</span>:序列的起始值<br><span class="hljs-built_in">stop</span>:序列的终止值<br><span class="hljs-built_in">num</span>:要生成的等间隔样例数量，默认为<span class="hljs-number">50</span><br>endpoint:序列中是否包含<span class="hljs-built_in">stop</span>值，默认为ture<br><br>等差数组<br><br>np.arange(<span class="hljs-built_in">start</span>,<span class="hljs-built_in">stop</span>, step, dtype)<br><br><br>参数<br>step:步长,默认值为<span class="hljs-number">1</span><br>np.arange(<span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">2</span>)<br><br>等比数组<br><br>np.logspace(<span class="hljs-built_in">start</span>,<span class="hljs-built_in">stop</span>, <span class="hljs-built_in">num</span>)<br><span class="hljs-built_in">num</span>:要生成的等比数列数量，默认为<span class="hljs-number">50</span><br><br> 生成随机数组<br>np.<span class="hljs-built_in">random</span>   <br><br></code></pre></td></tr></table></figure><p>正态分布创建方法</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs fortran">准正态分布中返回一个或多个样本值<br>np.random.randn(d0, d1, …, dn)<br><br><br><br>np.random.normal(loc=<span class="hljs-number">0.0</span>, <span class="hljs-built_in">scale</span>=<span class="hljs-number">1.0</span>, <span class="hljs-built_in">size</span>=<span class="hljs-keyword">None</span>)<br><br>loc：<span class="hljs-built_in">float</span><br><br>​ 此概率分布的均值（对应着整个分布的中心centre）<br><br><span class="hljs-built_in">scale</span>：<span class="hljs-built_in">float</span><br><br>​ 此概率分布的标准差（对应于分布的宽度，<span class="hljs-built_in">scale</span>越大越矮胖，<span class="hljs-built_in">scale</span>越小，越瘦高）<br><br><span class="hljs-built_in">size</span>：<span class="hljs-built_in">int</span> or tuple of ints<br><br>​ 输出的<span class="hljs-built_in">shape</span>，默认为<span class="hljs-keyword">None</span>，只输出一个值<br><br><br>返回指定形状的标准正态分布的数组。<br>np.random.standard_normal(<span class="hljs-built_in">size</span>=<span class="hljs-keyword">None</span>)<br></code></pre></td></tr></table></figure><h1 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">np.random.rand(d0, d1, <span class="hljs-built_in">..</span>., dn)<br>返回一组均匀分布的数。<br><br><br>从一个均匀分布[low,high)中随机采样，注意定义域是左闭右开，即包含low，不包含high.<br>np.random.uniform(<span class="hljs-attribute">low</span>=0.0, <span class="hljs-attribute">high</span>=1.0, <span class="hljs-attribute">size</span>=None<br><br><br><br>均匀分布中随机采样，生成一个整数或N维整数数组<br>np.random.randint(low, <span class="hljs-attribute">high</span>=None, <span class="hljs-attribute">size</span>=None, <span class="hljs-attribute">dtype</span>=<span class="hljs-string">&quot;l&quot;</span>)<br>取数范围：若high不为None时，取[low,high)之间随机整数，否则取值[0,low)之间随机整数。<br><br><br><br></code></pre></td></tr></table></figure><h1 id="形状修改"><a href="#形状修改" class="headerlink" title="形状修改"></a>形状修改</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">返回一个具有相同数据域，但shape不一样的视图<br>行、列不进行互换<br>ndarray<span class="hljs-selector-class">.reshape</span>(shape, <span class="hljs-attribute">order</span>)<br><br><br>修改数组本身的形状（需要保持元素个数前后相同）<br>行、列不进行互换<br><br>ndaarray<span class="hljs-selector-class">.resize</span>(new_shape)<br><br><br>数组的转置<br>将数组的行、列进行互换<br><br>ndaarray<span class="hljs-selector-class">.T</span><br><br><br></code></pre></td></tr></table></figure><h1 id="类型修改"><a href="#类型修改" class="headerlink" title="类型修改"></a>类型修改</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">返回修改了类型之后的数组<br>stock_change.astype(np.int32)<br><br><br><br>构造包含数组中原始数据字节的Python字节<br>  arr = np.array(<span class="hljs-string">[[[1, 2, 3], [4, 5, 6]]</span>, <span class="hljs-string">[[12, 3, 34], [5, 6, 7]]</span>])<br>arr.<span class="hljs-built_in">tostring</span>()<br></code></pre></td></tr></table></figure><h1 id="返回给定的形状哥类型的新数组，用0填充"><a href="#返回给定的形状哥类型的新数组，用0填充" class="headerlink" title="返回给定的形状哥类型的新数组，用0填充"></a>返回给定的形状哥类型的新数组，用0填充</h1><p>numpy.zeros(shape，dtype&#x3D;float，order &#x3D; ‘C’)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">返回给定形状和类型的新数组，用<span class="hljs-number">0</span>填充。<br><br>参数：<br>shape：<span class="hljs-type">int</span> 或 <span class="hljs-type">int</span> 的元组<br><br> 新阵列的形状，例如：（<span class="hljs-number">2</span>，<span class="hljs-number">3</span>）或<span class="hljs-number">2</span>。<br> dtype：数据类型，可选<br> 数组的所需数据类型，例如numpy.int8。默认是numpy.float64<br> <span class="hljs-keyword">order</span>：&#123;<span class="hljs-string">&#x27;C&#x27;</span>，<span class="hljs-string">&#x27;F&#x27;</span>&#125;，可选，默认：<span class="hljs-string">&#x27;C&#x27;</span><br> 是否在内容中以行（C）或列（F）顺序存储多维数据。<br>返回：<span class="hljs-keyword">out</span>：ndarray<br> 具有给定形状，类型和顺序的<span class="hljs-number">0</span>的数组。<br><br><br>np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br><span class="hljs-keyword">Out</span>[<span class="hljs-number">2</span>]: <br><span class="hljs-keyword">array</span>([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],<br>       [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>]])<br></code></pre></td></tr></table></figure><p>分组频数计算</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">mean</span><span class="hljs-params">()</span></span> 取平均值<br>nunique方法计算pandas Series的唯一值计算（去重）<br>value_counts方法获取pandas Series的频数统计<br><br></code></pre></td></tr></table></figure><h1 id="to-numeric-函数"><a href="#to-numeric-函数" class="headerlink" title="to_numeric 函数"></a>to_numeric 函数</h1><p>变量转换为数值类型（int，float）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">DataFrame每一列的数据类型必须相同，当有些数据中有缺失，但不是NaN时（如missing,null等），会使整列数据变成字符串<br>类型而不是数值型，这个时候可以使用to_numeric处理<br><br>pd<span class="hljs-selector-class">.to_numeric</span>(tips_sub_miss<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;total_bill&#x27;</span>]</span>)<br><br>to_numeric函数有一个参数errors,它决定了当该函数遇到无法转换的数值时该如何处理<br>默认情况下,该值为raise,如果to_numeric遇到无法转换的值时,会抛错<br>coerce: 如果to_numeric遇到无法转换的值时,会返回NaN<br>ignore: 如果to_numeric遇到无法转换的值时会放弃转换,什么都不做<br>pd<span class="hljs-selector-class">.to_numeric</span>(tips_sub_miss<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;total_bill&#x27;</span>]</span>,errors = <span class="hljs-string">&#x27;ignore&#x27;</span>)<br><br><br>to_numeric向下转型<br>to_numeric函数还有一个downcast参数, downcast接受的参数为 <span class="hljs-string">&#x27;integer&#x27;</span>,<span class="hljs-string">&#x27;signed&#x27;</span>,<span class="hljs-string">&#x27;float&#x27;</span>,<span class="hljs-string">&#x27;unsigned&#x27;</span><br>downcast参数设置为<span class="hljs-attribute">float</span>之后, total_bill的数据类型由float64变为float32<br><br>pd<span class="hljs-selector-class">.to_numeric</span>(tips_sub_miss<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;total_bill&#x27;</span>]</span>,errors = <span class="hljs-string">&#x27;coerce&#x27;</span>,downcast=<span class="hljs-string">&#x27;float&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="分类数据-category"><a href="#分类数据-category" class="headerlink" title="分类数据(category)"></a>分类数据(category)</h1><p>Pandas 有一种类别数据, category,用于对分类值进行编码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">转换为category类型<br>tips<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;sex&#x27;</span>]</span> = tips<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;sex&#x27;</span>]</span><span class="hljs-selector-class">.astype</span>(<span class="hljs-string">&#x27;str&#x27;</span>) tips<span class="hljs-selector-class">.info</span>()<br><br><br></code></pre></td></tr></table></figure><p>Pandas 数据类型转换<br>Pandas除了数值型的int 和 float类型外，还有object ，category，bool，datetime类型<br>可以通过as_type 和 to_numeric 函数进行数据类型转换<br>Pandas 分类数据类型<br>category类型，可以用来进行排序，并且可以自定义排序顺序<br>CategoricalDtype可以用来定义顺序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成数组&quot;&gt;&lt;a href=&quot;#生成数组&quot; class=&quot;headerlink&quot; title=&quot;生成数组&quot;&gt;&lt;/a&gt;生成数组&lt;/h1&gt;&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ndarray%E8%BF%90%E7%AE%97/"/>
    <id>http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ndarray%E8%BF%90%E7%AE%97/</id>
    <published>2025-09-11T03:36:23.142Z</published>
    <updated>2023-02-15T22:50:21.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 随机生成10名同学，5门功课的数据</span><br>score = np.random.randint(<span class="hljs-number">40</span>, <span class="hljs-number">100</span>,(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>))<br><br><span class="hljs-built_in">print</span>(score)<br><br><span class="hljs-comment"># 切片 取出最后4名同学的成绩，用逻辑判断</span><br>test_score = score[<span class="hljs-number">6</span>:, <span class="hljs-number">0</span>:<span class="hljs-number">5</span>]<br><br><span class="hljs-comment"># 逻辑判断</span><br><span class="hljs-built_in">print</span>(test_score &gt; <span class="hljs-number">60</span>)<br><br><span class="hljs-comment"># 布尔索引(满足条件替换)</span><br><span class="hljs-built_in">print</span>(test_score[test_score &gt; <span class="hljs-number">60</span>] =<span class="hljs-number">1</span>)<br><br>判断<span class="hljs-keyword">or</span>&amp;<span class="hljs-keyword">and</span><br><br><span class="hljs-comment"># 判断前两名同学的成绩[0:2, :]是否全及格</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>np.<span class="hljs-built_in">all</span>(score[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>, :] &gt; <span class="hljs-number">60</span>)<br><span class="hljs-literal">False</span><br>np.<span class="hljs-built_in">any</span>()<br><span class="hljs-comment"># 判断前两名同学的成绩[0:2, :]是否有大于90分的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>np.<span class="hljs-built_in">any</span>(score[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>, :] &gt; <span class="hljs-number">80</span>)<br><span class="hljs-literal">True</span><br><br><br></code></pre></td></tr></table></figure><h1 id="三目运算"><a href="#三目运算" class="headerlink" title="三目运算"></a>三目运算</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 判断前四名学生,前四门课程中，成绩中大于60的置为1，否则为0</span><br><span class="hljs-attribute">temp</span> = score[:<span class="hljs-number">4</span>, :<span class="hljs-number">4</span>]<br><span class="hljs-attribute">np</span>.where(temp &gt; <span class="hljs-number">60</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 判断前四名学生,前四门课程中，成绩中大于60且小于90的换为1，否则为0</span><br><span class="hljs-attribute">np</span>.where(np.logical_and(temp &gt; <span class="hljs-number">60</span>, temp &lt; <span class="hljs-number">90</span>), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 判断前四名学生,前四门课程中，成绩中大于90或小于60的换为1，否则为0</span><br><span class="hljs-attribute">np</span>.where(np.logical_or(temp &gt; <span class="hljs-number">90</span>, temp &lt; <span class="hljs-number">60</span>), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><p>数组运算时的广播机制：</p><h1 id="数组在进行矢量化运算时，要求数组的形状是相等的。"><a href="#数组在进行矢量化运算时，要求数组的形状是相等的。" class="headerlink" title="数组在进行矢量化运算时，要求数组的形状是相等的。"></a>数组在进行矢量化运算时，要求数组的形状是相等的。</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逻辑运算&quot;&gt;&lt;a href=&quot;#逻辑运算&quot; class=&quot;headerlink&quot; title=&quot;逻辑运算&quot;&gt;&lt;/a&gt;逻辑运算&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Matplotib/"/>
    <id>http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Matplotib/</id>
    <published>2025-09-11T03:36:23.141Z</published>
    <updated>2023-02-15T22:50:21.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中文显示"><a href="#中文显示" class="headerlink" title="中文显示"></a>中文显示</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from pylab import mpl<br>mpl<span class="hljs-selector-class">.rcParams</span><span class="hljs-selector-attr">[<span class="hljs-string">&quot;font.sans-serif&quot;</span>]</span>=<span class="hljs-selector-attr">[<span class="hljs-string">&quot;SimHei&quot;</span>]</span><br>mpl<span class="hljs-selector-class">.rcParams</span><span class="hljs-selector-attr">[<span class="hljs-string">&quot;axes.unicode_minu&quot;</span>]</span>= False<br><br></code></pre></td></tr></table></figure><h1 id="添加网格显示"><a href="#添加网格显示" class="headerlink" title="添加网格显示"></a>添加网格显示</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">plt.grid(<span class="hljs-literal">True</span>, <span class="hljs-attribute">linestyle</span>=<span class="hljs-string">&quot;--&quot;</span>,alpha=0.5)<br></code></pre></td></tr></table></figure><h1 id="添加描述信息"><a href="#添加描述信息" class="headerlink" title="添加描述信息"></a>添加描述信息</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">plt<span class="hljs-selector-class">.xlable</span>(<span class="hljs-string">&quot;时间&quot;</span>)<br>plt<span class="hljs-selector-class">.ylable</span>(<span class="hljs-string">&quot;温度&quot;</span>)<br>plt<span class="hljs-selector-class">.title</span>(<span class="hljs-string">&quot;中午的温度变化图&quot;</span>，fontsize=<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><h1 id="图像保存"><a href="#图像保存" class="headerlink" title="图像保存"></a>图像保存</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">plt<span class="hljs-selector-class">.savefig</span>(<span class="hljs-string">&quot;test.png&quot;</span>)<br></code></pre></td></tr></table></figure><p>画图流程</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> matplotlib.pyplot as plt<br><span class="hljs-attribute">import</span> random<br><span class="hljs-attribute">from</span> pylab import mpl<br><br><span class="hljs-comment"># 设置显示中文字体</span><br><span class="hljs-attribute">from</span> pylab import mpl<br><span class="hljs-attribute">mpl</span>.rcParams[<span class="hljs-string">&quot;font.sans-serif&quot;</span>] =<span class="hljs-meta"> [&quot;SimHei&quot;]</span><br><span class="hljs-comment"># 设置正常显示符号</span><br><span class="hljs-attribute">mpl</span>.rcParams[<span class="hljs-string">&quot;axes.unicode_minus&quot;</span>] = False<br><br><span class="hljs-comment"># 0.准备数据</span><br><span class="hljs-attribute">x</span> = range(<span class="hljs-number">60</span>)<br><span class="hljs-attribute">y_shanghai</span> =<span class="hljs-meta"> [random.uniform(15, 18) for i in x]</span><br><br><span class="hljs-comment"># 1.创建画布</span><br><span class="hljs-attribute">plt</span>.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">8</span>), dpi=<span class="hljs-number">100</span>)<br><br><span class="hljs-comment"># 2.绘制图像</span><br><span class="hljs-attribute">plt</span>.plot(x, y_shanghai)<br><br><span class="hljs-comment"># 2.1 添加x,y轴刻度</span><br><span class="hljs-comment"># 构造x,y轴刻度标签</span><br><span class="hljs-attribute">x_ticks_label</span> =<span class="hljs-meta"> [&quot;11点&#123;&#125;分&quot;.format(i) for i in x]</span><br><span class="hljs-attribute">y_ticks</span> = range(<span class="hljs-number">40</span>)<br><br><span class="hljs-comment"># 刻度显示</span><br><span class="hljs-attribute">plt</span>.xticks(x[::<span class="hljs-number">5</span>], x_ticks_label[::<span class="hljs-number">5</span>])<br><span class="hljs-attribute">plt</span>.yticks(y_ticks[::<span class="hljs-number">5</span>])<br><br><span class="hljs-comment"># 2.2 添加网格显示</span><br><span class="hljs-attribute">plt</span>.grid(True, linestyle=<span class="hljs-string">&quot;--&quot;</span>, alpha=<span class="hljs-number">0</span>.<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 2.3 添加描述信息</span><br><span class="hljs-attribute">plt</span>.xlabel(<span class="hljs-string">&quot;时间&quot;</span>)<br><span class="hljs-attribute">plt</span>.ylabel(<span class="hljs-string">&quot;温度&quot;</span>)<br><span class="hljs-attribute">plt</span>.title(<span class="hljs-string">&quot;中午11点--12点某城市温度变化图&quot;</span>, fontsize=<span class="hljs-number">20</span>)<br><br><span class="hljs-comment"># 2.4 图像保存</span><br><span class="hljs-attribute">plt</span>.savefig(<span class="hljs-string">&quot;./test.png&quot;</span>)<br><br><span class="hljs-comment"># 3.图像显示</span><br><span class="hljs-attribute">plt</span>.show()<br><br></code></pre></td></tr></table></figure><h1 id="一图多线"><a href="#一图多线" class="headerlink" title="一图多线"></a>一图多线</h1><p>多次plot</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 增加北京的温度数据</span><br>y_beijing = [random.uniform(1, 3) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x]<br><br><span class="hljs-comment"># 绘制折线图</span><br>plt.plot(x, y_shanghai)<br><span class="hljs-comment"># 使用多次plot可以画多个折线</span><br>plt.plot(x, y_beijing, <span class="hljs-attribute">color</span>=<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-attribute">linestyle</span>=<span class="hljs-string">&#x27;--&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="各图形及其语法"><a href="#各图形及其语法" class="headerlink" title="各图形及其语法"></a>各图形及其语法</h1><p>折线图</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">api: plt plot(<span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span>)<br></code></pre></td></tr></table></figure><p>散点图</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">api: plt.scatter(<span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span>)<br></code></pre></td></tr></table></figure><p>柱状图</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gams">api：plt.bar(x, width, align=<span class="hljs-string">&#x27;center&#x27;</span>, **kwargs)<br><span class="hljs-keyword">Parameters</span>:    <br>x <span class="hljs-comment">:</span> 需要传递的数据<br><br>width <span class="hljs-comment">:</span> 柱状图的宽度<br><br>align <span class="hljs-comment">:</span> 每个柱状图的位置对齐方式<br>    &#123;‘center’, ‘edge’&#125;, optional, default: ‘center’<br><br><span class="hljs-comment">**kwargs :</span><br>color:选择柱状图的颜色dadatwer<br></code></pre></td></tr></table></figure><p>直方图</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">api</span><span class="hljs-punctuation">:</span> <span class="hljs-string">matplotilb.pyplot.hist(x,bins=None)</span><br><span class="hljs-attribute">Parameters</span><span class="hljs-punctuation">:    </span><br><span class="hljs-attribute">x</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">需要传递的数据</span><br><span class="hljs-attribute">bins</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">组距</span><br></code></pre></td></tr></table></figure><p>饼图</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">api:</span> plt.pie(<span class="hljs-built_in">x</span>,labels=,atuopct=,colors)<br><span class="hljs-symbol">Parameters:</span>  <br><span class="hljs-symbol">x:</span>数量，自动算百分比<br><span class="hljs-symbol">labels:</span>每部分名称<br><span class="hljs-symbol">autopct:</span>占比显示指定%<span class="hljs-number">1.2</span>f%%<br><span class="hljs-symbol">colors:</span>每部分颜色<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中文显示&quot;&gt;&lt;a href=&quot;#中文显示&quot; class=&quot;headerlink&quot; title=&quot;中文显示&quot;&gt;&lt;/a&gt;中文显示&lt;/h1&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/kaikeba/"/>
    <id>http://mornikar.github.io/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/kaikeba/</id>
    <published>2025-09-11T03:36:23.140Z</published>
    <updated>2023-02-15T22:50:21.499Z</updated>
    
    <content type="html"><![CDATA[<p>mean(平均值)<br>热数据</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sns.heatmap(dataframe.corr(), <span class="hljs-attribute">annot</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">fmt</span>=<span class="hljs-string">&#x27;.1f&#x27;</span>)<br></code></pre></td></tr></table></figure><p>(例子用于理解)<br>对比两个最小值的均值<br>（第一个age 提取出年龄）（[:2]（把排好序的的两个拿出））</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">np</span>.<span class="hljs-built_in">mean</span>([age <span class="hljs-keyword">for</span> name ,age <span class="hljs-keyword">in</span> sorted(person_and_age.items(), <span class="hljs-built_in">key</span> = <span class="hljs-built_in">lambda</span> e: e[<span class="hljs-number">1</span>])[:<span class="hljs-number">2</span>]])<br></code></pre></td></tr></table></figure><p>对比两个最小值的均值<br>【:topn】(最前的两个数值)<br>history_price(数据)<br>e[0](取 面积：价格 的面积)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_price_by_similar</span>(<span class="hljs-params">history_price,query_x, topn=<span class="hljs-number">3</span></span>):<br>most_similar_items = sorted(history_price.items(), key= <span class="hljs-built_in">lambda</span> <span class="hljs-symbol">e:</span> (e[<span class="hljs-number">0</span>] - query_x)**<span class="hljs-number">2</span>)[<span class="hljs-symbol">:topn</span>]<br><br>most_similar_prices = [price <span class="hljs-keyword">for</span> rm, price <span class="hljs-keyword">in</span> most_similar_items]<br>average_prices = np.mean(most_similar_prices)<br><span class="hljs-keyword">return</span> average_prices<br></code></pre></td></tr></table></figure><p>回归预测结果产生的是一个数值，分类产生一个类别<br>KNN&#x3D;&#x3D;&gt;K-Neighbor-Nearest</p><p>拟合效果 是获取最优的k，b的问题</p><p>损失函数：<br>Loss<br>越接近0，越准确</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">𝑓(𝑟𝑚)=𝑘∗𝑟𝑚+𝑏<br><span class="hljs-built_in">Random</span> Approach<br>𝐿𝑜𝑠𝑠(𝑘,𝑏)=<span class="hljs-number">1</span>𝑛∑𝑖∈𝑁(𝑦𝑖^−𝑦𝑖)<span class="hljs-number">2</span><br> <br>𝐿𝑜𝑠𝑠(𝑘,𝑏)=<span class="hljs-number">1</span>𝑛∑𝑖∈𝑁((𝑘∗𝑟𝑚𝑖+𝑏)−𝑦𝑖)<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>怎么获取最优的k&amp;b？<br>1.直接用微积分的方法做计算（最小二乘法）（简单才用，基本不用）<br>2.用随机模拟的方法来做（随机生成一堆数）也叫：蒙特卡洛模拟</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def loss(y_hat, y):<br>    <span class="hljs-built_in">return</span> <span class="hljs-built_in">np</span>.<span class="hljs-built_in">mean</span>((y_hat - y) ** <span class="hljs-number">2</span>)<br>import <span class="hljs-built_in">random</span><br><br><br>min_loss = <span class="hljs-built_in">float</span>(&#x27;<span class="hljs-literal">inf</span>&#x27;)<br>best_k, bes_b = None, None<br><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">step</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>    min_v, max_v = -<span class="hljs-number">100</span>, <span class="hljs-number">100</span><br>    k, b = <span class="hljs-built_in">random</span>.randrange(min_v, max_v), <span class="hljs-built_in">random</span>.randrange(min_v, max_v)<br>    y_hats = [k * rm_i  + b <span class="hljs-keyword">for</span> rm_i <span class="hljs-keyword">in</span> x]<br>    current_loss = loss(y_hats, y)<br>    <br>    <span class="hljs-keyword">if</span> current_loss &lt; min_loss:<br>        min_loss = current_loss<br>        best_k, best_b = k, b<br>        <span class="hljs-built_in">print</span>(&#x27;在第&#123;&#125;步，我们获得了函数 f(rm) = &#123;&#125; * rm + &#123;&#125;, 此时loss是: &#123;&#125;&#x27;.format(<span class="hljs-keyword">step</span>, k, b, current_loss))<br><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">蒙特卡洛模拟<br>Supervisor<br>𝐿𝑜𝑠𝑠(𝑘,𝑏)=<span class="hljs-number">1</span>/𝑛*∑𝑖∈𝑁((𝑘∗𝑟𝑚𝑖+𝑏)−𝑦𝑖)<span class="hljs-number">2</span><br>∂𝑙𝑜𝑠𝑠(𝑘,𝑏)<span class="hljs-regexp">/∂𝑘=2/</span>𝑛*∑𝑖∈𝑁(𝑘∗𝑟𝑚𝑖+𝑏−𝑦𝑖)∗𝑟𝑚𝑖<br>∂𝑙𝑜𝑠𝑠(𝑘,𝑏)<span class="hljs-regexp">/∂𝑏=2/</span>𝑛*∑𝑖∈𝑁(𝑘∗𝑟𝑚𝑖+𝑏−𝑦𝑖)<br></code></pre></td></tr></table></figure><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs gml">def partial_k(k, b, <span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * np.<span class="hljs-built_in">mean</span>((k * <span class="hljs-variable language_">x</span> + b - <span class="hljs-variable language_">y</span>) * <span class="hljs-variable language_">x</span>)<br><br>def partial_b(k, b, <span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * np.<span class="hljs-built_in">mean</span>(k * <span class="hljs-variable language_">x</span> + b - <span class="hljs-variable language_">y</span>)<br><br>k_history, b_history = [], []<br>loss_history = []<br>k, b = <span class="hljs-built_in">random</span>.<span class="hljs-built_in">random</span>(), <span class="hljs-built_in">random</span>.<span class="hljs-built_in">random</span>()<br>min_loss = float(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>best_k, bes_b = None, None<br>learning_rate = <span class="hljs-number">1e-2</span><br><br><span class="hljs-keyword">for</span> step in range(<span class="hljs-number">2000</span>):<br>    k, b = k + (<span class="hljs-number">-1</span> * partial_k(k, b, <span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>) * learning_rate), b + (<span class="hljs-number">-1</span> * partial_b(k, b, <span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>) * learning_rate)<br>    y_hats = k * <span class="hljs-variable language_">x</span> + b<br>    current_loss = loss(y_hats, <span class="hljs-variable language_">y</span>)<br>    <br>    <span class="hljs-keyword">if</span> current_loss &lt; min_loss:<br>        min_loss = current_loss<br>        best_k, best_b = k, b<br>        k_history.append(best_k)<br>        b_history.append(best_b)<br>        loss_history.append(current_loss)<br>        print(<span class="hljs-string">&#x27;在第&#123;&#125;步，我们获得了函数 f(rm) = &#123;&#125; * rm + &#123;&#125;, 此时loss是: &#123;&#125;&#x27;</span>.format(step, k, b, current_loss))<br></code></pre></td></tr></table></figure><h1 id="深度学习的核心-：-通过梯度下降的方法，获得一组参数，是的loss最小"><a href="#深度学习的核心-：-通过梯度下降的方法，获得一组参数，是的loss最小" class="headerlink" title="深度学习的核心 ： 通过梯度下降的方法，获得一组参数，是的loss最小"></a>深度学习的核心 ： 通过梯度下降的方法，获得一组参数，是的loss最小</h1><p>loss偏导式 + 梯度下降<br class='item-img' data-src='0'><img src="0" alt="Snipaste_20210105_155120.png"></p><p>将课堂代码中的L2-Loss 变成L1Loss 并且实现梯度下降</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">𝐿2−𝐿𝑜𝑠𝑠(𝑦,𝑦̂ )=1/𝑛<span class="hljs-symbol">*</span>∑(𝑦̂ −𝑦)2<br> <br>𝐿1−𝐿𝑜𝑠𝑠(𝑦,𝑦̂ )=1/𝑛<span class="hljs-symbol">*</span>∑|<span class="hljs-string">(𝑦̂ −𝑦)</span>|<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;mean(平均值)&lt;br&gt;热数据&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/%E6%B5%8B%E8%AF%95/day1/"/>
    <id>http://mornikar.github.io/2025/09/11/%E6%B5%8B%E8%AF%95/day1/</id>
    <published>2025-09-11T03:36:23.138Z</published>
    <updated>2023-02-15T22:50:21.500Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/Ubuntu/vim%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%A6/"/>
    <id>http://mornikar.github.io/2025/09/11/Ubuntu/vim%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%A6/</id>
    <published>2025-09-11T03:36:23.135Z</published>
    <updated>2023-02-15T22:50:21.492Z</updated>
    
    <content type="html"><![CDATA[<p>取消vim末行模式下的数字</p><p>全选（高亮显示）：按esc后，然后ggvG或者ggVG</p><p>全部复制：按esc后，然后ggyG</p><p>全部删除：按esc后，然后dG</p><p>vim命令行模式下输入  ：set nu　　取消显示：在vim命令行模式下输入：  set nonu<br>插入内容：</p><p>　　　　i: 插入光标前一个字符</p><p>　　　　I: 插入行首</p><p>　　　　a: 插入光标后一个字符</p><p>　　　　A: 插入行未</p><p>　　　　o: 向下新开一行,插入行首</p><p>　　　　O: 向上新开一行,插入行首</p><p>　　移动光标:</p><p>　　　　 h: 左移</p><p>　　　　j: 下移 </p><p>　　　　k: 上移 </p><p>　　　　l: 右移</p><p>　　　　M: 光标移动到屏幕中间行 </p><p>　　　　L: 光标移动到屏幕最后一行行首 </p><p>　　　　G: 移动到指定行,行号 -G</p><p>　　　　w: 向后一次移动一个字 </p><p>　　　　b: 向前一次移动一个字</p><p>　　　　{: 按段移动,上移 </p><p>　　　　}: 按段移动,下移</p><p>　　　　Ctrl+d: 向下翻半屏 </p><p>　　　　Ctrl+u: 向上翻半屏</p><p>　　　　Ctrl+f: 向下翻一屏 </p><p>　　　　Ctrl+b: 向上翻一屏</p><p>　　　　gg: 光标移动文件开头 </p><p>　　　　G: 光标移动到文件末尾</p><p>　      删除命令:</p><p>　　　　x: 删除光标后一个字符,相当于 Del </p><p>　　　　X: 删除光标前一个字符,相当于 Backspace</p><p>　　　　dd: 删除光标所在行,n dd 删除指定的行数 </p><p>　　　　D: 删除光标后本行所有内容,包含光标所在字符 </p><p>　　　　d0: 删除光标前本行所有内容,不包含光标所在字符</p><p>　　　　dw: 删除光标开始位置的字,包含光标所在字符</p><p>　　撤销命令:</p><p>　　　　u: 一步一步撤销</p><p>　　　 Ctrl+r: 反撤销</p><p>　　重复命令:</p><p>　　　　.: 重复上一次操作的命令</p><p>　　文本行移动:</p><p>　　       &gt;&gt;: 文本行右移 </p><p>　　　   &lt;&lt;: 文本行左移　　  </p><pre><code> 复制粘贴:</code></pre><p>　　　　yy: 复制当前行,n yy 复制 n 行</p><p>　　　　p: 在光标所在位置向下新开辟一行,粘贴</p><p>　　可视模式:</p><p>　　　　v: 按字符移动,选中文本 </p><p>　　　V: 按行移动,选中文本可视模式可以配合 d, y, &gt;&gt;, &lt;&lt; 实现对文本块的删除,复制,左右移动</p><p>　　替换操作:</p><p>　　　　r: 替换当前字符 </p><p>　　　　R: 替换当前行光标后的字符</p><p>　　查找命令:</p><p>　　　　&#x2F;: str查找<br>　　　　n: 下一个<br>　　　　N：上一个</p><p>替换命令(并不常用)：</p><p>　　　　把abc全部替换成123:     末行模式下，将当前文件中的所有abc替换成123　　:%s&#x2F;abc&#x2F;123&#x2F;g</p><p>　　　　末行模式下，将第一行至第10行之间的abc替换成123    :1, 10s&#x2F;abc&#x2F;123&#x2F;g</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;取消vim末行模式下的数字&lt;/p&gt;
&lt;p&gt;全选（高亮显示）：按esc后，然后ggvG或者ggVG&lt;/p&gt;
&lt;p&gt;全部复制：按esc后，然后ggyG&lt;/p&gt;
&lt;p&gt;全部删除：按esc后，然后dG&lt;/p&gt;
&lt;p&gt;vim命令行模式下输入  ：set nu　　取消显示：在vim命令</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/python%E5%A4%8D%E4%B9%A0/%E4%BC%98%E5%8C%96/"/>
    <id>http://mornikar.github.io/2025/09/11/python%E5%A4%8D%E4%B9%A0/%E4%BC%98%E5%8C%96/</id>
    <published>2025-09-11T03:36:23.133Z</published>
    <updated>2023-02-15T22:50:21.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-6-关于-Python-程序的运行方面，有什么手段能提升性能？-2018-3-30-lxy"><a href="#6-6-关于-Python-程序的运行方面，有什么手段能提升性能？-2018-3-30-lxy" class="headerlink" title="6.6 关于 Python 程序的运行方面，有什么手段能提升性能？(2018-3-30-lxy)"></a>6.6 关于 Python 程序的运行方面，有什么手段能提升性能？(2018-3-30-lxy)</h1><p>1、使用多进程，充分利用机器的多核性能<br>2、对于性能影响较大的部分代码，可以使用 C 或 C++编写<br>3、对于 IO 阻塞造成的性能影响，可以使用 IO 多路复用来解决<br>4、尽量使用 Python 的内建函数<br>5、尽量使用局部变量</p><h1 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1.1</span> 现有字典 d=&#123;‘a’:<span class="hljs-number">24</span>，‘g’:<span class="hljs-number">52</span>，‘i’:<span class="hljs-number">12</span>，‘k’:<span class="hljs-number">33</span>&#125;请按字典中的 value<br>值进行排序？ (<span class="hljs-number">2018</span>-<span class="hljs-number">3</span>-<span class="hljs-number">30</span>-lxy)<br><span class="hljs-function"><span class="hljs-title">sorted</span><span class="hljs-params">(d.items()</span></span>，key = lambda <span class="hljs-attribute">x</span>:x[<span class="hljs-number">1</span>]) 。<br></code></pre></td></tr></table></figure><h1 id="高级切片方法"><a href="#高级切片方法" class="headerlink" title="高级切片方法"></a>高级切片方法</h1><h1 id="字典排序-1"><a href="#字典排序-1" class="headerlink" title="字典排序"></a>字典排序</h1><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">str1 = <span class="hljs-string">&quot;k:1|k1:2|k2:3|k3:4&quot;</span><br>def str2dict(str1):<br>dict1 = &#123;&#125;<br><span class="hljs-keyword">for</span> iterms <span class="hljs-keyword">in</span> str1.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;|&#x27;</span>):<br>key，value = iterms.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;:&#x27;</span>)<br>dict1[key] = value<br><span class="hljs-keyword">return</span> dict1<br></code></pre></td></tr></table></figure><h1 id="alist排序"><a href="#alist排序" class="headerlink" title="alist排序"></a>alist排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">alist [&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;a&#x27;</span>，<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">20</span>&#125;，&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;b&#x27;</span>，<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">30</span>&#125;，&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;c&#x27;</span>，<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">25</span>&#125;]<br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">sort_by_age</span>(<span class="hljs-params">list1</span>):<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(alist，key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-string">&#x27;age&#x27;</span>]，reverse=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-6-关于-Python-程序的运行方面，有什么手段能提升性能？-2018-3-30-lxy&quot;&gt;&lt;a href=&quot;#6-6-关于-Python-程序的运行方面，有什么手段能提升性能？-2018-3-30-lxy&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/python%E5%A4%8D%E4%B9%A0/python%20%E5%A4%8D%E4%B9%A0day01/"/>
    <id>http://mornikar.github.io/2025/09/11/python%E5%A4%8D%E4%B9%A0/python%20%E5%A4%8D%E4%B9%A0day01/</id>
    <published>2025-09-11T03:36:23.132Z</published>
    <updated>2023-02-15T22:50:21.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-python-魔法方法"><a href="#1-python-魔法方法" class="headerlink" title="1.python 魔法方法"></a>1.python 魔法方法</h1><h2 id="1-对象构造方法"><a href="#1-对象构造方法" class="headerlink" title="1.对象构造方法"></a>1.对象构造方法</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-python-魔法方法&quot;&gt;&lt;a href=&quot;#1-python-魔法方法&quot; class=&quot;headerlink&quot; title=&quot;1.python 魔法方法&quot;&gt;&lt;/a&gt;1.python 魔法方法&lt;/h1&gt;&lt;h2 id=&quot;1-对象构造方法&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/mysql%E6%97%B6%E9%97%B4%E6%9F%A5%E8%AF%A2/mysql/%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB/"/>
    <id>http://mornikar.github.io/2025/09/11/mysql%E6%97%B6%E9%97%B4%E6%9F%A5%E8%AF%A2/mysql/%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB/</id>
    <published>2025-09-11T03:36:23.127Z</published>
    <updated>2023-02-15T22:50:21.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DQL-数据查询语言（凡是带有select-关键字的都是查询语句）"><a href="#DQL-数据查询语言（凡是带有select-关键字的都是查询语句）" class="headerlink" title="DQL:数据查询语言（凡是带有select 关键字的都是查询语句）"></a>DQL:数据查询语言（凡是带有select 关键字的都是查询语句）</h1><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">select</span></span>....<br><br></code></pre></td></tr></table></figure><h1 id="DML：数据操作语言（凡是对表当中的数据进行增删改都是DML）"><a href="#DML：数据操作语言（凡是对表当中的数据进行增删改都是DML）" class="headerlink" title="DML：数据操作语言（凡是对表当中的数据进行增删改都是DML）"></a>DML：数据操作语言（凡是对表当中的数据进行增删改都是DML）</h1><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">update</span><br><span class="hljs-keyword">insert</span> 增<br><span class="hljs-keyword">delete</span> 删<br><span class="hljs-keyword">update</span> 改<br></code></pre></td></tr></table></figure><h1 id="DDL-数据定义语言（修改表结构）（凡是带有create、drop、alter的都是DDL，DDL主要操作的时表结构。不是表中的数据）"><a href="#DDL-数据定义语言（修改表结构）（凡是带有create、drop、alter的都是DDL，DDL主要操作的时表结构。不是表中的数据）" class="headerlink" title="DDL:数据定义语言（修改表结构）（凡是带有create、drop、alter的都是DDL，DDL主要操作的时表结构。不是表中的数据）"></a>DDL:数据定义语言（修改表结构）（凡是带有create、drop、alter的都是DDL，DDL主要操作的时表结构。不是表中的数据）</h1><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> ： 新建，等同增<br><span class="hljs-keyword">drop</span>：删除<br><span class="hljs-keyword">alter</span>：修改<br><br></code></pre></td></tr></table></figure><h1 id="TCL-事务控制语言（主要控制事务）"><a href="#TCL-事务控制语言（主要控制事务）" class="headerlink" title="TCL 事务控制语言（主要控制事务）"></a>TCL 事务控制语言（主要控制事务）</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">事务提交：<span class="hljs-keyword">commit</span>；<br>事务回滚：<span class="hljs-keyword">rollback</span>；<br></code></pre></td></tr></table></figure><h1 id="DCL：-是数据控制语言。"><a href="#DCL：-是数据控制语言。" class="headerlink" title="DCL： 是数据控制语言。"></a>DCL： 是数据控制语言。</h1><p>（）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">授权：<span class="hljs-keyword">grant</span><br>撤销授权<span class="hljs-keyword">revoke</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DQL-数据查询语言（凡是带有select-关键字的都是查询语句）&quot;&gt;&lt;a href=&quot;#DQL-数据查询语言（凡是带有select-关键字的都是查询语句）&quot; class=&quot;headerlink&quot; title=&quot;DQL:数据查询语言（凡是带有select 关键字的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mornikar.github.io/2025/09/11/mysql%E6%97%B6%E9%97%B4%E6%9F%A5%E8%AF%A2/mysq/newnote_1616765059970/"/>
    <id>http://mornikar.github.io/2025/09/11/mysql%E6%97%B6%E9%97%B4%E6%9F%A5%E8%AF%A2/mysq/newnote_1616765059970/</id>
    <published>2025-09-11T03:36:23.123Z</published>
    <updated>2023-02-15T22:50:21.495Z</updated>
    
    <content type="html"><![CDATA[<ol><li></li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">distinct</span>可以去除重复数据行<br></code></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">like</span>是模糊查询关键字<br>%表示任意多个任意字符<br>_表示一个任意字符<br><br>例<span class="hljs-number">1</span>：查询姓黄的学生:<br><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;黄%&#x27;</span>;<br>例<span class="hljs-number">2</span>：查询姓黄并且“名”是一个字的学生:<br><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;黄_&#x27;</span>;<br>例<span class="hljs-number">3</span>：查询姓黄或叫靖的学生:<br><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;黄%&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%靖&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">between</span> .. <span class="hljs-keyword">and</span> .. 表示在一个连续的范围内查询<br><span class="hljs-keyword">in</span> 表示在一个非连续的范围内查询<br>例<span class="hljs-number">1</span>：查询编号为<span class="hljs-number">3</span>至<span class="hljs-number">8</span>的学生:<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> id <span class="hljs-keyword">between</span> <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">8</span>;<br>例<span class="hljs-number">2</span>：查询编号不是<span class="hljs-number">3</span>至<span class="hljs-number">8</span>的男生:<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> (<span class="hljs-keyword">not</span> id <span class="hljs-keyword">between</span> <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">8</span>) <span class="hljs-keyword">and</span> gender<span class="hljs-operator">=</span><span class="hljs-string">&#x27;男&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight arcade&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class</summary>
      
    
    
    
    
  </entry>
  
</feed>
