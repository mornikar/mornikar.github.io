[{"title":"AI模型指标、训练优化方向","url":"/2013/07/13/AIGC%E7%AC%94%E8%AE%B0%E9%9A%8F%E7%AC%94/AIGC%E6%8C%87%E6%A0%87%E6%A2%B3%E7%90%86/","content":"AI模型优化训练方向指标：\n1.提高模型规模：\n模型规模通常直接影响模型的理解和生成能力，规模越大，处理复杂任务的能力通常越强。\n2.训练数据\nAI可以通过训练数据提高以下能力指标：\n    1.特定领域性能评估：这指的是模型在其训练数据所针对的特定任务或领域中的表现。通过评估指标衡量，如准确率、召回率、F1分数等\n    2.泛化能力：这是衡量模型能否将所学知识推广到新的、未见过的任务或领域的能力。\n如何提高模型的特定领域性能和泛化能力：\n    数据多样性：在训练模型时，使用来自不同子领域和不同类型的数据，以提高模型对领域变化的适应性。\n    数据增强：通过对训练数据进行变换，如同义词替换、句子重组等，来增加数据的多样性，从而提高模型的泛化能力。\n    领域适应：使用领域适应技术，如自适应训练、领域特化的网络架构等，使模型能够识别并适应新领域的特点。\n    少样本学习：通过训练模型以处理只有少量样本的新任务，提高模型在新领域上的泛化能力。\n    持续学习：允许模型在不断接收新数据的同时进行更新，以保持其知识库的最新状态。\n    评估和反馈：通过在不同的评估任务上测试模型的性能，并根据反馈调整模型，以提高其在特定领域和跨领域的性能。\n总之，模型的特定领域性能和泛化能力是衡量模型有效性和适用性的关键指标，需要通过精心设计的训练策略和评估流程来共同提高。\n","categories":["AIGC"],"tags":["AI模型指标、训练优化方向"]},{"title":"ChatGPT各版本差异调研","url":"/2013/07/13/AIGC%E7%AC%94%E8%AE%B0%E9%9A%8F%E7%AC%94/ChatGPT%E5%90%84%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82%E8%B0%83%E7%A0%94/","content":"ChatGPT 的各个版本主要是指不同时间点发布的模型，其性能差异通常体现在模型的规模、训练数据、优化算法和特定任务的适应性等方面。以下是一些可能的具体差异：\n\n模型规模：ChatGPT 最初的版本是基于 GPT-3.5 模型，随后可能会有更大规模或更小规模的版本发布，如 GPT-3.5 XL 或 GPT-3.5 XXL。模型规模通常直接影响模型的理解和生成能力，规模越大，处理复杂任务的能力通常越强。\n\n训练数据：随着时间的推移，模型可能会使用更多或更高质量的训练数据进行训练，这有助于提高模型在特定领域的性能和泛化能力。\n\n优化算法：模型可能会采用不同的优化算法或调整超参数来提高性能，例如改进的梯度下降方法、更高效的训练策略等。\n\n特定任务的适应性：随着时间的推移，模型可能会针对特定的任务进行微调（fine-tuning），以更好地适应这些任务的需求，例如通过指令微调（Instruction Tuning）或基于人类反馈的强化学习（RLHF）等技术。\n\n性能指标：不同版本的模型在不同的评估任务上的表现可能会有所不同，例如文本生成、对话质量、语言理解等。性能指标的提升可能表现为生成文本的自然性、准确性和多样性等方面的改进。\n\n\n需要注意的是，OpenAI 并没有公开详细披露每个版本模型的具体性能差异，因此上述信息是基于一般性的模型迭代和改进的理解。如果需要了解最新的模型性能差异，建议直接查阅 OpenAI 的官方发布或相关研究论文。\n","categories":["AIGC版本调研"],"tags":["AIGC版本调研"]},{"title":"多模态","url":"/2013/07/13/AIGC%E7%AC%94%E8%AE%B0%E9%9A%8F%E7%AC%94/%E5%A4%9A%E6%A8%A1%E6%80%81/","content":"LLM领域的AI应用\n1、基座模型与上层应用，分层清晰、各有空间\n2、应用层几乎不涉及模型和算法\n3、逻辑性抢、更容易量化\n多模态领域的AI应用\n1、模型即是应用\n2、多模型模块的组合\n3、多模块底层逻辑的理解\n\n多模态领域的重要技术突破：\n语言与视觉打通的Clip（contrastive Language-Image pre-training ）openAI于2021-1月发布\n向量、空间、特征\n1、Contrastive pre-training\n大量训练数据、弱监督训练\nOpenAI对其设计了简单模型结构：相似度运算\n\n\n各种多模态的模块组合与学习:\n如：Text2Image（文生图-文字生成图片Text to Image）\n2022.4 DALLE2组合了\n1、Clip Text Encoder\n2、Diffusion Model 中的逆向扩散过程\n两个模型中间用一个Transformer Decoder 串联起来\n2022.8 Stablel Diffusion 发现了\n1、Runway首席科学家Patrick Esser 发表了一遍有关Latent Diffusion Model的论文\n2、用代码把论文里的模型实现了一遍\n\n如：Text2Video（文生视频-文字生成视频Text to Video）\n2023.3月 发布的Gen2 里面组合了\n1、Clip Text Encoder\n2、Diffusion Model中的逆向扩散过程\n（逆向扩散过程：如清晰的一张图逐渐加噪点变模糊化，这叫扩散，逆向扩散就是一张模糊的旧图逆向训练成清晰的图）\n3、Latent Diffusion Model中的潜在空间\n20024.2 发布的Sora组合了\n1、DALLLE3的Caption improvement\n2、Meta ICCV2023的DIT（Duffusion Transformer）替换U-Net\n3、Google ICCV2021 的ViViT（A Video Vision Transformer）\n\n建议：\n1、不要一上来就做一个单独的AI产品\n2、从一个优化带你开始\n3、2C产品建议从留存、活跃、互动率考虑\n4、2B从大规模效率出发\n5、内部系统从用户操作复杂度\n学习模型原理、学习模型边界、学习多模态的各种模块\n","categories":["AIGC版本调研"],"tags":["AIGC多模态"]},{"title":"大模型解构","url":"/2013/07/13/AIGC%E7%AC%94%E8%AE%B0%E9%9A%8F%E7%AC%94/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%84/","content":"AI工作流：\nAIGC赋能电商公司：\n极睿科技：极睿科技\nAIGC赋能教育：\nAIGC赋能广告：HeyGen\n30人3个亿\nAIGC赋能办公场景：AIPPT\nAiPPT - 全智能 AI 一键生成 PPT\n月收几百万人命比\nAIGC赋能泛娱乐行业：星野\nmeitu美图\n※AIGC赋能金融：支小助\n南方航空、电网、烟草、咪咕、航空\n数据分析：\n外部调研、内部数据分析\n经营分析与商业经营\n重要视角：国内外大厂、小厂、创业等加大AI投入\n2.移动互联网没机会、只有卷AI功能\n3、2B需求爆发增长、比2C还快\n4、各部门沟通壁垒无法打通\n注意重点：\n1、AI现在速度在2010\n2.小米、美团、滴滴、头条等都是2010-2012阶段成立，造就大佬也造就变现员工\n3、现阶段企业投入AI的ROI最高，蜂拥而至的AI需求其实非常合理\n结合业务场景做落地：\n金融行业：严谨性、复杂性、实时性、准确性\nPrompt、Agent、Function Call、RAG\n什么事Prompt：\n提示词工程\nFunction Call：\n理解语义、自主决策、机构化调用工具、询问用户、补全信息、基于返回的结构化信息，整合生成回复、\nFunction Call的成功率非常依赖基座LLM\nFunction Call可以让LLM变成智能中枢\nLLM Based Agent\n从无状态到特定状态的定义和识别\n无状态、连续：\nprompt：帮我点外卖，两杯可乐和，面包。送公司\n有状态、离散：\n{\nAPP：美团\nirders：可乐、面包\nNumbers：1548324254\n….\n}\n用好Agent的关键，思考哪些东西值得被离散化、状态化\n不断测试大模型的能力，并研究如何提高状态判断的准确度。\n如何测试大模型。\n测试大模型的离散化的准确率如何\n多Agent协作\n如何提升性能：\n提升状态判断准确率、Function Call准确度、RAG准确度、Agent可控性\n最初：只会Prompt\n初级：Agent：反思+纠错\n中级：多Agent协作、RAG\n高级：Fine tune、Embedding定制\n顶级：训练垂直行业LLM\n以前产品经理要PMF：符合市场需求\nAIGC产品经理要TPF：技术产品的契合\n","categories":["AIGC版本调研"],"tags":["AIGC版本调研"]},{"title":"AIGC就业调研","url":"/2013/07/13/AIGC%E7%AC%94%E8%AE%B0%E9%9A%8F%E7%AC%94/%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%EF%BC%86%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","content":"结合当前就业市场趋势和空窗期特点，以下是针对您转向AI产品经理岗位的分析及建议：\n\n​​一、2025年6月AI产品经理就业现状​​\n​​市场需求旺盛​​\n\nAI技术加速渗透金融、医疗、教育、制造等行业，企业对AI产品经理的需求持续增长，尤其是具备​​跨领域知识​​（技术+业务）的复合型人才。\n岗位薪资水平显著高于传统产品经理，一线城市资深岗位年薪可达60K-16薪，部分岗位甚至更高。\n\n\n​​竞争激烈但机会明确​​\n\n虽然求职者增多，但​​技术门槛​​（如AI基础知识、数据分析能力）和​​行业经验​​（如医疗、金融等垂直领域）筛选严格，供给仍小于需求。\n传统互联网产品经理转型AI存在优势，但需补充AI技术理解（如机器学习、NLP）和工具应用（如Python、数据分析平台）。\n\n\n\n\n​​二、两年空窗期的潜在影响与应对策略​​\n​​风险点​​\n\n​​技术脱节​​：AI技术迭代快（如大模型、生成式AI），需快速补齐基础知识和工具链。\n​​经验断层​​：企业可能担忧空窗期导致行业敏感度下降，需通过项目实践或行业研究证明持续学习能力。\n\n\n​​破局建议​​\n\n​​技能补充​​：\n学习AI基础（如机器学习原理、Prompt Engineering）及行业案例（如智能客服、推荐系统）。\n掌握AI产品工具（如Figma+AI插件、数据分析工具Tableau&#x2F;Power BI）。\n\n\n​​经验重塑​​：\n参与AI相关兼职&#x2F;自由项目（如为初创公司提供AI产品方案），或复盘过往项目中的“类AI”经验（如数据分析、自动化流程设计）。\n输出行业洞察（如撰写AI+垂直领域的分析文章），展示业务理解能力。\n\n\n\n\n\n\n​​三、2025年6月入行AI产品经理的可行性​​\n​​时机优势​​\n\n​​政策红利​​：国家“十四五”规划持续推动AI产业化，企业预算向AI应用倾斜，岗位需求保持高位。\n​​技术成熟​​：大模型开源降低AI产品开发门槛，企业更关注​​产品化能力​​（如场景落地、用户体验），而非纯技术背景。\n\n\n​​关键行动​​\n\n​​针对性学习​​：\n优先掌握“AI产品方法论”（如需求定义、数据标注规范、模型评估标准），而非盲目学习算法。\n考取认证（如NPDP、AI产品经理专项证书）提升简历竞争力。\n\n\n​​求职策略​​：\n优先投递​​AI中台​​或​​垂直领域​​（如医疗AI、教育AI）岗位，利用行业经验降低转型难度。\n面试中强调空窗期的“主动性”（如学习成果、项目沉淀），弱化时间空白。\n\n\n\n\n\n\n​​四、长期职业发展建议​​\n​​技术+业务双驱动​​：持续跟踪AI技术趋势（如多模态、Agent），同时深耕1-2个垂直行业（如金融风控、智能制造），成为“懂技术的业务专家”。\n​​职业路径延伸​​：从需求分析向​​AI产品架构设计​​或​​行业解决方案​​转型，提升不可替代性。\n\n\n​​总结​​当前是AI产品经理入行的有利窗口期，但需快速补齐技术短板并重构经验体系。建议以​​“场景化AI产品能力”​​为核心，结合空窗期的主动学习成果，针对性切入医疗、教育等传统行业AI化需求，逐步建立竞争优势。\n以下是针对AI产品经理的系统化学习路径，结合当前行业需求和空窗期特点设计，分为​​4大阶段​​，覆盖技术基础、产品思维、实战技能及资源推荐，并附关键学习链接：\n\n​​一、基础能力搭建（1-2个月）​​​​目标​​：建立AI技术认知框架，掌握基础工具和编程能力。\n\n​​AI基础概念​​\n\n学习AI&#x2F;ML&#x2F;NLP&#x2F;计算机视觉的基本原理，理解大模型（如GPT、BERT）的工作机制。\n​​推荐资源​​：\nB站视频：大模型技术点科普\n书籍：《》（Stuart Russell）\n\n\n\n\n​​Python编程与数据分析​​\n\n掌握Python语法、Pandas&#x2F;Numpy数据处理、Matplotlib可视化。\n​​推荐资源​​：\n免费课程：菜鸟教程Python入门\n实战案例：Kaggle入门竞赛（如泰坦尼克生存预测）\n\n\n\n\n​​机器学习基础​​\n\n学习监督学习（分类、回归）、无监督学习（聚类）和模型评估指标（准确率、F1值）。\n​​推荐资源​​：\n吴恩达《》课程（Coursera）\n实践平台：Google Colab（免费GPU环境）\n\n\n\n\n\n\n​​二、AI技术深化（2-3个月）​​​​目标​​：理解AI产品开发的核心技术栈，掌握大模型应用与开发。\n\n​​大模型技术栈​​\n\n学习Prompt Engineering、LangChain框架、微调（Fine-tuning）和私有化部署。\n​​推荐资源​​：\n实战案例：LangChain官方网页\n视频教程：大模型微调开发\n\n\n\n\n​​垂直领域应用​​\n\n研究NLP（智能客服、文本生成）、CV（图像识别）、推荐系统的技术实现与产品设计。\n​​推荐资源​​：\n行业报告：640份AI大模型报告合集\n工具实践：OpenAI API、Hugging Face模型库\n\n\n\n\n​​AI产品工具链​​\n\n掌握Figma（原型设计）、Jira（项目管理）、Mixpanel（数据分析）。\n​​推荐资源​​：\n教程：Figma+AI插件实战指南\n\n\n\n\n\n\n​​三、产品能力进阶（2-3个月）​​​​目标​​：培养AI产品全流程管理能力，学习商业化落地方法。\n\n​​AI产品方法论​​\n\n学习需求定义（如用户场景分析）、数据标注规范、模型评估标准。\n​​推荐资源​​：\n书籍：《AI产品经理的实操手册》（李开复）\n案例拆解：智能客服产品需求文档模板\n\n\n\n\n​​跨领域协作​​\n\n学习与算法工程师、数据科学家的协作模式，理解MLOps流程。\n​​推荐资源​​：\n文章：AI团队沟通指南\n\n\n\n\n​​商业化与伦理​​\n\n研究AI产品的商业模式（订阅制、API收费）、数据隐私与伦理问题。\n​​推荐资源​​：\n报告：《AI商业化落地白皮书》\n\n\n\n\n\n\n​​四、实战与求职（1-2个月）​​​​目标​​：通过项目积累经验，打造差异化竞争力。\n\n​​实战项目​​\n\n选择1-2个垂直领域（如医疗、教育），完成从需求分析到落地的完整项目。\n​​推荐方向​​：\n基于大模型的智能问答系统（参考LangChain框架）\n多模态AI应用（图文生成、语音交互）\n\n\n\n\n​​作品集与求职​​\n\n突出技术理解（如模型选型逻辑）和业务价值（如ROI分析）。\n​​推荐资源​​：\n模板：AI产品经理简历模板\n社区：GitHub开源项目（如AI-Product-Case-Studies）\n\n\n\n\n\n\n​​五、免费学习资源汇总​​\n​​系统课程​​\nB站专栏：大模型技术科普与实战\nCSDN资料包：《AI产品经理学习资料包》\n\n\n​​书籍与报告​​\n电子书：《大模型产品经理实战指南》（CSDN可下载）\n行业报告：艾瑞咨询《2025年中国AI应用市场研究告》\n\n\n\n\n​​关键建议​​\n​​空窗期利用​​：通过开源项目或兼职（如AI咨询）积累经验，弱化时间空白。\n​​技术敏感度​​：定期阅读ArXiv论文，关注Hugging Face模型更新。\n​​面试准备​​：刷题《大模型LLMS面试宝典》，模拟产品设计答辩。\n\n通过以上路径，6-8个月可完成转型，建议优先投递AI中台、垂直领域（如医疗AI）岗位，降低竞争压力。\nAI入职条件：\n1.基于模型的边界能力\n能否基于模型的能力边界找到适合的应用场景。\n如：理解LLM、Agent的核心原理，能够结合业务场景系统规划Agent应用场景，有完整的闭环实践经验。\n如：AI文档问答系统。可以用RAG接企业知识库\n基于模型的理解去分析产品的可行性和收益\n判断场景价值：\n    1.这个知识库核心解决什么场景的问题？\n    2.该场景里面的问题有哪些？\n    3.分类可解决与不可解决的问题。\n知识库什么类型？：\n结构化or非结构化？\n有没有上下文强依赖？\n用了AI成本高不高相对之前的方案，提升效果如何？\n※2.能否驱动模型去基于场景做迭代\n最容易暴露我们的能力深度\n如：只知道RAG的架构，有检索有生成，先召回后生成\n问：基于场景，文档怎么做chunk？向量库怎么选？Prompt怎么拼的？上线后怎么兜底？\n要知道：数据怎么拿，要不要清洗，怎么标注，模型怎么选，通用大模型还是微调小模型。\nPrompt怎么设计，要不要加规则兜底？整个系统接到那个业务场景里？稳定性能不能保证。有问题怎么回溯？指标怎么评估？上线后怎么判断成败？\n3.设计好实验，验证方案\n测评：定义所在场景下功能的测评标准和方法，迭代评测指标，分析并且确定后续方向\n如：电商的推荐项目。怎么判断方案有效果？转化率提升了？对照组怎么设计？实验期多长？点击率or转化率？有没有波动分析？局部有限不等于全局有效。\n落地的AI产品经理具备：\n1.设计可执行的方案\n2.清楚实验流程\n3.设定清晰边界\n4.推动数据组拉指标\n","categories":["AIGC"],"tags":["AIGC"]},{"url":"/2025/09/11/Ubuntu/vim%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%A6/","content":"取消vim末行模式下的数字\n全选（高亮显示）：按esc后，然后ggvG或者ggVG\n全部复制：按esc后，然后ggyG\n全部删除：按esc后，然后dG\nvim命令行模式下输入  ：set nu　　取消显示：在vim命令行模式下输入：  set nonu插入内容：\n　　　　i: 插入光标前一个字符\n　　　　I: 插入行首\n　　　　a: 插入光标后一个字符\n　　　　A: 插入行未\n　　　　o: 向下新开一行,插入行首\n　　　　O: 向上新开一行,插入行首\n　　移动光标:\n　　　　 h: 左移\n　　　　j: 下移 \n　　　　k: 上移 \n　　　　l: 右移\n　　　　M: 光标移动到屏幕中间行 \n　　　　L: 光标移动到屏幕最后一行行首 \n　　　　G: 移动到指定行,行号 -G\n　　　　w: 向后一次移动一个字 \n　　　　b: 向前一次移动一个字\n　　　　{: 按段移动,上移 \n　　　　}: 按段移动,下移\n　　　　Ctrl+d: 向下翻半屏 \n　　　　Ctrl+u: 向上翻半屏\n　　　　Ctrl+f: 向下翻一屏 \n　　　　Ctrl+b: 向上翻一屏\n　　　　gg: 光标移动文件开头 \n　　　　G: 光标移动到文件末尾\n　      删除命令:\n　　　　x: 删除光标后一个字符,相当于 Del \n　　　　X: 删除光标前一个字符,相当于 Backspace\n　　　　dd: 删除光标所在行,n dd 删除指定的行数 \n　　　　D: 删除光标后本行所有内容,包含光标所在字符 \n　　　　d0: 删除光标前本行所有内容,不包含光标所在字符\n　　　　dw: 删除光标开始位置的字,包含光标所在字符\n　　撤销命令:\n　　　　u: 一步一步撤销\n　　　 Ctrl+r: 反撤销\n　　重复命令:\n　　　　.: 重复上一次操作的命令\n　　文本行移动:\n　　       &gt;&gt;: 文本行右移 \n　　　   &lt;&lt;: 文本行左移　　  \n 复制粘贴:\n\n　　　　yy: 复制当前行,n yy 复制 n 行\n　　　　p: 在光标所在位置向下新开辟一行,粘贴\n　　可视模式:\n　　　　v: 按字符移动,选中文本 \n　　　V: 按行移动,选中文本可视模式可以配合 d, y, &gt;&gt;, &lt;&lt; 实现对文本块的删除,复制,左右移动\n　　替换操作:\n　　　　r: 替换当前字符 \n　　　　R: 替换当前行光标后的字符\n　　查找命令:\n　　　　&#x2F;: str查找　　　　n: 下一个　　　　N：上一个\n替换命令(并不常用)：\n　　　　把abc全部替换成123:     末行模式下，将当前文件中的所有abc替换成123　　:%s&#x2F;abc&#x2F;123&#x2F;g\n　　　　末行模式下，将第一行至第10行之间的abc替换成123    :1, 10s&#x2F;abc&#x2F;123&#x2F;g\n"},{"title":"AIGC大模型总纲","url":"/2013/07/13/AIGC%E7%AC%94%E8%AE%B0%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94/","content":"复习内容：生成对抗网络（GAN）、基于变换器（Transformer）架构、搭建GPT、BERT、变分自编码器（Variational Autoencoder, VAE）、\n成为AIGC（人工智能生成内容）产品经理的学习路径通常包括以下几个方面：\n\n基础知识：\n\n产品管理基础：学习产品生命周期、市场调研、用户需求分析、MVP（最小可行产品）开发等。\nAI与机器学习基础：了解机器学习、深度学习、自然语言处理（NLP）等基础概念，可以通过在线课程或书籍学习。\n\n\n行业知识：\n\nAIGC的应用领域：研究AIGC在内容创作、游戏、广告、社交媒体等领域的应用案例。\n技术趋势：关注AI技术的最新发展，例如生成对抗网络（GAN）、变换器（Transformer）模型等。\n\n\n技能提升：\n\n数据分析：掌握基本的数据分析技能，能够使用工具如Excel、SQL、Python等进行数据处理和分析。\n用户体验设计：了解用户体验（UX）设计的原则，能够与设计团队合作，创造用户友好的产品。\n\n\n项目经验：\n\n实践项目：参与AIGC相关的项目，实习或个人项目都是很好的选择，可以帮助你理解产品开发的实际流程。\n跨团队合作：与技术团队、市场团队、用户研究团队等进行合作，了解不同角色在产品开发中的作用。\n\n\n社交与网络：\n\n行业交流：加入相关的行业组织或在线社区，参加会议、研讨会，与行业内的专家和同行交流，获取最新信息。\n\n\n持续学习：\n\n关注资源：定期阅读行业博客、白皮书、研究论文，跟踪AIGC的最新动态和趋势。\n\n\n\n下面是对生成对抗网络（GAN）和变换器（Transformer）模型的简要介绍：\n生成对抗网络（GAN）\n基本概念：\n\nGAN是一种深度学习模型，由两部分组成：生成器（Generator）和判别器（Discriminator）。\n生成器负责生成新的数据样本，而判别器则判断样本是真实的还是生成的。\n\n\n工作原理：\n\n生成器接受随机噪声（通常是一个随机向量）作为输入，并生成数据（如图像）。\n判别器接受真实数据和生成的数据，输出一个概率值，表示输入数据是来自真实分布的可能性。\n训练过程中，生成器和判别器相互对抗：生成器希望生成能欺骗判别器的数据，而判别器则希望能准确区分真实数据和生成数据。\n训练目标是使生成器生成的数据越来越真实，同时提高判别器的判断能力。\n\n\n应用：\n\nGAN在图像生成、图像修复、超分辨率成像等领域有广泛应用。\n\n\n\n变换器（Transformer）\n基本概念：\n\nTransformer是一种用于处理序列数据的模型，最初用于自然语言处理（NLP），但也可以应用于其他领域，如计算机视觉。\n其核心特点是自注意力机制（Self-Attention），能够捕捉输入序列中元素之间的关系。\n\n\n工作原理：\n\nTransformer由编码器（Encoder）和解码器（Decoder）两部分组成。编码器将输入序列转换为上下文表示，而解码器根据上下文生成输出序列。\n自注意力机制允许模型在处理序列时，考虑到序列中每个词与其他词的关系，从而提高了长距离依赖的建模能力。\n通过多层堆叠的编码器和解码器，Transformer能够捕捉复杂的模式。\n\n\n应用：\n\nTransformer在机器翻译、文本生成、问答系统等NLP任务中表现出色。此外，经过调整后，Transformer也在图像生成和其他任务中取得了良好效果（如Vision Transformer）。\n\n\n\n这两种模型都是当前深度学习领域的重要技术，各自具有独特的优势和应用场景。希望这些介绍对你有所帮助！如果你有更具体的问题或需要深入的解释，请随时问我。\n用简单的语言来解释大语言模型、神经网络和数学模型，并理清它们之间的关系和区别。\n1. 数学模型\n定义：数学模型是使用数学语言来描述现实世界中某种现象或系统的工具。它可以是方程、公式或不等式。\n例子：用方程描述物体的运动、经济学中的供需模型等。\n作用：帮助理解、预测和分析现象。\n\n2. 神经网络\n定义：神经网络是一种数学模型，受人类大脑神经元结构启发，旨在通过层次化的方式处理和学习数据。\n结构：由输入层、隐藏层和输出层组成，每层包含多个“神经元”，这些神经元之间通过连接权重相互作用。\n例子：图像识别、语音识别等。\n作用：通过训练来学习数据中的模式，从而进行预测或分类。\n\n3. 大语言模型（LLM）\n定义：大语言模型是特定类型的神经网络，专门用于处理和生成自然语言文本。它通常具有非常大的规模，包含亿万到千亿个参数。\n结构：基于变换器（Transformer）架构，能够理解和生成语言的上下文。\n例子：GPT、BERT等。\n作用：能够进行文本生成、翻译、问答等多种语言任务。\n\n它们之间的关系\n数学模型是最广泛的概念，可以包括各种形式的模型（如方程、函数等），神经网络就是其中的一种。\n神经网络是特定类型的数学模型，利用层次结构和非线性激活函数来学习复杂的数据模式。\n大语言模型是神经网络中的一个具体应用，通常基于变换器架构，专注于处理和生成自然语言。\n\n总结\n数学模型 &gt; 神经网络 &gt; 大语言模型数学模型是广义的，神经网络是特定的类型，而大语言模型是神经网络的一个具体应用。这些模型在数据处理和预测中逐层深入，逐步实现更复杂的功能。\n\n机器学习是人工智能的一个分支，旨在使计算机能够通过经验自动学习和改进。下面是机器学习的基本原理和主要技术能力的概述：\n机器学习原理\n数据驱动：\n\n机器学习依赖大量的数据，通过分析数据中的模式和结构进行学习。数据通常分为训练集、验证集和测试集。\n\n\n模型：\n\n机器学习使用数学模型来表示输入与输出之间的关系。模型通过学习数据中的特征来进行预测或分类。\n\n\n训练过程：\n\n监督学习：模型在有标签的数据上进行训练，目标是学习输入与输出之间的映射关系。例如，给定图像及其对应标签，模型学习识别图像内容。\n无监督学习：模型在没有标签的数据上进行训练，目标是发现数据中的潜在结构或模式，例如聚类和降维。\n强化学习：通过与环境交互学习，模型根据获得的奖励或惩罚调整行为，目标是最大化长期奖励。\n\n\n损失函数：\n\n在训练过程中，模型通过损失函数评估预测值与真实值之间的差距，优化算法（如梯度下降）用于调整模型参数以最小化损失。\n\n\n评估和验证：\n\n使用不同的数据集（如测试集）评估模型性能，常见指标包括准确率、精确率、召回率和F1-score等。\n\n\n\n机器学习的技术能力\n分类：\n\n将输入数据分为不同类别，如垃圾邮件检测、图像分类等。\n\n\n回归：\n\n预测连续数值，如房价预测、销售额预测等。\n\n\n聚类：\n\n无监督学习方法，将数据分组，使得同一组内的样本相似度较高，而不同组之间的相似度较低，如客户细分。\n\n\n降维：\n\n减少数据的维度，保留最重要的信息，用于数据可视化和噪声去除，如主成分分析（PCA）。\n\n\n生成模型：\n\n生成新数据样本，如生成对抗网络（GAN）和变分自编码器（VAE），用于图像、文本等生成任务。\n\n\n序列建模：\n\n处理时间序列数据或序列数据，如自然语言处理中的文本生成和翻译，常用的模型有RNN、LSTM和Transformer。\n\n\n\n应用场景机器学习在各个领域有广泛应用，包括：\n\n金融：风险评估、欺诈检测、交易算法。\n医疗：疾病预测、医学图像分析。\n营销：推荐系统、用户行为分析。\n自动驾驶：环境感知、路径规划。\n\n通过理解机器学习的原理和技术能力，可以更好地应用这些技术解决实际问题。\n变分自编码器（Variational Autoencoder, VAE）是一种生成模型，结合了自编码器和变分推断的思想。它能够从潜在空间中生成新的样本，同时学习数据的分布。以下是VAE的详细介绍：\n1. 基本概念\n自编码器：自编码器是一种无监督学习模型，由编码器和解码器两部分组成。编码器将输入数据压缩为潜在空间的表示，解码器则从潜在表示重建输入数据。\n\n变分推断：变分推断是一种通过优化近似推断分布来进行贝叶斯推断的方法。VAE利用这种思想来学习潜在变量的分布。\n\n\n2. VAE的结构\n编码器（Inference Network）：\n\n将输入数据 ( x ) 映射到潜在空间中的分布。具体来说，编码器输出潜在变量 ( z ) 的均值 ( \\mu ) 和方差 ( \\sigma^2 )，表示为 ( q(z|x) )。\n\n\n潜在空间：\n\nVAE假设潜在变量 ( z ) 服从某个分布，通常选择标准正态分布 ( N(0, I) ) 作为先验分布 ( p(z) )。\n\n\n解码器（Generative Network）：\n\n从潜在变量 ( z ) 中重建输入数据，表示为 ( p(x|z) )。\n\n\n\n3. 训练过程VAE的目标是最大化边际似然 ( p(x) )，即输入数据的生成概率。由于直接计算 ( p(x) ) 是困难的，VAE通过变分推断使用以下目标函数进行优化：\n\n变分下界（ELBO）：\n\n[\\mathcal{L}(x; \\theta, \\phi) &#x3D; \\mathbb{E}{q(z|x)}[\\log p(x|z)] - D{KL}(q(z|x) | p(z))]\n\n第一项是重构损失，表示给定潜在变量 ( z ) 重建输入数据的能力。\n第二项是Kullback-Leibler散度（KL散度），用于衡量近似后验 ( q(z|x) ) 与先验分布 ( p(z) ) 之间的差异。\n\n4. 优化算法使用反向传播和随机梯度下降（SGD）等优化算法来优化损失函数，更新编码器和解码器的参数。\n5. 应用场景\n生成任务：VAE可以生成与训练数据相似的新样本，如图像、文本等。\n数据缺失填充：通过学习数据的潜在结构，可以填补缺失数据。\n异常检测：通过重构损失，可以检测与训练数据分布显著不同的样本。\n\n6. 优势与不足优势：\n\nVAE能够学习数据的潜在分布，并从中生成新样本。\n它在处理高维数据（如图像）时表现良好。\n\n不足：\n\n生成的样本可能较模糊，特别是在复杂数据上。\nVAE可能会遇到“模糊性”问题，导致生成的样本缺乏细节。\n\n总结变分自编码器（VAE）是一种强大的生成模型，能够学习数据的潜在结构并生成新的数据样本。通过结合自编码器的特性与变分推断的框架，VAE在多个领域的应用中展现了其潜力。\n神经网络和机器学习之间的关系密切，神经网络是机器学习的一种重要方法。下面详细阐述它们的关系以及如何互相配合和迭代。\n神经网络与机器学习的关系\n分类关系：\n\n机器学习是一个广泛的领域，包含了多种算法和模型，旨在让计算机从数据中学习并进行预测或决策。它包括监督学习、无监督学习、强化学习等。\n神经网络是机器学习的一种具体实现，属于深度学习的范畴。它模拟人脑神经元的结构和功能，能够处理复杂的数据模式和特征。\n\n\n模型复杂性：\n\n神经网络特别适合处理高维数据（如图像、文本和声音），能够学习复杂的非线性关系。相较于传统的机器学习算法（如线性回归、决策树），神经网络具有更强的表达能力。\n\n\n\n如何互相配合和迭代\n模型选择：\n\n在机器学习的任务中，可以根据数据的特性和任务的复杂性选择使用神经网络或其他算法。例如，对于简单的分类任务，可能使用逻辑回归；而对于图像识别或自然语言处理等复杂任务，则更倾向于使用神经网络。\n\n\n特征工程：\n\n在传统机器学习中，特征工程是一个关键步骤，通过手动选择和构造特征来提高模型性能。神经网络通过其层次结构能够自动提取特征，减少了对手动特征工程的依赖。\n但是，结合这两者的力量，使用机器学习的方法对数据进行初步处理和特征提取，再将结果输入神经网络，可以提升性能。\n\n\n集成学习：\n\n在某些场景中，可以将神经网络与传统机器学习模型结合，形成集成学习。例如，使用多个模型（如决策树、支持向量机和神经网络）的预测结果进行加权平均，从而提高整体性能。\n\n\n迭代优化：\n\n机器学习和神经网络的迭代优化过程通常是交替进行的。可以通过实验不同的模型结构、超参数调整和训练策略，不断迭代，寻找最佳解决方案。\n在此过程中，可以结合传统机器学习方法（如交叉验证、网格搜索）来优化神经网络的超参数，提高模型的泛化能力。\n\n\n反馈机制：\n\n在生产环境中，机器学习模型（包括神经网络）需要不断更新。通过收集新数据和模型性能反馈，可以迭代优化模型，确保其适应新的数据分布和任务需求。\n\n\n\n总结神经网络是机器学习的一个重要组成部分，二者相辅相成。在实际应用中，可以根据任务需求选择合适的方法，并通过特征工程、集成学习和迭代优化等策略，将它们结合起来，提升模型的性能和适应性。通过不断的反馈和优化，可以实现更高效的学习过程。\n还有许多其他重要的模型值得关注和学习。以下是一些当前热门的深度学习模型：\n\n卷积神经网络（CNN）：CNN在图像分类、目标检测、人脸识别等领域有着广泛的应用。它通过卷积核进行局部特征的学习，并通过多层卷积和池化操作提取抽象特征。\n\n循环神经网络（RNN）：RNN适用于处理序列数据，如文本、语音和时间序列等。它的循环结构允许对序列中的每个元素进行逐一处理，捕捉时间依赖关系。\n\n长短期记忆网络（LSTM）：LSTM是RNN的一种改进形式，通过引入记忆单元来解决梯度消失问题，提高了长期依赖学习能力5。\n\n变分自编码器（VAEs）：VAEs在生成逼真的数据分布方面表现出色，通过对输入数据进行概率建模来进行数据生成。\n\n物理信息机器学习（Physics-Informed Machine Learning）：结合物理先验和数据，提高了机器学习模型的泛化能力和可解释性，适用于科学和工程领域1。\n\n扩散模型（Diffusion Model）：基于物理信息的深度生成模型，能够在各种任务中生成高质量的样本。\n\n自回归模型：如GPT-3，在文本生成任务中展示了强大的能力\n一、什么是 BERT？BERT 利用基于 Transformer 的神经网络来理解和生成类似人类的语言。BERT 采用仅编码器的架构。在原始 Transformer 架构中，既有编码器模块，也有解码器模块。在 BERT 中使用仅编码器架构的决定表明主要强调理解输入序列而不是生成输出序列。\n\n\n1、BERT 的双向方法传统语言模型按顺序处理文本，从左到右或从右到左。这种方法将模型的感知限制在目标词之前的直接上下文中。BERT 使用双向方法（B 就是 Bidirectional（双向）），同时考虑句子中单词的左右上下文，而不是按顺序分析文本，BERT 同时查看句子中的所有单词。\n2、预训练和微调BERT 模型经历了两个步骤：\n\n对大量未标记的文本进行预训练，以学习上下文嵌入。\n\n对标记数据进行微调，以执行特定的 NLP 任务。\n\n\n二、BERT 的工作原理BERT 旨在生成语言模型，因此仅使用编码器机制。将 token 序列输入到 Transformer 编码器。这些 token 首先嵌入到向量中，然后在神经网络中处理。输出是一系列向量，每个向量对应一个输入 token，提供上下文化表示。\n在训练语言模型时，定义预测目标是一项挑战。许多模型会预测序列中的下一个单词，这是一种定向方法，可能会限制上下文学习。BERT 通过两种创新的训练策略解决了这一挑战：\n掩码语言模型 (Masked Language Model，MLM)\n预测下一句 (Next Sentence Prediction，NSP)\n\nMLM在 BERT 的预训练过程中，每个输入序列中的一部分单词被屏蔽（掩码），并训练模型根据周围单词提供的上下文预测这些掩码单词的原始值。\n\n简单来说，\n掩码单词：在 BERT 从句子中学习之前，它会隐藏一些单词（约 15%）并用特殊符号替换它们，例如 [MASK]。\n猜测隐藏的单词：BERT 的工作是通过查看周围的单词来找出这些隐藏的单词是什么。这就像一场猜测某些单词缺失的游戏，BERT 会尝试填补空白。\nBERT 如何学习：\nBERT 在其学习系统之上添加了一个特殊层来做出这些猜测。然后，它会检查其猜测与实际隐藏的单词有多接近\n它通过将猜测转换为概率来实现这一点，说“我认为这个单词是 X，我对此非常确定。”\n4 特别关注隐藏的单词\nBERT 在训练期间的主要重点是正确获取这些隐藏的单词。它不太关心预测未隐藏的单词。\n这是因为真正的挑战是找出缺失的部分，这种策略有助于 BERT 真正理解单词的含义和上下文。\n从技术角度来说，\nBERT 在编码器的输出之上添加了一个分类层。这一层对于预测掩码词至关重要。\n分类层的输出向量与嵌入矩阵相乘，将它们转换为词汇维度。此步骤有助于将预测的表示与词汇空间对齐。\n使用 SoftMax 激活函数计算词汇表中每个单词的概率。此步骤为每个掩码位置生成整个词汇表的概率分布。\n训练期间使用的损失函数仅考虑掩码值的预测。该模型因其预测与掩码词的实际值之间的偏差而受到惩罚。\n该模型的收敛速度比定向模型慢。这是因为在训练期间，BERT 只关心预测掩码值，而忽略非掩码词的预测。通过这种策略实现的增强的环境意识弥补了较慢的收敛速度。\n（Softmax函数 是一种常用于多类分类问题的激活函数。它将输入的实向量转换为概率分布，使得每个元素的值在0到1之间，并且所有元素的总和为11。\n主要作用\n\n概率分布：Softmax函数将输入的实向量转换为概率分布，这意味着输出的每个值都可以解释为某个类别的概率。这在多类分类任务中尤为重要，因为它可以帮助模型确定每个类别的可能性1。\n\n归一化：Softmax函数对输入进行归一化处理，使得输出的总和为1。这有助于标准化每个神经元的输出，确保输出值在0到1之间2。\n\n多分类任务：Softmax函数特别适用于多分类任务的输出层。它可以处理超过两个类标签的情况，并将其转换为概率分布，从而帮助模型进行分类决策2。\n\n\n公式\nSoftmax函数的公式如下： [ \\text{Softmax}(x_i) &#x3D; \\frac{e^{x_i}}{\\sum_{j} e^{x_j}} ] 其中，( x_i ) 是输入向量中的第 ( i ) 个元素，( e ) 是自然对数的底1。）\n2. NSPBERT 预测第二句是否与第一句相连。这是通过使用分类层将 [CLS] 标记的输出转换为 2×1 形状的向量，然后使用 SoftMax 计算第二句是否跟在第一句后面的概率来实现的。\nBERT 预测第二句是否与第一句相连。这是通过使用分类层将 [CLS] 标记的输出转换为 2×1 形状的向量，然后使用 SoftMax 计算第二句是否跟在第一句后面的概率来实现的。\n在训练过程中，BERT 学习理解句子对之间的关系，预测第二句是否跟在原始文档中的第一句后面。\n50% 的输入对将第二句作为原始文档中的后续句子，而另外 50% 的输入对具有随机选择的句子。\n为了帮助模型区分连接和断开的句子对。在进入模型之前对输入进行处理：\n在第一句的开头插入 [CLS] token，并在每个句子的末尾添加 [SEP] 标记。\n在每个 token 中添加表示句子 A 或句子 B 的句子嵌入。\n位置嵌入指示每个 token 在序列中的位置。\nBERT 预测第二句是否与第一句相连。这是通过使用分类层将 [CLS] token 的输出转换为 2×1 形状的向量来实现的，然后使用 SoftMax 计算第二句是否跟在第一句后面的概率。\n为什么要一起训练 MLM 和 NSP？\n在 BERT 模型的训练过程中，MLM 和 NSP 一起训练。该模型旨在最小化 MLM 和 NSP 的组合损失函数，从而形成一个强大的语言模型，增强了理解句子内上下文和句子间关系的能力。\n推荐系统构建：构建实时化推荐生态构建大型实时AI推荐引擎，本质是推动数据、算法、工程三大体系的深度协同与持续进化：\n\n数据层：流式处理能力是基础，目标是将原始数据实时转化为驱动推荐的高价值特征（DataasFeatures）。\n算法层：在线学习与离线批量训练、强化学习结合，赋予模型持续自优化能力，紧贴业务动态。\n工程层：熔断、弹性伸缩、混合部署等架构设计，在追求极致实时性的同时，构筑坚如磐石的系统稳定性。\n\n用于评估模型的性能：\nGLUE：\nGLUE基准数据集介绍_glue数据集-CSDN博客\nMultiNLI：\nnyu-mll&#x2F;multi_nli ·Hugging Face 的数据集\nSQuAD：\n深度解析NLP问答系统：Deepset SQUAD与SQuAD v2评估实践-百度开发者中心\n一、AI时代产品经理面临的四大核心挑战1. 从技术确定性到不确定性的转变传统产品开发遵循明确的输入输出框架，而AI产品特别是大模型应用具有显著的不确定性特征。一个提示词可能产生完全不同的输出结果，这对产品设计提出了全新要求。产品经理需要建立”概率思维”，能够评估和管理这种不确定性，将其控制在用户可接受的预期范围内。  \n\n跨领域协作复杂度激增AI产品的开发涉及数据科学、算法工程、用户体验设计、伦理法律等多个专业领域。例如，开发一个智能客服系统需要协调NLP工程师、对话设计师、合规专家等不同背景的团队成员。产品经理必须具备跨界沟通能力，能够理解各领域的专业语言，并在技术可行性与用户体验之间找到平衡点。  \n\n产品边界与功能定义的重新思考AI技术特别是生成式AI的能力边界不断扩展，使得传统产品功能划分方式不再适用。产品经理需要从”客户要完成的工作”(Jobs to be done)角度重新定义产品，而非局限于特定功能。例如，Notion AI不仅优化了文档编辑体验，更重新定义了知识工作流程。  \n开发流程与评估体系的革新传统产品开发中的”设计-开发-测试”线性流程在AI时代面临挑战。产品经理需要掌握快速原型开发能力，通过Prompt工程快速验证AI能力边界，并建立全新的评估指标体系。例如，对生成式AI产品，除了传统可用性指标外，还需评估输出质量稳定性、多样性等新维度。二、AI产品经理的五大转型策略1. 技术理解与商业洞察的平衡AI产品经理不需要成为算法专家，但必须掌握技术基本原理和能力边界。关键学习内容包括：大模型的核心能力与局限常见AI技术栈(如LangChain等工具链)数据需求与训练流程伦理风险与合规要求同时保持对行业趋势的敏锐洞察，定期分析竞品技术路线和商业模式。  \n采用敏捷开发与持续迭代方法论AI产品开发应遵循”小步快跑”原则：快速推出最小可行产品(MVP)验证核心价值建立用户反馈闭环系统基于数据持续优化模型和体验典型案例：ChatGPT从3.5到4.0版本的迭代过程中，持续优化了响应质量、多模态能力和定制化水平。  \n构建跨学科协作框架建立高效的跨团队协作机制：与技术团队：共同定义评估指标和测试用例与设计团队：共创AI原生交互范式与法务团队：提前规划合规路径与用户社区：建立共创生态推荐工具：使用Notion或类似平台搭建跨领域知识库，确保信息透明共享。  \n用户研究与体验设计的范式升级AI产品需要全新的用户研究方法：开展”AI可用性测试”，观察用户与系统的自然互动设计”容错体验”，优雅处理AI的不确定性输出开发”协同创作”模式，平衡自动化与用户控制权优秀案例：Midjourney通过Discord社区实现了创作者间的相互学习和激发，形成了独特的共创文化。  \n建立负责任AI的产品框架将伦理考量融入产品全生命周期：公平性：监控算法偏见透明性：提供解释机制隐私保护：实施数据治理社会影响：评估长期后果实用工具：微软的负责任AI清单提供了系统化的检查框架。三、未来展望：AI与产品经理的共生进化到2026年，Gartner预测75%的企业将把AI纳入产品开发流程。产品经理的角色将向三个方向分化：AI策略产品经理：制定企业级AI产品路线图AI体验设计师：打造人机协同的最佳体验AI伦理架构师：确保技术应用的负责任性成功的关键在于保持”终身学习”心态，将AI视为增强能力的伙伴而非威胁。产品经理需要发展机器无法替代的人类优势：同理心、创造力、战略思维和伦理判断。行动指南：从今天开始的转型步骤技能评估：用1周时间完成AI能力自测，识别知识缺口实践学习：选择1个AI工具(如ChatGPT API)进行深度探索项目实践：在现有工作中引入1个AI增强的工作流程社群连接：加入至少1个AI产品经理专业社区思维转变：每月进行1次”AI如何改变我的产品领域”的专题思考\n\n\n\n\n\n开源框架：\nEvalScope自动化评测\n三大项功能：自动化评测、可视化报告、归因分析\n还有AGI-Eval评测社区、openCompass司南、Chatbot Arena| openLM.ai,FlagEval天秤评测、C-Eval、GAIA基准测试\n面试问答：\nQ3. 目前AI Agent产品有哪几种设计模式？分别有什么特点？\nA3：吴恩达教授在红杉资本AI Ascent的分享中提到反思（reflection）、**工具使用（Tool use）、规划（Planning）、多智能体协作（Multiagent collaboration）**四种AI Agent设计模式。\n\n反思（Reflection）：指的是AI代理在执行任务时能够自我评估和调整其行为的能力。通过反思，AI可以学习从经验中获得教训，从而在未来的决策中做出更好的选择。\n工具使用（Tool Use）：这涉及到AI代理能够识别、选择和使用不同的工具或资源来完成特定的任务。例如，一个机器人可能会使用不同的工具来修理设备或完成建筑任务。\n规划（Planning）：这是指AI代理能够制定和执行长期或复杂的计划。规划能力使AI能够预见未来的需求和挑战，并提前做出相应的安排。\n多智能体协作（Multiagent Collaboration）：这涉及到多个AI代理能够协同工作，共同完成更复杂的任务。这种协作可以提高效率和效果，尤其是在需要不同技能和资源的情况下。\n\nQ4. AI Agent平台，一般有哪些功能模块？\n**A4：**基于LLM的chatbot0-1搭建，包括：【智能体创建】、【智能体配置】、【智能体调试】、【智能体发布】功能；以及【智能体商城】功能，支持用户从平台中挑选其感兴趣的智能体进行应用和体验；以及多智能体协作功能。\n关于【智能体配置】功能，包括智能体『基本信息配置』（名称、头像、简介、LLM模型选择与参数配置（工作技能和工作内容&amp;流程描述、温度值等）、『智能体复杂配置』（工作流配置、插件配置、知识库配置等）；\n\n在【LLM】选择和配置上，平台一般均会提供【自家LLM】和【三方LLM】，供用户挑选；在LLM配置上，一般支持配置LLM的温度值、系统提示词、TOPK等参数；\n在【工作流】配置功能中，Agent平台，基本上均实现了“画布式”可视化配置方式，用户可通过拖拽节点组件{LLM、插件、数据库、会话、变量等}来完成工作流配置。\n在【插件】选择上，平台支持用户从平台整合好的【预置插件商城】中选择，也支持用户【自定义插件】。\n在【知识库】配置功能中，一般的Agent平台，均支持导入外部文档资料（如pdf、excel、word等），功能丰富一些的Agent平台不仅支持离线导入文档，还支持“连接数据库”（如语聚AI，支持连接飞书文档，需提前定义好API相关配置）\n\n\n三、国内外AI Agent产品盘点\n3.2 21款 国内AI Agent构建平台盘点\nAI产品经理总结大纲：AI产品经理的竞品分析：传统的产品调研：功能+表表格，总结差别。产品设计意图，实践方式\nAI的产品调研：\n1.前台看体验和设计意图\n    不是看产品有没有这个功能，而是看通过AI怎么实现。\n    这个功能为什么重要。\n例如：NotionAI和Jasper，都能生成文章，差别在NotionAI是无感启动，本质靠的是Prompt上下文拼接能力+多轮的语境记忆。\n而Jasper，主打营销场景。预设品牌调性和内容风格。选择模版，自动给出结构。底层是靠场景的微调+Prompt模板库\n调研方法：需要上手操作记录路径。分析触发机制。甚至观察loading时长。\n底层是分析出到底解决了那部分用户的什么问题。\n具体路径怎么设计，prompt怎么组织，反馈怎么迭代\n2.中台看模型\n模型、数据是差距点\n调查看是调用OpenAI接口还是自己训练的模型。有没有加RAG？有没有LoRA做微调？有没有做数据闭环？\n可以抓包看看API调用的参数，是不是带温度的数据\n※推理方法：测同一个Prompt，在多个产品上的效果，观察差多少，就可以反推出背后用的模型的类型\n有些产品表面是智能问答，但推理发现不是大模型干的，而是传统的检索的方式\n就可以分析到竞品的模型选型，推理的策略，数据结构，可控能力\n3.底层看商业\n例如：AI写作工具。\n分析它的盈利模式，赚钱的逻辑。是靠卖Saas订阅？还是API调用？还是Toc做效率工具？还是ToB做内容生产？\n根据盈利方式的不一样，后续的推理链路就不同。\n例如：比如OpenAI是API型产品，成本敏感，必须依靠提示词优化+模型压缩，去降推成本\n如Jasper是Saas+模板场景型的产品。关键点就是转化率+续费\n要在垂直场景体验足够好\nAI产品经理的PRD1.了解PRD规范\n2.把问题定义清楚\n3.有没有能力让算法落地成产品\n一、项目背景：\n作用：定义问题。\n用一段话说明我们现在在解决什么具体的业务问题。之前我们靠什么方式解决，为什么现在值得用AI试\n如：\n    一.1.现在要解决什么问题：\n                当前客服系统主要依赖于规则引擎，覆盖率是百分之多少，剩余百分之多少依赖人工。\n    一.2.之前靠什么方式解决&#x2F;痛点：\n                在哪些场景之下，比如说退款改签售后，这些高频的复杂场景之下，规则系统的问题是什么。维护成本高，响应不及时，这会导致用户的满意度下降\n    一.3.为什么现在值得AI做？：\n                所以为了提升这些指标，并且降低人力成本，那当前的大模型方案，他的优势是什么，能够多大程度，解决什么场景的问题\n二、项目目标：\n    这是算法落地的基础。\n        1.业务目标：要提升什么指标？转化率？自助率？满意度？\n            如：讲FAQ类的问题自动应答率提升到85%，保持满意度不低于当前的某个指标。\n        2.技术约束：数据够不够？能不能跑在线？延迟是多少？冷启动能不能接受？\n            如：不涉及订单相关的问题处理，优先覆盖标准可枚举类问题\n        3.边界判断：明确先不解决什么，只做哪一类的能力。\n            如：模型的部署延迟要求是3s，如超时自动切换成规则兜底\n三、需求内容：\nPRD核心部分。不是回答要不要做AI，要把整条链路，从输入到输出，从数据到反馈，清晰写下来。\n1.数据从哪里来：用用户提的问题？还是现有的文档？还是人工标注？\n    如：智能客服情况下，只选高频出现的问题+人工客服的标准回答\n2.把信息喂给模型：是直接拼成Prompt？还是先做检索，检索要不要做摘要？\n提前设计逻辑。怎么选内容，怎么拼接上下文，有没有超长被截断 的风险？\n3.大模型出来的答案能不能直接用？\n不能用怎么办？策略是什么？有没有兜底？有没有设置信任分数阈值？万一答错了用户能不能是别别出来？能不能切换成规则？\n四、实验设计：\n不能说放10%流量测试一下。一定要先定义好成功的标准是？分流的机制怎么做？，放量怎么安排，出问题怎么识别？怎么回退？\n什么是微调？面试官可以通过你对微调的深度，去看你所做的AI产品和业务场景结合的深度。\n微调 深度&#x3D;（AI（结合）业务场景）的 深度\n理解什么是微调：\n（个人理解总结公式）\n1.选型通用大模型：GPT → 拿公司具体数据进行训练 &#x3D;懂需求（变成我们这个领域的专家）\n举例：\n做一个AI电商客服：\n先让模型理解我们的业务，如：用户问怎么退货？\n通用模型回答：市面平台政策是怎么样的，你可以根据情况进行退货\n（套路公式化）\n微调后模型回答：我们公司的政策支持7天无理由退款、已发货仅退款….用户可以按照我们以下步骤进行退货。下面是直达链接与细节策略\n（更具体更细节，更智能）\n产品经理与算法工程师职能分工：\n产品经理：提出问题和标准的人\n算法工程师：是解决问题的人\n产品：建立模型评测标准：判断什么场景需要AI解决、指标如何反馈。\n算法：怎么训模型：训练框架选型、调整参数、显卡资源\n※微调指标四步：一、清晰的目标：（明确指标）例：退货相关的：FAQ的命中率从70%提升到85%，客户与机器人的平均对话轮次从4轮优化到2轮\n从而得出FAQ命中率指标：85%，对话轮次指标：2轮等\n二、高质量数据：（查、洗、标、批）如何获得高质量数据？\n例：自己获取或者配合相关人员，\n1.提取获取历史的客服对话里面提取高频场景。（查：查高频场景）\n2.挑选脏情绪化表达的脏数据进行清洗。（洗：清洗脏数据）\n3.设计标注的规则：表明正确回复应该怎么去做（标：简历标注规则）\n4.整理成数据需求，提出给标注组的同学（或数据分析岗），让其批量化产出这样质量的数据。（批：批量生成高质量数据）\n三、选择策略：了解微调路径信息例：\n全参数微调：（理解能力强，训练资源，时间等成本高）\n需要模型特别强的理解能力：把整个模型的参数全部打开，重新训练。 \n如：多轮的复杂对话，个性化的服务\nQLoRA：（修改少量参数，成本低，轻量化）\n只训练一小部分参数，训练成本低，轻量化部署。适合中型业务或者快速迭代的业务\n如：咨询项目训练，一周时间让FAQ命中率提升17%\n提示词微调：Prompt工程\n四、上线验证结果反馈：\n灰度上线的机制\nAB实验\n对比分析问题\n是否达成目标，问题背后的原因\n然后推动解决\nAI产品经理跟算法协作：1.标准怎么定义\n怎么基于业务场景，定义出模型的理想态？明确清楚模型的评估指标。模型不是精度越高越好\n如：智能问答系统。假设准确率高，但响应慢就会导致用户流失\n如：推荐系统。假设点击率涨了，但转化率掉了，业务就会不满意\n拆解业务目标背后的算法策略：产品理想态和评估标准设计：\n与算法讨论。确定主要指标，其他指标的容忍度？优先精准还是覆盖？优先保证稳定性还是最大化的探索空间？\n2.数据怎么准备\n数据准备与特征设计\n决定模型效果的很大程度，不是选择什么模型，更多是用了什么数据。\n所以要熟悉业务数据，确定哪些字段对模型有价值。哪些是噪音。明确标签的标准。\n是否需要主观的标注？标注人员是否理解场景？\n是否要额外的去补充外部的数据？是否需要把用户群体分层？\n把数据和业务结合拆解清楚，是数据准备与特征设计的重要一步\n模型后续的起点也高很多\n3.上线后怎么优化？\n上线前：\n推动上线前的实验，怎么分实验组对照组，要看什么？怎么判断实验有效？\n上线后：\n盯着效果波动，进行记录，是否冷热启动的问题？数据的漂移？用户行为发生的变化？\n基于真实数据去定位问题，推动算法协调算法，一起去解决\n优化策略\nFAQ命中率指智能客服系统通过FAQ链接层快速匹配用户问题并返回准确答案的比例。优化命中率需结合FAQ链接层与RAG（Retrieval-Augmented Generation）机制，通过以下方式实现：\n优化策略\n\n‌构建四层知识结构‌：采用“主题-子主题-问题-答案”体系，将高频问题归类至FAQ层，复杂问题通过RAG检索。 ‌‌1\n\n‌扩展问法覆盖‌：通过高扩展问（20-30条&#x2F;知识点）提升模型泛化能力，覆盖口语化、工具化等变体，命中率可达80-85%。 ‌‌2\n\n‌多源同步策略‌：通过API接口或ETL同步机制整合多源知识，确保知识库统一性和时效性。 ‌‌1\n\n‌兜底策略‌：当RAG无法匹配时，自动引导至FAQ层或人工介入，避免“抱歉，我不知道”的尴尬。\n遇到问题。优化检查\n\n\n\n‌纯RAG模式‌：因检索效率低、数据不干净等问题，可能导致30%的回答失败率。 ‌‌3\n‌忽视数据质量‌：训练数据偏差或噪声干扰会降低模型泛化能力，需通过数据清洗和扩展问法优化。\n\nAI入职条件：\n1.基于模型的边界能力\n能否基于模型的能力边界找到适合的应用场景。\n如：理解LLM、Agent的核心原理，能够结合业务场景系统规划Agent应用场景，有完整的闭环实践经验。\n如：AI文档问答系统。可以用RAG接企业知识库\n基于模型的理解去分析产品的可行性和收益\n判断场景价值：\n    1.这个知识库核心解决什么场景的问题？\n    2.该场景里面的问题有哪些？\n    3.分类可解决与不可解决的问题。\n知识库什么类型？：\n结构化or非结构化？\n有没有上下文强依赖？\n用了AI成本高不高相对之前的方案，提升效果如何？\n※2.能否驱动模型去基于场景做迭代\n最容易暴露我们的能力深度\n如：只知道RAG的架构，有检索有生成，先召回后生成\n问：基于场景，文档怎么做chunk？向量库怎么选？Prompt怎么拼的？上线后怎么兜底？\n要知道：数据怎么拿，要不要清洗，怎么标注，模型怎么选，通用大模型还是微调小模型。\nPrompt怎么设计，要不要加规则兜底？整个系统接到那个业务场景里？稳定性能不能保证。有问题怎么回溯？指标怎么评估？上线后怎么判断成败？\n3.设计好实验，验证方案\n测评：定义所在场景下功能的测评标准和方法，迭代评测指标，分析并且确定后续方向\n如：电商的推荐项目。怎么判断方案有效果？转化率提升了？对照组怎么设计？实验期多长？点击率or转化率？有没有波动分析？局部有限不等于全局有效。\n落地的AI产品经理具备：\n1.设计可执行的方案\n2.清楚实验流程\n3.设定清晰边界\n4.推动数据组拉指标\n","categories":["AIGC"],"tags":["AIGC大模型总纲"]},{"title":"Conda 环境导入","url":"/2013/07/13/conda/conda%20%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%85%A5/","content":"联网复制1.导出已有环境激活环境env_name(环境名称)\nconda activate env_name导出环境\nconda env export –file env_name.yml将env_name.yml复制到另一台机器上，导入\nconda env create -f env_name.yml复制到环境仅包含原来环境中使用conda install 安装的包。2. 导入pip安装的包(需进入虚拟机环境)导出安装库(源机器)\npip freeze &gt; requirements.txt导入安装库(目标机器)\npip install -r requirements.txt离线环境将envs目录下的env_name(环境名称)文件夹复制到目标机器上通过以下命令导入conda create -n env_name –clone .&#x2F;env_name –offline若显示以下结果，则表示导入成功conda虚拟环境复制_第1张图片\n","categories":["Anaconda"],"tags":["Anaconda_环境导入"]},{"title":"Conda 环境导入","url":"/2013/07/13/conda/conda%20%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%85%A52/","content":"conda本身的命令里是有移植这个选项的。假如前提是，在本地的conda里已经有一个AAA的环境，我想创建一个新环境跟它一模一样的叫BBB，那么这样一句就搞定了：\nconda create -n BBB –clone AAA1但是如果是跨计算机呢。\n其实是一样的。\n查询conda create命令的原来说明，是这样的：\n–clone ENVPath to (or name of) existing local environment.12–clone这个参数后面的不仅可以是环境的名字，也可以是环境的路径。\n所以，很自然地，我们可以把原来电脑上目标conda环境的目录复制到新电脑上，然后再用：\nconda create -n BBB –clone ~&#x2F;path1就直接一步安装了所有的包，完成了环境的移植。原来的电脑上的环境的地址可以用conda info -e 查询到。\n但是注意有个小的问题：移植过来的环境只是安装了你原来环境里用conda install等命令直接安装的包，你用pip之类装的东西没有移植过来，需要你重新安装。\n在服务器上想要使用别人搭好的环境，但是又怕自己对环境的修改更新会影响他人的使用，这个时候可以使用conda命令进行复制环境。首先假设已经安装了Anaconda。\n根据已有环境名复制生成新的环境假设已有环境名为A，需要生成的环境名为B：\nconda create -n B –clone A1根据已有环境路径复制生成新的环境假设已有环境路径为D:\\A，需要生成的新的环境名为B：\nconda create -n B –clone D:\\A1生成的新的环境的位置在anaconda的安装路径下，一般情况在D:\\Anaconda3\\envs\\文件夹下。\n","categories":["Anaconda"],"tags":["Anaconda_环境导入"]},{"title":"Conda 环境导入","url":"/2013/07/13/conda/conda/","content":"查看虚拟环境 conda info -e\n2019-05-16 update: 这个道理跟家里的电视机是一样一样的，安装conda就相当于买了一台电视机，但是有电视了不意味着你就能看节目了，你要手动添加频道才能看你想看的电视节目。官方channel: (先不要急着添加这两个哦,只要添加下面的清华的4个镜像地址就足够了的)：\nconda config –add channels biocondaconda config –add channels conda-forge官方的话这两个channel应该就够了的。\n2020-06-14 update：但是其实现在用国内的镜像比较多，官方的频道相较而言速度较慢。但也不是绝对的，有小伙伴跟我说他使用官方的频道也很流畅，所以见仁见智啦。另外，不建议加入大量的相同的频道，如添加了官方的bioconda之后又添加清华的bioconda镜像，没有必要，而且会拖慢速度。\n2019-06-12 update：最近在装raxml-ng的时候发现了一个新的channel叫genomedk，各位也可以添加到condarc里去 👇\n这个频道有的时候会引起网络错误, 网络不稳定的朋友不建议加.conda config –add channels genomedk顺便安利一个我hoptop学长的教程：如何搭建一个本地的conda镜像（包含bioconda）供各位爱折腾的高端玩家。2019-06-17 update: 清华恢复了conda 的镜像了！详情请看下面：Anaconda 镜像即将恢复借花献佛给大家复习一遍如何添加清华的镜像channels: 来源 → 生信媛: 喜大普奔: Anaconda的清华镜像又可以用了\nconda config –add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config –add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config –add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/conda config –add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/2020-06-14 update: 为了分担清华源镜像的压力，最近北京外国语大学也开启了镜像站点，同样是由清华TUNA团队维护的，如果有小伙伴遇到清华源速度很慢的情况的话，可以考虑换成北外的镜像。新闻传送门：https://mirrors.tuna.tsinghua.edu.cn/news/bfsu-mirror/镜像传送门：https://mirrors.bfsu.edu.cn/help/anaconda/2020-08-05 update: 为了方便大家(当然主要是自己偷懒用), 把北外的链接也给写出来, 这样就可以直接复制粘贴了当然两者取其一就可以了, 不用重复添加.另外, 我查看了中科大的镜像https://mirrors.ustc.edu.cn/anaconda, 点击这个地址会直接跳转到清华tuna的镜像站点. 所以目前看起来国内是只有清华和北外两个镜像站点可用了如果有小伙伴知道还有别的镜像可以用的话欢迎在下面留言或者私信我鸭!\nconda config –add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/bioconda/conda config –add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/conda-forge/conda config –add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/free/conda config –add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/main/下面这个我没用过, 但是看起来像是R的频道, 可以添加一下试试看.conda config –add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/r/如果你需要其他的更多的频道,请访问这个地址👉: https://mirrors.bfsu.edu.cn/help/anaconda/ 里面有详细的指导哒\n2020-08-10 update: 在生信技能树的群里由群友@合肥-生信-gzcdo 提供了两个新的conda的国内镜像源\nhttps://mirrors.nju.edu.cn/anaconda/https://mirrors.sjtug.sjtu.edu.cn/anaconda/\n各位朋友也可以试试看这两个镜像呀!~\n显示安装的频道\n conda config –set show_channel_urls yes查看已经添加的channels\nconda config –get channels已添加的channel在哪里查看\nvim ~&#x2F;.condarc利用conda安装生物信息软件安装命令: conda install gatk搜索需要的安装包:提供一个网址,用于事先查找想安装的软件存不存在conda available packages2020-06-14 update: 链接已挂，请选择用下面的conda search命令或者开头提供的更新的网址当然, 也可以用这个命令进行搜索（会稍微慢一点）\n conda search gatk安装完成后，可以用“which 软件名”来查看该软件安装的位置：\n which gatk如需要安装特定的版本:conda install 软件名&#x3D;版本号conda install gatk&#x3D;3.7这时conda会先卸载已安装版本，然后重新安装指定版本。\n查看已安装软件:\nconda list更新指定软件:\nconda update gatk卸载指定软件:\nconda remove gatk退出conda环境退出也很简单，之前我们是. .&#x2F;activate 或者 (. ~&#x2F;miniconda3&#x2F;bin&#x2F;activate)现在退出只要:\n. .&#x2F;deactivate\n或者用conda deactivate就退出当前的环境了\n创建软件的软链接（非必须步骤）跟着命令一路敲到这里的小旁友们估计发现了，现在退出conda环境之后之前安装的软件全都GG了，敲命令没法执行了！怎么办呢！其实只要把安装好的软件软连接到一个处在环境变量里的位置就可以使用了。三步走：\n第一步，创建一个文件夹我一般的习惯是在&#x2F;home目录下创建一个.soft文件夹第二步，将这个文件夹添加到环境变量中export PATH&#x3D;”&#x2F;.soft:$PATH”第三步，软链接ln -s ~&#x2F;miniconda3&#x2F;bin&#x2F;gatk ~&#x2F;.soft这样就可以运行啦如果还是不行建议试试初始化一下bashrc：. .&#x2F;bashrc\n创建conda环境（常用步骤，强烈推荐）之前创建的时候显示的是（base）这是conda的基本环境，有些软件依赖的是python2的版本，当你还是使用你的base的时候你的base里的python会被自动降级，有可能会引发别的软件的报错，所以，可以给一些特别的软件一些特别的关照，比如创建一个单独的环境。在conda环境下，输入conda env list（或者输入conda info –envs也是一样滴）查看当前存在的环境：\nconda env list\n这是我相当常用的一条命令了，建议记一记目前的环境\n目前只有一个base\nconda create -n python2 python&#x3D;2\n-n: 设置新的环境的名字python&#x3D;2 指定新环境的python的版本，非必须参数这里也可以用一个-y参数，可以直接跳过安装的确认过程。conda会创建一个新的python2的环境，并且会很温馨的提示你只要输入conda activate python2就可以启动这个环境了\n新的环境退出环境如上面的截图提到的，只要\nconda deactivate2019-6-28 update: 如何删除和重命名一个已存在的环境\n删除环境删除也很容易的\nconda remove -n myenv –all就可以退出当前环境。掌握了创建和删除我们就可以实现重命名的操作了\n重命名环境实际上conda并没有提供这样的功能，但是可以曲线救国，原理是先克隆一个原来的环境，命名成想要的名字，再把原来的环境删掉即可参考自：conda 创建&#x2F;删除&#x2F;重命名 环境接下来演示把一个原来叫做py2的环境重新命名成python2：\nconda create -n python2 –clone py2conda remove -n py2 –all骚操作：allias简化启动（非必须步骤）image.png\nlinux提供了一个给大家偷懒的命令叫alias，只要在你的.bashrc里设置一下就好了，我添加了一条叫做condaup的命令，这样就可以免去每次敲. &#x2F;miniconda&#x2F;bin&#x2F;dactivate的麻烦，一步搞定技术宅改变世界！image.png报错信息集锦2020-08-06 update: 我最近用conda总是发生一些奇怪的问题, 所以想把报错的信息及解决方式给收集整理一下.\n报错1: 网络错误\nCollecting package metadata (current_repodata.json): failed\nCondaHTTPError: HTTP 000 CONNECTION FAILED for url https://conda.anaconda.org/genomedk/linux-64/current_repodata.jsonElapsed: -\nAn HTTP error occurred when trying to retrieve this URL.HTTP errors are often intermittent, and a simple retry will get you on your way.u’https://conda.anaconda.org/genomedk/linux-64‘一般这种问题就只要重新运行一下上一条命令就可以了. 有的时候网络不稳定而已.\n","categories":["Anaconda"],"tags":["Anaconda_网络线路"]},{"title":"Conda 环境导入","url":"/2013/07/13/conda/conda%20%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%85%A53/","content":"虚拟环境配置统一虚拟环境，适用于python等高级语言环境隔离做人工智能，深度挖掘时会用到dokcer 里嵌套安装conda2、更新包管理镜像源：\nconda config –add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config –set show_channel_urls yes\n3、更新所有包：conda update –all\n4、安装包：conda install xxx，更新包：conda update xxx，删除包：conda remove，已安装包列表：conda list\n5、创建环境：conda create -n env_name list of packages，list of packages 是要安装在环境中的包的列表\n6、创建特定版本python的环境：conda create -n py3 python&#x3D;3 或 conda create -n py2 python&#x3D;2 或 conda create -n py33 python&#x3D;3.3conda create –prefix&#x3D;”D:\\my_python\\envs\\my_py_env”  python&#x3D;3.6.3\n7、进入环境：activate my_env，离开deactivate\n8、删除环境：conda env remove -n env_name\n9、列出环境：conda env list\n10、导出环境：conda env export &gt; environment.yaml，通过环境文件创建环境：conda env create -f environment.yaml\n","categories":["Anaconda"],"tags":["Anaconda_环境导入"]},{"title":"Conda 环境导入","url":"/2013/07/13/conda/conda%E5%90%AF%E5%8A%A8%E6%8F%92%E4%BB%B6%E5%91%BD%E4%BB%A4/","content":"redis 启动redis-server.exe\n绑定端口号redis-cli.exe -h 127.0.0.1 -p 6379\n","categories":["Anaconda"],"tags":["Anaconda_环境导入"]},{"title":"Conda 环境导入","url":"/2013/07/13/conda/conda%E5%BF%85%E8%A6%81%E6%93%8D%E4%BD%9C/","content":"进入虚拟环境 source activate env_name \n安装命令: conda install pytest搜索 conda search pytest安装完成后，可以用“which 软件名”来查看该软件安装的位置： which gatk如需要安装特定的版本:conda install 软件名&#x3D;版本号conda install gatk&#x3D;3.7\n查看已安装软件:conda list\n更新指定软件:conda update gatk\n卸载指定软件:conda remove gatk\n退出conda环境. .&#x2F;deactivate\n或者用conda deactivate\n重命名环境conda create -n python2 –clone py2conda remove -n py2 –all\n","categories":["Anaconda"],"tags":["Anaconda_环境导入"]},{"title":"Conda 环境导入","url":"/2013/07/13/conda/requirements.txt%20%20%E7%8E%AF%E5%A2%83%E8%8E%B7%E5%8F%96%EF%BC%88%E5%AF%BC%E5%87%BA%EF%BC%89/","content":"导出 \npip freeze &gt; requirements.txt\n\n导入 \npip install -r requirements.txt\n","categories":["Anaconda"],"tags":["Anaconda_环境导入"]},{"title":"Docker 创建","url":"/2013/07/13/dokcer/docker%20%E5%88%9B%E5%BB%BA/","content":"docker run -itd –name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;1548324254 mysql&#x2F;mysql-server\ndocker run -p 3306:3306 –name mysql ^-v &#x2F;d&#x2F;mysql&#x2F;docker-mysql&#x2F;conf:&#x2F;etc&#x2F;mysql ^-v &#x2F;d&#x2F;mysql&#x2F;docker-mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql ^-v &#x2F;d&#x2F;mysql&#x2F;docker-mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql ^-e MYSQL_ROOT_PASSWORD&#x3D;1548324254 ^-d mysql&#x2F;mysql-server\n\n拉取镜像docker pull mysql:5.7创建容器并映射路径docker run -p 3306:3306 –name mysql ^-v &#x2F;e&#x2F;mysql&#x2F;docker-mysql&#x2F;conf:&#x2F;etc&#x2F;mysql ^-v &#x2F;e&#x2F;mysql&#x2F;docker-mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql ^-v &#x2F;e&#x2F;mysql&#x2F;docker-mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql ^-e MYSQL_ROOT_PASSWORD&#x3D;123456 ^-d mysql:5.7\n^为win cmd 中的换行符   -v宿主机路径：mysql路径&#x2F;e&#x2F;mysql&#x2F;docker-mysql&#x2F;conf 路径代表win中 E:\\mysql\\docker-mysql\\confMYSQL_ROOT_PASSWORD&#x3D;123456  代表root密码\nlinux中路径映射为：\nsudo docker run -p 3306:3306 –name mysql -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:5.7\n进入容器，进入mysql ，修改远程访问权限docker exec -it mysql bash   进入容器mysql -u root -p    进入mysqlGRANT ALL PRIVILEGES ON . TO ‘root‘@’%’ IDENTIFIED BY ‘123456’ WITH GRANT OPTION;flush privileges;   刷新权限exit 退出mysql  exit  退出容器宿主机连接mysql\nDocker常用命令新建容器\ndocker run -d –name 自定义容器名 镜像ID或镜像名展示当前运行的容器\ndocker ps展示所有容器\ndocker ps -a展示所有本地镜像\ndocker images运行容器\ndocker start 容器名或容器ID停止运行容器\ndocker stop 容器名或容器ID删除容器\ndocker rm -f 容器名或容器ID进入容器内容bash\ndocker exec -it 容器名或容器ID bash#退出容器命令:exit查看容器ip\ndocker inspect 容器名或id关闭docker服务\nsystemctl stop docker关闭docker服务\ndocker inspect mycentos3重要  重要  重要在win上别忘了加路径：\n","categories":["docker"],"tags":["docker_创建"]},{"title":"Docker 仓库","url":"/2013/07/13/dokcer/docker%E4%BB%93%E5%BA%93/","content":"本地的镜像推送到DockerHub上，这里的xianhu要和登录时的username一致：[root@xxx ~]# docker push xianhu&#x2F;centos:git    # 成功推送[root@xxx ~]# docker push xxx&#x2F;centos:git    # 失败The push refers to a repository [docker.io&#x2F;xxx&#x2F;centos]unauthorized: authentication required\n以后别人就可以从你的仓库中下载合适的镜像了。\n[root@xxx ~]# docker pull xianhu&#x2F;centos:git\n创建容器之后做更改，之后commit生成镜像，然后push到仓库中。更新Dockerfile。在工作时一般建议这种方式，更简洁明了。\n创建一个用于Flask开发的Python环境，包含Git、Python3、Flask以及其他依赖包等。[root@xxx ~]# docker pull centos[root@xxx ~]# docker run -it centos:latest &#x2F;bin&#x2F;bash\n此时进入容器，安装Python3、Git、Flask及其依赖包等，安装完成后exit退出[root@xxx ~]# docker commit -m “Flask” -a “xianhu” container_id xianhu&#x2F;flask:v1[root@xxx ~]# docker push xianhu&#x2F;flask:v1\n作者：笑虎链接：https://zhuanlan.zhihu.com/p/23599229来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","categories":["docker"],"tags":["docker_仓库"]},{"title":"Docker 创建参数","url":"/2013/07/13/dokcer/docker%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E5%8F%82%E6%95%B0/","content":"端口映射:P :随机映射 p:指定映射-P 创建  端口映射POTRTSp 0.0.0.0：32768——》80/tcp        == 宿主机（Ubuntu）端口-》容器端口\nhost模式：容器和宿主机共享网络直接采用宿主机的网络，不是单独分配--network=host\n","categories":["docker"],"tags":["docker_创建"]},{"title":"Docker 创建","url":"/2013/07/13/dokcer/%E5%88%A9%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/","content":"说明该镜像以哪个镜像为基础FROM centos:latest\n构建者的基本信息MAINTAINER xianhu\n在build这个镜像时执行的操作RUN yum updateRUN yum install -y git\n拷贝本地文件到镜像中COPY .&#x2F;* &#x2F;usr&#x2F;share&#x2F;gitdir&#x2F;\n有了Dockerfile之后，就可以利用build命令构建镜像了：\n[root@xxx ~]# docker build -t&#x3D;”xianhu&#x2F;centos:gitdir” .\n上就是构建自己镜像的两种方法。其中也涉及到了容器的一些操作。如果想删除容器或者镜像，可以使用rm命令，注意：删除镜像前必须先删除以此镜像为基础的容器。[root@xxx ~]# docker rm container_name&#x2F;container_id[root@xxx ~]# docker rmi image_name&#x2F;image_id\n[root@xxx ~]# docker save -o centos.tar xianhu&#x2F;centos:git    # 保存镜像, -o也可以是–output[root@xxx ~]# docker load -i centos.tar    # 加载镜像, -i也可以是–input\n","categories":["docker"],"tags":["docker_创建"]},{"title":"Docker 指令","url":"/2013/07/13/dokcer/%E5%91%BD%E4%BB%A4/","content":"[root@xxx ~]# docker search centos    # 查看centos镜像是否存在[root@xxx ~]# docker pull centos    # 利用pull命令获取镜像\ndocker images    # 查看当前系统中的images信息\ndocker run -it centos:latest &#x2F;bin&#x2F;bash # 启动一个容器git –version    # 此时的容器中没有gitbash: git: command not found\nyum install git    # 利用yum安装git\n#运行容器docker run -itd –name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 mysql\ngit –version   # 此时的容器中已经装有git了git version 1.8.3.1\ndocker ps -a\n这里将容器转化为一个镜像，即执行commit操作，完成后可使用docker images查看docker commit -m “centos with git” -a “qixianhu” 72f1a8a0e394 xianhu&#x2F;centos:git\n","categories":["docker"],"tags":["docker_指令"]},{"title":"Docker 指令","url":"/2013/07/13/dokcer/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"启动[root@xxx ~]# docker run -it centos:latest &#x2F;bin&#x2F;bash这里-it是两个参数：-i和-t。前者表示打开并保持stdout，后者表示分配一个终端（pseudo-tty）。此时如果使用exit退出，则容器的状态处于Exit，而不是后台运行。如果想让容器一直运行，而不是停止，可以使用快捷键 ctrl+p ctrl+q 退出，此时容器的状态为Up。除了这两个参数之外，run命令还有很多其他参数。其中比较有用的是-d后台运行：[root@xxx ~]# docker run centos:latest &#x2F;bin&#x2F;bash -c “while true; do echo hello; sleep 1; done”[root@xxx ~]# docker run -d centos:latest &#x2F;bin&#x2F;bash -c “while true; do echo hello; sleep 1; done”\n启动、停止、重启容器命令：[root@xxx ~]# docker start container_name&#x2F;container_id[root@xxx ~]# docker stop container_name&#x2F;container_id[root@xxx ~]# docker restart container_name&#x2F;container_id\n后台启动一个容器后，如果想进入到这个容器，可以使用attach命令：[root@xxx ~]# docker attach container_name&#x2F;container_id\n删除：[root@xxx ~]# docker rm container_name&#x2F;container_id\n","categories":["docker"],"tags":["docker_指令"]},{"title":"Docker 炼丹机器学习","url":"/2013/07/13/dokcer/%E7%82%BC%E4%B8%B9%E6%9C%AF%E5%A3%AB/","content":"一般炼丹都在服务器上，很少有人在本机跑代码的。之前自己捣鼓怎么用本地的编辑器配上远程服务器的环境来营造一个最舒乎的姿势。最开始用VS Code的SFTP插件，但是用着还是不顺手，因为不能用远程的环境，最后还是选择了强大的PyCharm。下面的这个教程最开始只是自己用，后来写了一篇博客分享给实验室的人，没想到大家都开始用上了。这次专门写一篇更详细的放到知乎供有缘人使用。开始之前你可以对比以下条件来确定自己是否真的需要这样做：使用PyCharm作为主力IDE写Python而不是其他（我非常推荐大家用）深度学习炼丹师（当然你可以不是，但如果是，你会更舒服）服务器在远程或者局域网（局域网的体验最佳）使用Docker（能够熟练使用最佳）当你配置完成之后，你将能在本地PyCharm IDE上使用远程服务器的Python解释器和环境进行调试和运行，同时能够很方便的将代码在本地和服务器上进行同步。OK，废话不多说，正式开始我们的PyCharm+Docker的远程环境配置之旅。首先你需要满足以下两个必备条件：使用PyCharm专业版，记住一定是专业版（社区版不提供远程服务）在服务器上安装docker和nvidia-docker1. 新建docker container首先按照如下命令新建一个docker容器（关于docker的使用这里不废话，建议不熟悉的童鞋先去学一下如何使用docker，教程很多）：sudo nvidia-docker run -it -p [host_port]:[container_port](do not use 8888) –name:[container_name] [image_name] -v [container_path]:[host_path] &#x2F;bin&#x2F;bash举个栗子：sudo nvidia-docker run -p 5592:5592 -p 5593:5593 -p 8022:22 –name&#x3D;”liuzhen_tf” -v ~&#x2F;workspace&#x2F;liuzhen&#x2F;remote_workspace:&#x2F;workspace&#x2F;liuzhen&#x2F;remote_workspace -it tensorflow&#x2F;tensorflow:latest-gpu &#x2F;bin&#x2F;bash正确执行完之后，现在我们就处在新建的docker容器里了（端口映射，容器名，镜像和路径映射这些换成你自己的就行，但是一定要留一个端口映射到容器22端口，因为SFTP默认使用22端口）。2. 配置SSH服务接着我们在刚刚新建的容器里配置SSH服务，首先安装openssh-server:$ apt update$ apt install -y openssh-server然后建立一个配置文件夹并进行必要的配置：$ mkdir &#x2F;var&#x2F;run&#x2F;sshd$ echo ‘root:passwd’ | chpasswd\n这里使用你自己想设置的用户名和密码，但是一定要记住！$ sed -i ‘s&#x2F;PermitRootLogin prohibit-password&#x2F;PermitRootLogin yes&#x2F;‘ &#x2F;etc&#x2F;ssh&#x2F;sshd_config$ sed ‘s@session\\srequired\\spam_loginuid.so@session optional pam_loginuid.so@g’ -i &#x2F;etc&#x2F;pam.d&#x2F;sshd$ echo “export VISIBLE&#x3D;now” &gt;&gt; &#x2F;etc&#x2F;profile重启SSH激活配置：$ service ssh restart在服务器（宿主机）上（不是服务器的docker里）测试刚刚新建docker容器中哪个端口转发到了服务器的22端口：$ sudo docker port [your_container_name] 22\n如果前面的配置生效了，你会看到如下输出0.0.0.0:8022最后测试能否用SSH连接到远程docker：$ ssh root@[your_host_ip] -p 8022密码是你前面自己设置的到这里说明服务器的docker端已经完成配置。3. 在PyCharm里配置部署环境打开PyCharmTools &gt; Deployment &gt; Configuration, 新建一个SFTP服务器，名字自己取：输入如下图配置，注意这里的端口是你刚刚设置的映射到容器22端口的宿主机中的端口，我这里使用的是8022，账号密码是你刚刚自己设置的，这里的Root Path设置一个远程docker容器里的路径:配置完点击Test SFTP connection,如果成功就恭喜你，可以进行下一步了。最后在Mappings中配置路径，这里的路径是你本地存放代码的路径，与刚刚配置的Root Path相互映射（意思是Mapping里本机的路径映射到远程的Root Path），方便以后在本地和远程docker中进行代码和其他文件同步。4. 在PyCharm里配置远程解释器点击PyCharm的File &gt; Setting &gt; Project &gt; Project Interpreter右边的设置按钮新建一个项目的远程解释器：配置完成以后在项目解释器界面就会出现如下图所示，可以看到此时已经完成远程解释器的本地化：配置完成以后需要等本地和远程的环境同步一下，到这里，恭喜你，可以用最舒服的姿势。。。写代码了。配置完成以后的日常是这样的：左边是本地的文件，修改之后可以随时右键deployment-&gt;upload到远程主机，或者直接在本地调试运行；最右边是远程主机的文件，假如直接在远程修改了文件刷新一下同样可以右键下载到本地，但是我不建议这样做，因为这样很容易带来冲突（毕竟没有很好的版本控制）。目前最好的实践是在局域网的服务器上，时延低，同步速度快。常见问题：最常见的问题就是docker容器停了以后里面的SSH服务也会相应停止，因此当你发现自己某一天连不上的时候，记得去docker里重启一下ssh服务：$ service ssh restart感谢 @丁果 对这个问题提出的解决方案：“可以在run的时候加上–restart&#x3D;always，同时ssh启动的写到dockerfile里去。”2. 在容器中执行apt update的时候可能会出现0% working 的问题","categories":["docker机器学习"],"tags":["docker 炼丹机器学习"]},{"url":"/2025/09/11/javaScipt/JavaScript/","content":"8.1JS获取标签元素，操作标签属性（css属性,标签属性，内容）alert() (执行相应的操作并且弹出对话框)\nvar定义的变量会向前申明（提前申明）\n8.2条件语句if\n比较运算符&#x3D;&#x3D;\t&#x3D;&#x3D;&#x3D;\t!&#x3D;\t&gt;\t&lt;\t&gt;&#x3D;\t&lt;&#x3D;注意：&#x3D;&#x3D;&#x3D; 判断值与类型如果x&#x3D;5   判断x&#x3D;&#x3D;&#x3D;5为ture ，x&#x3D;&#x3D;&#x3D;”5”为false\n逻辑运算符:&amp;&amp; and\t||\tor\t!\tnot\n8.3获取标签元素内置对象document的方法getElementByld\nvar oDiv=document.getElementById(&quot;div1&quot;)alert(oDiv)&lt;/script&gt;&lt;div id=&quot;div1&quot;&gt;this is div&lt;/div&gt;\n\n8.4改属性&#x2F;&#x2F;js获取标签入口代码（必须写在匿名函数中  ）html:class–&gt;js:className   html:font-size—&gt;js:对象.style.fontSize\nwindow.onload(页面内容加载后立即执行此函数)=function（）（没有函数名，只作用于这一次）&#123;\tvar oInput = document.getElementById(&quot;input1&quot;);\tvar oA = document.getElementById(&quot;link01&quot;);//获取标签\talert(oInput.value);\talert(oInput.name);\talert(oA.className); //设置标签属性:对象名.属性名//a的属性class ,通过对象访问时，使用名字classNameoA.className = &quot;sty02&quot;;（格式记住时对象.属性名=“新的css属性名&quot;）oA.style.fontSize = &quot;50px&quot;;&#125;\n\n8.5读取或者改标签包裹的内容对象.innerHTML\nwindow.onload = function()&#123;\tvar oDiv = document.getElementById(&quot;div1&quot;);\talert(oDiv.innnerHTML);\toDiv.innerHTML  =&quot;&lt;ul&gt;&lt;/ul&gt;&quot;&#125;\n8.6数组创建：实例化对象创建\nvar  alist = new Array(1,2,3); \n字面量方式创建\nvar alist2=[1,2,3,&#x27;abc&#x27;];\n多维数组\nvar alist = [[1,2,3],[&#x27;a&#x27;,&#x27;b&#x27;]];\n数组的操作\n var alist = [1,2,3,4];alert(alist.length);数组的尾部添加与尾部提取var alist = [1,2,3,4];//尾部添加一个5alist.push(5)//弹出1，2，3，4，5alert(alist);//尾部提取alist.pop();//弹出1，2，3，4alert(alist);\n\n\n根据下标添加和删除元素arr.splice(start,num,element1,….,elementN)参数解析start ：必需，开始删除的索引num：可选，删除数组元素的个数elementN：可选，start索引位置要插入的新元素.删除\nvar colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];colors.splice(0,1)alert(colors);//green,blue添加colors.splice(1,0,&quot;yellow&quot;,&quot;orange&quot;);alert(colors);//green,yellow,organge,blue删除添加colors.splice(1,1,&quot;red&quot;,&quot;purple&quot;);alert(colors)//green,red,purple,orange,blue\n\n\n8.7循环语句for循环\t\twhile循环 \tdo-while循环\nvar array = [1,4,5];for循环for(var index = 0; index&lt;array.length;index++)&#123;\tvar result = array[index];\talert(result);&#125;\nwhile循环var index = 0;while(index&lt;arrray.length)&#123;\tvar result = array[index];\tconsole.log(访问内容。跟aler弹框不同，这是用来调试用的,看代码需要进入页面的Console页面)(alist[index]);\tindex++;&#125;\ndo while循环var index = 0;do&#123;\tvar result = array[index];\talert(result);\tindex++;&#125;while(index&lt;array.length);\n8.8字符串拼接”+”\n var i=100;var i2=200;var i3=&quot;123&quot;alert(i+i2);//300alert(i2+i3);//200123\n8.9定时器在一段特定的时间后执行某段代码创建方式2种：1.setTimeout(func[,delay,param1,param2,…]):以指定的时间间隔（以毫米计算）调用一次函数的定时器\n2.settlnterval(func[,delay,param1,param2,…]):以指定的时间间隔（毫米）重复调用一个函数的计时器\n&lt;s&gt;\tfunction hello()&#123;\t\talert(&#x27;hello&#x27;);&#125;\tsetInterval(hell,1000);(每隔一秒调用函数一次，1000毫秒=1秒);&lt;/s&gt;\n清除定时器2种\n清除只执行一次的定时器clearTimeout(timeoutID)\n清除反复调用的定时器clearInterval(timeoutID)\n&lt;s&gt;\tfunction hello()&#123;\t\talert(&#x27;hello&#x27;);\t\tclearTimeout(t1)&#125;\tt1=setTimeout(hello,500)&lt;/s&gt;\n\n8.10链接\n\n\n$()是jQuery库中实现的函数，把你写的js对象（函数），转换成jQ自定义的对象（jq函数里面做了window.onload的工作，页面加载完成事件）优化：（使用jQ入口写法更快，比window.onload快）\n写法：\n$(function()&#123;\tvar\t$div = $(&quot;#div1&quot;);\talert(&quot;jquery:&quot; +$div);&#125;);\n\n\n8.11属性选择器\n$(&quot;input[name=username]&quot;)\n\n8.12选择器转移\n&lt;script&gt;\t$(function()&#123;\tvar $div =$(&#x27;#div01&#x27;)\t$(&#x27;#div&#x27;).prev();//表示选择的上一级\t//$div.prev().css(&#123;&quot;color&quot;:&quot;red&quot;&#125;);($元素.关键字.css(&#123;&quot;color&quot;:&quot;red&quot;&#125;))\t$(&quot;#div&quot;).prevAll() ;//选择的元素上面的所有同级元素\t//$div.prevAll().css(&#123;&quot;color&quot;:&quot;blue&quot;&#125;);\t$(&quot;#div&quot;).next() ;//下一个同级元素\t//$div.next().css(&#123;&quot;color&quot;:&quot;red&quot;&#125;);\t$(&quot;#div&quot;).next()；//选择的元素下面的所有同级元素\t$(&quot;#div&quot;).parent();//表示选择的元素的父元素\t$(&quot;#div&quot;).children();//选择的元素的所有子元素\t$(&quot;#div&quot;).siblings();//选择的元素的其他同级元素\t$(&quot;#div&quot;).find(&#x27;.myClass&#x27;);//选择的id是box元素的class=myClass的元素&#125;)\t&lt;/script&gt;&lt;div&gt;\t&lt;h2&gt;这是第一个h2标签&lt;h2&gt;\t&lt;p&gt;这是第一个段落&lt;/p&gt;\t&lt;div id=&quot;div01&quot;&gt;这是一个&lt;span&gt;div&lt;/span&gt;&lt;span class=&quot;sp02&quot;&gt;第二个span&lt;/span&gt;&lt;/div&gt;\t&lt;h2&gt;这是第二个h2标签&lt;/h2&gt;\t&lt;p&gt;这是第二个段落&lt;/p&gt;&lt;/div&gt;\n\n8.13jq获取和设置标签内容‘’’\n\n\t$(function(){\n\t\tvar $div = $(\"#div1\");\n\t\t//获取标签内容\n\t\tconsole.log($div.html())\n\t\t//设置标签内容：删除原理内容\n\t\t$div.html(\"hello world\");\n\t\t\n\t\t//追加标签内容\n\t\t$div.append(\"hi\")\n\t\n})\n\n\n\n\t\n\t\thello\n\t\n\n\n\n8.14prop获取属性值和设置属性值与对象.css不同的是.css直接改css,prop直接改标签符的属性prop 方法:获取元素属性：对象.prop（“标签属性名”）设置元素属性：对象.prop（“标签属性名”：“属性值”,…）\nval方法：获取元素属性：对象.val()设置元素属性：对象.val(“value值”)\ncss方法：获取样式属性:对象.css(“样式属性名”)设置样式属性：对象.css({“样式属性名”：“属性值”})\n8.15常见事件：click():点击事件blur():失去焦点focus():获取焦点mouseover():鼠标进入mouseout():鼠标离开ready():页面加载完成\n8.16事件代理原理：利用底层原理（冒泡原理）：事件会向它的父级一层一层传递把事件加到父级上，通过判断事件的来源，执行相应的子元素的操作\n作用：事件代理可以减少绑定，提高性能，让新子元素共享操作\n$(cuntion()&#123;\t$list = $(&#x27;#list&#x27;);\t$list.delegate(&#x27;li&#x27;,&#x27;click&#x27;,function()&#123;\t\t$(this).css(&#123;background:&#x27;red&#x27;&#125;)\t&#125;)&#125;)&lt;ul id=&quot;list&quot;&gt;\t&lt;li&gt;1&lt;/li&gt;&lt;/ul&gt;\n\n8.17jsonjson类似于js对象的字符串，是一种数据格式json有两种格式1.对象格式 2.数组格式json转换js对象：\nvar sjson = &#x27;&#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:10&#125;&#x27;;var oPerson = JSON.parse(sjon);alert(oPerson.name)alert(operson.age)\n\n8.18ajax前后台通讯获取数据的jQuery方法特点：异步（多线程），局部刷新（优化）\n&lt;script&gt;\t$(function()&#123;\t\t$.get(&quot;http://t.weather.sojson.com/api/weather/city/101010100&quot;,\t\tfunction(data,status)&#123;\t\t\tconsole.log(data);\t\t\tconsole.log(status);\t\t\talest(dat);\t\t\t&#125;).error(function()&#123;\t\t\t\talert(&#x27;网络异常&#x27;);\t\t\t&#125;);\t&#125;);\t$.post(&quot;test.php&quot;,&#123;&quot;func&quot;:&quot;getNameAndTime&quot;&#125;,function(data)&#123;\t\talert(data.name);\t\tconsole.log(data.time);\t\t\t&#125;,&quot;json&quot;).error(function()&#123;\t\talert(&quot;网络异常&quot;);\t&#125;)&lt;/script&gt;\n\n$.get和$.post方法的参数说明:\n$.get(url,data,success(data, status, xhr),dataType).error(func)$.post(url,data,success(data, status, xhr),dataType).error(func)\nurl 请求地址data 设置发送给服务器的数据，没有参数不需要设置success 设置请求成功后的回调函数data 请求的结果数据status 请求的状态信息, 比如: “success”xhr 底层发送http请求XMLHttpRequest对象dataType 设置返回的数据格式“xml”“html”“text”“json”error 表示错误异常处理func 错误异常回调函数\n概括：js获取标签与操作\nwindow.onload &#x3D; function(){…}var oDiv &#x3D;document.getElementbyId(“div1”);\n****js调用js：\ndocument.write(&quot;&lt;script language=javascript src=&#x27;/js/import.js&#x27;&gt;&lt;/script&gt;&quot;);document.write(&quot;&lt;script language=jQuery src=&quot;js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;&quot;)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2025/09/11/javaScipt/miniweb%E6%A1%86%E6%9E%B6/","content":"了解：静态资源:可以提前准备的，不经常发生变化的资源动态资源：不饿能提前准备经常发生变化的资源web框架：为web服务器提供动态资源的程序WSGI协议：web服务器和web框架之间进行协同工作的一个规则\n"},{"url":"/2025/09/11/flask/Flask%E5%9F%BA%E7%A1%80/","content":"App 等于整个项目\nflask 的request 的是从包导入，是全局变量。怎么区分？原理：线程控制，通过线程id来区分\nrequest.remote_userrequest.remote_addr\nrequest获取方法# 类型声明mydict = None  # type:dict# mydict.update()# mydict.get()@app.route(&#x27;/user&#x27;, methods=[&quot;get&quot;, &quot;post&quot;])def hello_world():    # ==========[request基础属性]=============    # 请求url地址    # print(request.url)    # 发送请求的用户和ip    # print(request.remote_user)    # print(request.remote_addr)    # 请求的方法    # 大写的字符串    # print(request.method)    # 请求头信息-字典    # print(request.headers)    # print(request.headers[&quot;Host&quot;])    # print(request.headers.get(&quot;Host&quot;, &quot;默认值&quot;))    # ==============[request获取请求参数]====================    # 1.提取路径参数    # 127.0.0.1:5000/user_id/666    # 语法: &lt;转换器名称:变量名称&gt;    # 2.提取查询字符串参数    # 127.0.0.1:5000/user/?name=xiaoming&amp;age=18   [get]    # 语法：request.args  类型：字典    # params_dict = request.args    # print(params_dict.get(&quot;name&quot;))    # print(params_dict.get(&quot;age&quot;))    # 3.提取请求体参数    # 127.0.0.1:5000/user  请求体字典：&#123;&quot;name&quot;: &quot;james&quot;, &quot;age&quot;: 35&#125;  [post]    # 语法：request.form    # params_dict = request.form    # print(params_dict.get(&quot;name&quot;))    # print(params_dict.get(&quot;age&quot;))    # 4.原始bytes类型参数 [了解]    # 语法：request.data    # print(request.data)    # 5.提取json字符串参数    # 127.0.0.1:5000/user/   请求体json字符串：&#123;&quot;name&quot;: &quot;kobe&quot;, &quot;age&quot;: 43&#125;    # 语法：request.json    # 底层已经将json字符串转换成字典    # params_dict = request.json    # print(params_dict.get(&quot;name&quot;))    # print(params_dict.get(&quot;age&quot;))    # 6.提取文件类型的参数    # 127.0.0.1:5000/user/   &#123;&quot;img&quot;: &quot;文件数据&quot;&#125;    # 语法：request.files    file = request.files.get(&quot;img&quot;)  # type:FileStorage    # 读取二进制文件数据    # 注意：一旦读取完毕 数据被清空了    # print(file.read())    # 保存图片到本地    # TODO: 图片存储到云平台    file.save(&quot;./2.png&quot;)    return &#x27;Hello World!&#x27;@app.route(&#x27;/index&#x27;)def index():    return &#x27;index page&#x27;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n导包# 1.导包\tfrom flask import Flask  # 2.创建flask应用对象app\tapp = Flask(__name__)  # 3.自定义视图函数绑定路由信息\t@app.route(&#x27;/&#x27;)\tdef index():    \treturn &#x27;Hello World&#x27; # 4.运行flask应用程序\t\t app.run()  # 查看路由信息属性：app.url_map\n3.flask 初始化参数1. __name__（重点必传）认为当前文件所有在目录就是项目目录，会在这个目录下寻找静态文件路径（图片，js,css），模板文件路径(html)2. static_ul_path静态文件访问路径前缀，，默认为：/static/文件名称3. static_folder(可以不传,知道作用就好):静态文件存储的文件夹，，默认为 static4.template_folder模板文件存储的文件夹，可以不传，默认为 templates\n1-app.run()的参数&amp;配置信息读取# Flask旧版本的运行方式\t通过修改app.run()函数的host，port参数，指定运行的ip地址和端口号。# 读取配置信息\tapp.config.get(key)app.config(&quot;key&quot;)\n2-Flask新版本(1.x)运行方案–终端运行\n总结：#0.代码中可以省略：app.run() 这行代码#1.使用环境变量的形式指明那个文件需要被运行export FLASK_APP=flask文件名称 #3.设置运行模式：(非必须,可以不指明，默认是production生产模块）export FLASK_ENV=production  运行在生产模式，未指明则默认为此方式export FLASK_ENV=development 运行在开发模式 默认开启debug模式#2.使用命令启动：默认运行在127.0.0.1:5000端口flask run   #2.1指明ip和端口flask run -h 0.0.0.0 -p 8000# 注意：FLASK_APP  FLASK_ENV  production development 固定写法 不能出错\n\n3.路由# 总结：(重点)1.修改@app.route(&#x27;路由地址&#x27;, methods=[&#x27;post&#x27;, &#x27;get&#x27;])的参数达到修改访问url：\t目的：不同的url引导到对应的视图函数1.1 查询路由和视图函数的绑定关系\t app.url_map 2.转换器：\t作用：提取路由url`路径`上面的参数\t语法：&lt;参数类型:形参&gt;注意：参数类型`暂时`理解成对应类型\n4-指定请求方式&amp;使用 PostMan 对请求进行测试# 总结：修改请求方式：\t我们可以根据需求修改对应的请求方式，完成不同的业务需求语法：app.route(路径,methods=[&quot;POST&quot;,&quot;GET&quot;])注意：methods是一个列表。请求方法大小写均可。\n6.返回JSON格式数据[重点]总结：当需要给客户端返回json类型的数据的时候，可以借助jsonify函数将python字典转换成json字符串语法格式：\tjsonify(字典)作用：\t1.将字典转换成json字符串\t2.将返回值包装成resonse对象\t3.将·数据类型·设置成application/json格式\n\n\n\n7-重定向# 总结：\t概念：当你访问某一url路由的时候，不是给你引导到当前url对应的网页而是跳转到了另一个url对应的网页。\t# 重定向函数：redirect(url地址)url_for(视图函数名称)\n\n\n\n8-自定义响应信息resp =make_response(响应体)resp.headers[key] = valueresp.set_cookie()resp.status_code = 200\n\n\n\n9-状态保持-cookie# 设置响应头的set_cookie字段  value必须是str/bytes类型\tresponse.set_cookie(&#x27;per_page&#x27;, &#x27;10&#x27;, max_age=86400)  # 本质是将max_age=0response.delete_cookie(&#x27;per_page&#x27;)# 直接获取到字典形式的cookie数据\trequest.cookies.get(&#x27;per_page&#x27;)\n\n\n\n10 状态保持 sessionfrom flask import sessionsession 本质不是全局变量，线程隔离，线程id区分# 注意：flask中使用session需要设置加密混淆字符串# 盐app.secret_key = &quot;saldhjhaldk(*i&quot;# 给flask中的session设置有效时长 [1天]# flask默认是：31天过期app.permanent_session_lifetime = timedelta(days=1)session[&quot;user_name&quot;] = &quot;laowang&quot;# 运行设置有效时长session.permanent = True# 删除session# session.pop(key) 删除一条# session.clear() 删除全部\n11-JWT12-异常处理abort(http错误状态码)# 捕获http错误@app.errorhandler(404)# 还可以捕获系统内置错误@app.errorhandler(ZeroDivisionError)\n\n\n\n\n\n请求钩子[重点]总结：1.当访问一路由：127.0.0.1：5000/  浏览器会发送一个请求给flask后端： request 2.当请求发送过来的时候有四个时机：\t1.第一次请求之前 before_first_request\t2.每次请求之前 before_request\t3.每次请求之后 after_request\t4.每次请求之后是否有错误 teardown_request\t@app.before_request     执行时机：每一次请求之前触发，视图函数执行之前触发    作用：拦截请求，封ip，token用户权限认证@app.before_first_request    执行时机：项目第一次启动就会触发，而且仅会执行一次    作用：项目初始化工作@app.after_request    执行时机：每次在视图函数执行完毕的时候触发[没有错误]，要接受一个响应对象    作用：拦截响应，设置cookie，设置响应状态码 响应头信息    @app.teardown_request    执行时机：每次在视图函数执行完毕后触发[无论是否有错误], 接受一个异常对象    作用：异常处理，收尾工作\n数据库配置：1. 用工厂方法在app下的__init__.py下创建链接\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2025/09/11/flask/Flask%E5%9F%BA%E7%A1%802/","content":"列表提取与元组提取注意点：如果是底层配置需求（有错需要警告的话）就用方法[‘’]提取，空就会报错如果是无关大雅的外层需求，可以用get.(‘’)来提取，空也不会报错\n蓝图（注意避免循环导包）from flask import Blueprint, url_for# 1.创建蓝图对象home_bp = Blueprint(&quot;hone&quot;, __name__, url_prefix = &#x27;/home&#x27;)# 在蓝图中使用钩子函数[作用域：整个home模块]@home_bp.before_requestdef process_request():\tprint (&quot;before_request调用了&quot;)from .views import *\n\n\n\n上下文(数据容器)1.请求上下文:request, sessiondef hello_world():    # =======[请求上下文]==========    print(request.url)    session[&quot;username&quot;] = &quot;xiaoming&quot;    print(session.get(&quot;username&quot;))2.应用上下文:current_app    # ========[应用上下文]============    # current_app == app 当前运行的app    # 别的模块不方便导入app，够不着app的时候可以current_app    print(app.config.get(&quot;JSON_AS_ASCII&quot;))    print(app.config.get(&quot;SECRET_KEY&quot;))    print(current_app.config.get(&quot;JSON_AS_ASCII&quot;))    print(current_app.config.get(&quot;SECRET_KEY&quot;))理解：1.上下文不是全局变量，web是并发调用，全局变量是线程共享2.上下文是线程隔离（LocalStack类型, 本质是字典）# 问题在Flask程序未运行的情况下，调试代码时需要使用current_app、g、request这些对象，会不会有问题？该如何使用？# 解决方案\t \t手动开启应用上下文 【重点】     with app.app_context():            current_app            手动开启请求上下文    with app.request_context(environ):      # 模拟解析客户端请求之后的wsgi字典数据    environ = &#123;&#x27;wsgi.version&#x27;:(1,0), &#x27;wsgi.input&#x27;: &#x27;&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;, &#x27;PATH_INFO&#x27;: &#x27;/&#x27;, &#x27;SERVER_NAME&#x27;: &#x27;itcast server&#x27;, &#x27;wsgi.url_scheme&#x27;: &#x27;http&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;&#125; \n\n\n\ng对象与请求钩子的综合案例# 需求：构建用户身份认证机制# 1.每次进入视图函数之前对用户身份进行认证(jwt session cookie)，将用户信息保存到g对象中，方便在别的函数使用用户信息# 2.对于特定视图可以提供强制要求用户登录的限制# 分析    每次进入视图函数之前对用户身份进行认证，并保存用户信息 --&gt; 钩子函数    提供强制要求用户登录的限制 ---&gt; 装饰器   # 数据如何传递？\tg对象# 执行流程：发送请求 --&gt; 钩子函数(登录使用g变量保存用户信息，没有登录g变量保存None) --&gt; 视图函数发送请求 --&gt; 钩子函数 --&gt; 装饰器  --&gt; 视图函数 --&gt; 获取用户信息\n\n\ng对象与请求钩子\nfrom flask import Flask, session, g, requestimport functoolsapp = Flask(__name__)app.secret_key = &quot;alksdjalkdjlkas***&quot;# 需求：限制视图函数的访问权限# eg: 个人中心，评论，点赞接口必须先登录，才能访问视图函数# 方案：在钩子函数中统一提取用户信息，并且使用g变量存储，再将用户是否登录的业务逻辑代码封装到装饰器中[减少代码冗余]@app.before_requestdef get_userinfo():    # 注意：必须用get获取字典的键值对信息    g.user_id = session.get(&quot;user_id&quot;)    g.user_name = session.get(&quot;user_name&quot;)    # TODO:    # token = request.headers.get(&quot;token&quot;)    # token校验 -- payload -- 用户信息 -- 登录装饰器判断是否登录 -- 视图函数# 主动寻求装饰# app.before_request(get_userinfo)# 登录装饰器def login_required(view_func):    # 防止装饰器修改被装饰函数名和文档信息    @functools.wraps(view_func)    def wrapper(*args, **kwargs):        # 判断用户是否登录        if g.user_id and g.user_name:            # 进入视图函数            return view_func(*args, **kwargs)        else:            # 未登录            return &quot;invliad user&quot;, 401    return wrapper@app.route(&#x27;/login&#x27;)def login():    # 状态保持    session[&quot;user_id&quot;] = 66    session[&quot;user_name&quot;] = &quot;james&quot;    return &#x27;login success&#x27;@app.route(&#x27;/index&#x27;)def index():    # 提取用户信息    if g.user_id and g.user_name:        return &quot;欢迎回来：&#123;&#125; &quot;.format(g.user_name)    else:        return &#x27;&lt;a href=&quot;/login&quot;&gt;去登录&lt;/a&gt;&#x27;# 注意：装饰顺序 先构建请求，再判断是否有登录@app.route(&#x27;/profile&#x27;)@login_requireddef profile():    # 判断用户是否有登录    print(g.user_name)    return &quot;profile page&quot;@app.route(&#x27;/comment&#x27;)@login_requireddef comment():    # 判断用户是否有登录    print(g.user_name)    return &quot;profile page&quot;if __name__ == &#x27;__main__&#x27;:    app.run(debug=True, port=8000)\n工厂方法# 需求：将app创建封装到工厂方法中def create_app(config_name):    # 1.创建app    app = Flask(__name__)    # 2.读取配置类中的配置信息    config_class = config_dict[config_name]    app.config.from_object(config_class)    # 3.读取环境变量中私有配置信息    # 后加载的同名配置信息会覆盖之前的配置信息    app.config.from_envvar(&quot;CONFIG&quot;, silent=True)    # 4.返回app    return app# 开发模式下的app对象app = create_app(&quot;dev&quot;)\n\n配置文件\n# 使用面向对象的方式封装多套配置信息class BaseConfig(object):    &quot;&quot;&quot;    配置类基类    以类属性的方式添加配置信息    &quot;&quot;&quot;    DEBUG = True    SECRET_KEY = &quot;python666&quot;class DevelopmentConfig(BaseConfig):    &quot;&quot;&quot;开发阶段配置信息&quot;&quot;&quot;    DEBUG = True    # redis 配置信息 【自定义】    REDIS_HOST = &quot;127.0.0.1&quot;    REDIS_PORT = 6379class ProductionConfig(BaseConfig):    &quot;&quot;&quot;上线配置信息&quot;&quot;&quot;    # 减少io 减少服务器压力    DEBUG = False    # redis 配置信息 【自定义】    REDIS_HOST = &quot;192.168.1.3&quot;    REDIS_MASTER_PORT = 6379    REDIS_SLAVE_PORT = 6380class TestingConfig(BaseConfig):    &quot;&quot;&quot;测试配置信息&quot;&quot;&quot;    # 提示代码错误    Testing = True    # redis 配置信息    REDIS_HOST = &quot;127.0.0.1&quot;    REDIS_PORT = 6379# 暴露外界调用的接口config_dict = &#123;    &quot;dev&quot;: DevelopmentConfig,    &quot;pro&quot;: ProductionConfig,    &quot;test&quot;: TestingConfig&#125;\n\n\n单例设计模式class Singleton(object):    # 对象初始化    # def __init__(self):    #     pass    # cls == Singleton    def __new__(cls, *args, **kwargs):        # 第一次：cls上没有_instance 进入if判断创建对象        # 以后的每一次：cls上有instance 返回的是第一次创建的对象        if not hasattr(cls, &quot;_instance&quot;):            # 第一次类中没有_instance属性 进入if判断，创建对象，保存_instance属性中            # super(Singleton, cls).__new__(*args, **kwargs) 调用父类的__new__创建对象            # 动态属性赋值            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)        return cls._instance\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2025/09/11/flask/flask%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/","content":"1. 蓝图（注意避免循环导包）2. 工厂方法3. 单例设计模式4. 取消ascii（啊斯卡编码）# 在flask_restful中取消中文转换成ascii编码app.config[&quot;RESTFUL_JSON&quot;] = &#123;&quot;ensure_ascii&quot;: False&#125;# 在flask框架中app.config[&quot;JSON_AS_ASCII&quot;] = Flask\n所有装饰器装饰顺序为靠近函数的先执行内容执行顺序从上到下\n工厂模式链接数据库from flask import Flaskfrom settings import config_dictfrom flask_sqlalchemy import SQLAlchemy# 数据库的第二种创建方式：# 创建数据库对象，但是还未关联app对象，不会执行init_app方法进行初始化操作,等待工厂方法创建出app对象，再延后关联# db数据库必须定义成全局变量，方便别的模块调用db = SQLAlchemy()# 设计模式：MVC MVT MVVM 工厂设计模式，单例设计模式，中间人设计思想-生产者消费者模式，装饰器模式,...# https://yq.aliyun.com/topic/122# 需求：将app创建封装到工厂方法中def create_app(config_name):    # 1.创建app    app = Flask(__name__)    # 2.读取配置类中的配置信息    config_class = config_dict[config_name]    app.config.from_object(config_class)    # 3.读取环境变量中私有配置信息    # 后加载的同名配置信息会覆盖之前的配置信息    app.config.from_envvar(&quot;CONFIG&quot;, silent=True)    # 懒加载 延后加载    db.init_app(app)    # 4.返回app    return app# 开发模式下的app对象app = create_app(&quot;dev&quot;)# 生产模式下的app对象# app = create_app(&quot;pro&quot;)print(db)@app.route(&#x27;/&#x27;)def hello_world():    print(app.config[&quot;REDIS_HOST&quot;])    return &#x27;Hello World!&#x27;if __name__ == &#x27;__main__&#x27;:    app.run(debug=True, port=8000)\n用装饰器拦截放回字典定制json格式from flask import Flaskfrom flask_restful import Api, Resourceapp = Flask(__name__)# 1.将app对象包装创建api对象 [用于管理类视图(资源)]api = Api(app)&quot;&quot;&quot;需求：&#123;    &quot;name&quot;: &quot;james&quot;,    &quot;team&quot;: &quot;lakers&quot;&#125;定制返回的json格式：&#123;    &quot;message&quot;: &quot;OK&quot; 或 &quot;ERROR Message&quot;,    &quot;data&quot;: &#123;            &quot;name&quot;: &quot;james&quot;,            &quot;team&quot;: &quot;lakers&quot;    &#125;&#125;方案1：修改底层output_json的源代码 [不推荐]    # json定制化    if &quot;message&quot; not in data:        data = &#123;            &quot;message&quot;: &quot;OK&quot;,            &quot;data&quot;: data        &#125;方案2：使用装饰器拦截返回的字典，定制json格式，返回响应 [推荐]&quot;&quot;&quot;from utils import output_json# 主动寻求装饰api.representation(mediatype=&quot;application/json&quot;)(output_json)# 2.定义类视图  继承Resourceclass DemoResource(Resource):    def get(self):        # 类视图响应的content-type默认变为json形式        # 类视图的返回值可以是字典, 会被自动转为json字符串        my_dict = &#123;            &quot;name&quot;: &quot;james&quot;,            &quot;team&quot;: &quot;lakers&quot;        &#125;        return my_dict    def post(self):        my_dict = &#123;            &quot;name&quot;: &quot;james&quot;,            &quot;team&quot;: &quot;lakers&quot;,            &quot;message&quot;: &quot;invalid user&quot;        &#125;        return my_dict# 3.api对象给类视图添加路由api.add_resource(DemoResource, &#x27;/&#x27;)if __name__ == &#x27;__main__&#x27;:    print(app.url_map)    app.run(debug=True)"},{"url":"/2025/09/11/flask/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/","content":"优化查询user.query.options(load_only(user.id))\n\n增加数据（增加数据主要需要三步操作）\n创建模型对象模型对象 &#x3D; 模型类(字段名&#x3D;字段值)将模型对象添加到会话中组件对象.session.add(模型对象)提交会话组件对象.session.commit()# 1.创建模型对象    user1 = User(name=&#x27;zs&#x27;, age=20)    # user1.name = &#x27;zs&#x27;    # user1.age = 20    # 2.将模型对象添加到会话中     db.session.add(user1)    # 添加多条记录    # db.session.add_all([user1, user2, user3])    # 3.提交会话 (会提交事务)    # sqlalchemy会自动创建隐式事务    # 事务失败会自动回滚    db.session.commit()    return &quot;index&quot;\n\n查询User.query.(查询方法)User.query.all()\n\n删除数据1. 先查询, 再删除2. 基于过滤条件的删除@app.route(&#x27;/del&#x27;)def delete():    &quot;&quot;&quot;删除数据&quot;&quot;&quot;    # 方式1: 先查后删除    goods = Goods.query.filter(Goods.name == &#x27;方便面&#x27;).first()    # 删除数据    db.session.delete(goods)    # 提交会话 增删改都要提交会话    db.session.commit()    return &quot;index&quot;\n方法二# 方式2: delete子查询Goods.query.filter(Goods.name == &#x27;方便面&#x27;).delete()# 提交会话db.session.commit()\n\n刷新数据Session 被设计为数据操作的执行者, 会先将操作产生的数据保存到内存中在执行 flush刷新操作 后, 数据操作才会同步到数据库中有两种情况下会 隐式执行刷新操作:提交会话执行查询操作 (包括 update 和 delete 子查询)开发者也可以 手动执行刷新操作 session.flush()\n执行迁移命令export FLASK_APP=hm_数据迁移.py  # 设置环境变量指定启动文件flask db init  # 生成迁移文件夹flask db migrate  # ⽣成迁移版本, 保存到迁移文件夹中flask db upgrade  # 执行迁移"},{"url":"/2025/09/11/flask/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/","content":"# app/__init__.py ...from flask_migrate import Migrate...def register_extensions(app):    &quot;&quot;&quot;组件初始化&quot;&quot;&quot;    ...    # 数据迁移组件初始化    Migrate(app, db)    # 导入模型类    from models import user\nWindows中没有这个命令，应该采用SET命令\n"},{"url":"/2025/09/11/flask/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","content":"导出虚拟环境所有的第三方包pip freeze &gt; requirements.txt\n一次性安装pip install -r requirements.txt  -i 源\n"},{"url":"/2025/09/11/flask/%E9%93%BE%E6%8E%A5mysql/","content":"在Mysql命令行中更改时区\n点开最右侧 Advanced，找到 serverTimezone，在右侧value处填写 GMT，保存即可！(或填写 Asia&#x2F;Shanghai)Copymysql &gt; SET time_zone &#x3D; ‘+8:00’; # 此为北京时，我们所在东8区Copymysql&gt; flush privileges; # 立即生效\n"},{"url":"/2025/09/11/python%E5%A4%8D%E4%B9%A0/python%20%E5%A4%8D%E4%B9%A0day01/","content":"1.python 魔法方法1.对象构造方法1."},{"url":"/2025/09/11/python%E5%A4%8D%E4%B9%A0/%E4%BC%98%E5%8C%96/","content":"6.6 关于 Python 程序的运行方面，有什么手段能提升性能？(2018-3-30-lxy)1、使用多进程，充分利用机器的多核性能2、对于性能影响较大的部分代码，可以使用 C 或 C++编写3、对于 IO 阻塞造成的性能影响，可以使用 IO 多路复用来解决4、尽量使用 Python 的内建函数5、尽量使用局部变量\n字典排序1.1 现有字典 d=&#123;‘a’:24，‘g’:52，‘i’:12，‘k’:33&#125;请按字典中的 value值进行排序？ (2018-3-30-lxy)sorted(d.items()，key = lambda x:x[1]) 。\n高级切片方法字典排序str1 = &quot;k:1|k1:2|k2:3|k3:4&quot;def str2dict(str1):\tdict1 = &#123;&#125;for iterms in str1.split(&#x27;|&#x27;):key，value = iterms.split(&#x27;:&#x27;)dict1[key] = valuereturn dict1\nalist排序alist [&#123;&#x27;name&#x27;:&#x27;a&#x27;，&#x27;age&#x27;:20&#125;，&#123;&#x27;name&#x27;:&#x27;b&#x27;，&#x27;age&#x27;:30&#125;，&#123;&#x27;name&#x27;:&#x27;c&#x27;，&#x27;age&#x27;:25&#125;] def sort_by_age(list1): return sorted(alist，key=lambda x:x[&#x27;age&#x27;]，reverse=True)"},{"url":"/2025/09/11/%E4%BA%91%E7%8E%AF%E5%A2%83/%E4%BA%91%E7%8E%AF%E5%A2%83/","content":"https://www.bistudio.com.cn/cloudDetail?cloud_id=1\n"},{"url":"/2025/09/11/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/newnote_1602030880118/","content":"\n"},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Matplotib/","content":"中文显示from pylab import mplmpl.rcParams[&quot;font.sans-serif&quot;]=[&quot;SimHei&quot;]mpl.rcParams[&quot;axes.unicode_minu&quot;]= False\n添加网格显示plt.grid(True, linestyle=&quot;--&quot;,alpha=0.5)\n\n添加描述信息plt.xlable(&quot;时间&quot;)plt.ylable(&quot;温度&quot;)plt.title(&quot;中午的温度变化图&quot;，fontsize=20)\n图像保存plt.savefig(&quot;test.png&quot;)\n画图流程\nimport matplotlib.pyplot as pltimport randomfrom pylab import mpl# 设置显示中文字体from pylab import mplmpl.rcParams[&quot;font.sans-serif&quot;] = [&quot;SimHei&quot;]# 设置正常显示符号mpl.rcParams[&quot;axes.unicode_minus&quot;] = False# 0.准备数据x = range(60)y_shanghai = [random.uniform(15, 18) for i in x]# 1.创建画布plt.figure(figsize=(20, 8), dpi=100)# 2.绘制图像plt.plot(x, y_shanghai)# 2.1 添加x,y轴刻度# 构造x,y轴刻度标签x_ticks_label = [&quot;11点&#123;&#125;分&quot;.format(i) for i in x]y_ticks = range(40)# 刻度显示plt.xticks(x[::5], x_ticks_label[::5])plt.yticks(y_ticks[::5])# 2.2 添加网格显示plt.grid(True, linestyle=&quot;--&quot;, alpha=0.5)# 2.3 添加描述信息plt.xlabel(&quot;时间&quot;)plt.ylabel(&quot;温度&quot;)plt.title(&quot;中午11点--12点某城市温度变化图&quot;, fontsize=20)# 2.4 图像保存plt.savefig(&quot;./test.png&quot;)# 3.图像显示plt.show()\n\n一图多线多次plot\n# 增加北京的温度数据y_beijing = [random.uniform(1, 3) for i in x]# 绘制折线图plt.plot(x, y_shanghai)# 使用多次plot可以画多个折线plt.plot(x, y_beijing, color=&#x27;r&#x27;, linestyle=&#x27;--&#x27;)\n各图形及其语法折线图\napi: plt plot(x,y)\n散点图\napi: plt.scatter(x,y)\n\n柱状图\napi：plt.bar(x, width, align=&#x27;center&#x27;, **kwargs)Parameters:    x : 需要传递的数据width : 柱状图的宽度align : 每个柱状图的位置对齐方式    &#123;‘center’, ‘edge’&#125;, optional, default: ‘center’**kwargs :color:选择柱状图的颜色dadatwer\n直方图\napi: matplotilb.pyplot.hist(x,bins=None)Parameters:    x : 需要传递的数据bins : 组距\n饼图\napi: plt.pie(x,labels=,atuopct=,colors)Parameters:  x:数量，自动算百分比labels:每部分名称autopct:占比显示指定%1.2f%%colors:每部分颜色\n"},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Numpy/","content":"生成数组a = np.array([[1,2,3],[4,5,6]])# 从现有的数组当中创建a1 = np.array(a)# 相当于索引的形式，并没有真正的创建一个新的a2 = np.asarray(a)\n 关于array和asarray的不同\n等于创建一个软链接当数组赋值给另外一个变量后，array：修改变量不会改变asarray： 会跟着改变\n\n\n生成各种不同的数组\n生成固定范围的数组np.linspace (start, stop, num, endpoint)参数:start:序列的起始值stop:序列的终止值num:要生成的等间隔样例数量，默认为50endpoint:序列中是否包含stop值，默认为ture等差数组np.arange(start,stop, step, dtype)参数step:步长,默认值为1np.arange(10, 50, 2)等比数组np.logspace(start,stop, num)num:要生成的等比数列数量，默认为50 生成随机数组np.random   \n\n正态分布创建方法\n准正态分布中返回一个或多个样本值np.random.randn(d0, d1, …, dn)np.random.normal(loc=0.0, scale=1.0, size=None)loc：float​ 此概率分布的均值（对应着整个分布的中心centre）scale：float​ 此概率分布的标准差（对应于分布的宽度，scale越大越矮胖，scale越小，越瘦高）size：int or tuple of ints​ 输出的shape，默认为None，只输出一个值返回指定形状的标准正态分布的数组。np.random.standard_normal(size=None)\n\n均匀分布np.random.rand(d0, d1, ..., dn)返回一组均匀分布的数。从一个均匀分布[low,high)中随机采样，注意定义域是左闭右开，即包含low，不包含high.np.random.uniform(low=0.0, high=1.0, size=None均匀分布中随机采样，生成一个整数或N维整数数组np.random.randint(low, high=None, size=None, dtype=&quot;l&quot;)取数范围：若high不为None时，取[low,high)之间随机整数，否则取值[0,low)之间随机整数。\n\n形状修改返回一个具有相同数据域，但shape不一样的视图行、列不进行互换ndarray.reshape(shape, order)修改数组本身的形状（需要保持元素个数前后相同）行、列不进行互换ndaarray.resize(new_shape)数组的转置将数组的行、列进行互换ndaarray.T\n\n类型修改返回修改了类型之后的数组stock_change.astype(np.int32)构造包含数组中原始数据字节的Python字节  arr = np.array([[[1, 2, 3], [4, 5, 6]], [[12, 3, 34], [5, 6, 7]]])arr.tostring()\n返回给定的形状哥类型的新数组，用0填充numpy.zeros(shape，dtype&#x3D;float，order &#x3D; ‘C’)\n返回给定形状和类型的新数组，用0填充。参数：\tshape：int 或 int 的元组 \t新阵列的形状，例如：（2，3）或2。 \tdtype：数据类型，可选 \t数组的所需数据类型，例如numpy.int8。默认是numpy.float64 \torder：&#123;&#x27;C&#x27;，&#x27;F&#x27;&#125;，可选，默认：&#x27;C&#x27; \t是否在内容中以行（C）或列（F）顺序存储多维数据。返回：\tout：ndarray \t具有给定形状，类型和顺序的0的数组。np.zeros((2,3))Out[2]: array([[ 0.,  0.,  0.],       [ 0.,  0.,  0.]])\n\n\n分组频数计算\nmean() 取平均值nunique方法计算pandas Series的唯一值计算（去重）value_counts方法获取pandas Series的频数统计\n\nto_numeric 函数变量转换为数值类型（int，float）\nDataFrame每一列的数据类型必须相同，当有些数据中有缺失，但不是NaN时（如missing,null等），会使整列数据变成字符串类型而不是数值型，这个时候可以使用to_numeric处理pd.to_numeric(tips_sub_miss[&#x27;total_bill&#x27;])to_numeric函数有一个参数errors,它决定了当该函数遇到无法转换的数值时该如何处理默认情况下,该值为raise,如果to_numeric遇到无法转换的值时,会抛错coerce: 如果to_numeric遇到无法转换的值时,会返回NaNignore: 如果to_numeric遇到无法转换的值时会放弃转换,什么都不做pd.to_numeric(tips_sub_miss[&#x27;total_bill&#x27;],errors = &#x27;ignore&#x27;)to_numeric向下转型to_numeric函数还有一个downcast参数, downcast接受的参数为 &#x27;integer&#x27;,&#x27;signed&#x27;,&#x27;float&#x27;,&#x27;unsigned&#x27;downcast参数设置为float之后, total_bill的数据类型由float64变为float32pd.to_numeric(tips_sub_miss[&#x27;total_bill&#x27;],errors = &#x27;coerce&#x27;,downcast=&#x27;float&#x27;)\n\n分类数据(category)Pandas 有一种类别数据, category,用于对分类值进行编码\n转换为category类型tips[&#x27;sex&#x27;] = tips[&#x27;sex&#x27;].astype(&#x27;str&#x27;) tips.info()\nPandas 数据类型转换Pandas除了数值型的int 和 float类型外，还有object ，category，bool，datetime类型可以通过as_type 和 to_numeric 函数进行数据类型转换Pandas 分类数据类型category类型，可以用来进行排序，并且可以自定义排序顺序CategoricalDtype可以用来定义顺序\n"},{"url":"/2025/09/11/%E6%B5%8B%E8%AF%95/day1/","content":""},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/kaikeba/","content":"mean(平均值)热数据\nsns.heatmap(dataframe.corr(), annot=True, fmt=&#x27;.1f&#x27;)\n(例子用于理解)对比两个最小值的均值（第一个age 提取出年龄）（[:2]（把排好序的的两个拿出））\nnp.mean([age for name ,age in sorted(person_and_age.items(), key = lambda e: e[1])[:2]])\n对比两个最小值的均值【:topn】(最前的两个数值)history_price(数据)e[0](取 面积：价格 的面积)\ndef find_price_by_similar(history_price,query_x, topn=3):\tmost_similar_items = sorted(history_price.items(), key= lambda e: (e[0] - query_x)**2)[:topn]\tmost_similar_prices = [price for rm, price in most_similar_items]\taverage_prices = np.mean(most_similar_prices)\treturn average_prices\n\n回归预测结果产生的是一个数值，分类产生一个类别KNN&#x3D;&#x3D;&gt;K-Neighbor-Nearest\n拟合效果 是获取最优的k，b的问题\n损失函数：Loss越接近0，越准确\n𝑓(𝑟𝑚)=𝑘∗𝑟𝑚+𝑏Random Approach𝐿𝑜𝑠𝑠(𝑘,𝑏)=1𝑛∑𝑖∈𝑁(𝑦𝑖^−𝑦𝑖)2 𝐿𝑜𝑠𝑠(𝑘,𝑏)=1𝑛∑𝑖∈𝑁((𝑘∗𝑟𝑚𝑖+𝑏)−𝑦𝑖)2\n怎么获取最优的k&amp;b？1.直接用微积分的方法做计算（最小二乘法）（简单才用，基本不用）2.用随机模拟的方法来做（随机生成一堆数）也叫：蒙特卡洛模拟\ndef loss(y_hat, y):    return np.mean((y_hat - y) ** 2)import randommin_loss = float(&#x27;inf&#x27;)best_k, bes_b = None, Nonefor step in range(1000):    min_v, max_v = -100, 100    k, b = random.randrange(min_v, max_v), random.randrange(min_v, max_v)    y_hats = [k * rm_i  + b for rm_i in x]    current_loss = loss(y_hats, y)        if current_loss &lt; min_loss:        min_loss = current_loss        best_k, best_b = k, b        print(&#x27;在第&#123;&#125;步，我们获得了函数 f(rm) = &#123;&#125; * rm + &#123;&#125;, 此时loss是: &#123;&#125;&#x27;.format(step, k, b, current_loss))\n蒙特卡洛模拟Supervisor𝐿𝑜𝑠𝑠(𝑘,𝑏)=1/𝑛*∑𝑖∈𝑁((𝑘∗𝑟𝑚𝑖+𝑏)−𝑦𝑖)2∂𝑙𝑜𝑠𝑠(𝑘,𝑏)/∂𝑘=2/𝑛*∑𝑖∈𝑁(𝑘∗𝑟𝑚𝑖+𝑏−𝑦𝑖)∗𝑟𝑚𝑖∂𝑙𝑜𝑠𝑠(𝑘,𝑏)/∂𝑏=2/𝑛*∑𝑖∈𝑁(𝑘∗𝑟𝑚𝑖+𝑏−𝑦𝑖)\ndef partial_k(k, b, x, y):    return 2 * np.mean((k * x + b - y) * x)def partial_b(k, b, x, y):    return 2 * np.mean(k * x + b - y)k_history, b_history = [], []loss_history = []k, b = random.random(), random.random()min_loss = float(&#x27;inf&#x27;)best_k, bes_b = None, Nonelearning_rate = 1e-2for step in range(2000):    k, b = k + (-1 * partial_k(k, b, x, y) * learning_rate), b + (-1 * partial_b(k, b, x, y) * learning_rate)    y_hats = k * x + b    current_loss = loss(y_hats, y)        if current_loss &lt; min_loss:        min_loss = current_loss        best_k, best_b = k, b        k_history.append(best_k)        b_history.append(best_b)        loss_history.append(current_loss)        print(&#x27;在第&#123;&#125;步，我们获得了函数 f(rm) = &#123;&#125; * rm + &#123;&#125;, 此时loss是: &#123;&#125;&#x27;.format(step, k, b, current_loss))\n\n深度学习的核心 ： 通过梯度下降的方法，获得一组参数，是的loss最小loss偏导式 + 梯度下降\n将课堂代码中的L2-Loss 变成L1Loss 并且实现梯度下降\n𝐿2−𝐿𝑜𝑠𝑠(𝑦,𝑦̂ )=1/𝑛*∑(𝑦̂ −𝑦)2 𝐿1−𝐿𝑜𝑠𝑠(𝑦,𝑦̂ )=1/𝑛*∑|(𝑦̂ −𝑦)|\n"},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ndarray%E8%BF%90%E7%AE%97/","content":"逻辑运算# 随机生成10名同学，5门功课的数据score = np.random.randint(40, 100,(10,5))print(score)# 切片 取出最后4名同学的成绩，用逻辑判断test_score = score[6:, 0:5]# 逻辑判断print(test_score &gt; 60)# 布尔索引(满足条件替换)print(test_score[test_score &gt; 60] =1)判断or&amp;and# 判断前两名同学的成绩[0:2, :]是否全及格&gt;&gt;&gt; np.all(score[0:2, :] &gt; 60)Falsenp.any()# 判断前两名同学的成绩[0:2, :]是否有大于90分的&gt;&gt;&gt; np.any(score[0:2, :] &gt; 80)True\n\n三目运算# 判断前四名学生,前四门课程中，成绩中大于60的置为1，否则为0temp = score[:4, :4]np.where(temp &gt; 60, 1, 0)# 判断前四名学生,前四门课程中，成绩中大于60且小于90的换为1，否则为0np.where(np.logical_and(temp &gt; 60, temp &lt; 90), 1, 0)# 判断前四名学生,前四门课程中，成绩中大于90或小于60的换为1，否则为0np.where(np.logical_or(temp &gt; 90, temp &lt; 60), 1, 0)\n\n数组运算时的广播机制：\n数组在进行矢量化运算时，要求数组的形状是相等的。"},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/pandas/","content":"创建Series\nimport pandas as pd s = pd.Series([&#x27;banana&#x27;,42])\n创建DataFrame\nname_list = pd.DataFrame(\t&#123;\t\t&#x27;Name&#x27;:[&#x27;Tome&#x27;,&#x27;Bob&#x27;], \t\t&#x27;Occupation&#x27;:[&#x27;Teacher&#x27;,&#x27;IT Engineer&#x27;], \t\t&#x27;age&#x27;:[28,36]\t&#125;)\nSeries 常用操作loc\t使用索引值取子集iloc \t使用索引位置取子集dtype或dtypes Series\t内容的类型T \tSeries的转置矩阵shape \t数据的维数size \tSeries中元素的数量values \tSeries的值.value_counts()\t\t统计value数量director.count() \t返回非空值describe() \t打印描述信息\nSeries的一些方法方法 \t说明append \t连接两个或多个Seriescorr \t计算与另一个Series的相关系数cov\t 计算与另一个Series的协方差describe 计算常见统计量drop_duplicates \t返回去重之后的Seriesequals \t\t判断两个Series是否相同get_values \t获取Series的值，作用与values属性相同hist \t绘制直方图isin Series\t中是否包含某些值min \t返回最小值max\t返回最大值mean\t返回算术平均值median\t返回中位数mode \t返回众数quantile \t返回指定位置的分位数replace \t用指定值代替Series中的值sample\t 返回Series的随机采样值sort_values \t对值进行排序to_frame\t把Series转换为DataFrameunique \t\t去重返回数组\n两个Series之间计算，如果Series元素个数相同，则将两个Series对应元素进行计算；元素不同则缺失用NaN表示\nDataFramendim 查看数集的维度set_index 修改索引drop 删除列to_pickle 保存read_pickle 读取to_csv  保存成csv文件格式：(&#x27;output/scientists_df.tsv&#x27;,sep=&#x27;\\t&#x27;)to_clipboard 把数据保存到系统剪贴板，方便粘贴to_dict 把数据转换成Python字典to_hdf 把数据保存为HDF格式to_html 把数据转换成HTMLto_json 把数据转换成JSON字符串to_sql 把数据保存到SQL数据库nlargest(100,&#x27;imdb_score&#x27;)0.1统计数值列，并进行转置college.describe().T统计多方式数值.describe()nlargest方法显示出某列的排序nlargest(100,&#x27;imdb_score&#x27;).head()传入一个字典agg(&#x27;key&#x27;:&#x27;value&#x27;)\n聚合重点agg\n数据链接concat\t把dataframe(简单叠堆)ignore_index = True\t忽略后面DataFrame的索引添加列（默认添加行），传入参数 axis = columnscol_concat = pd.concat([df1,df2,df3],axis=1)向DataFrame添加一列，不需要调用函数，通过dataframe[&#x27;列名&#x27;] = [&#x27;值&#x27;] 即可\n链接数据库pd.read_sql_table从数据库中读取表，第一个参数是表名，第二个参数是数据库连接对象\nhow = ’left‘ 对应SQL中的 left outer 保留左侧表中的所有keyhow = ’right‘ 对应SQL中的 right outer 保留右侧表中的所有keyhow = &#x27;outer&#x27; 对应SQL中的 full outer 保留左右两侧侧表中的所有keyhow = &#x27;inner&#x27; 对应SQL中的 inner 只保留左右两侧都有的key转换：to_timedelta 将Milliseconds列转变为timedelta数据类型dt.floor(&#x27;s&#x27;) dt.floor() 时间类型数据，按指定单位截断数据DataFrame的assign方法：创建新列.assignjoin合并，依据两个DataFrame的行索引，如果合并的两个数据有相同的列名，需要通过lsuffix，和rsuffix，指定合并后的列名的前缀stocks_2016.join(stocks_2017, lsuffix=&#x27;_2016&#x27;, rsuffix=&#x27;_2017&#x27;, how=&#x27;outer&#x27;)concat, join, 和merge的区别concat ：Pandas函数可以垂直和水平地连接两个或多个pandas对象只用索引对齐默认是外连接（也可以设为内连接）join ：DataFrame方法只能水平连接两个或多个pandas对象对齐是靠被调用的DataFrame的列索引或行索引和另一个对象的行索引（不能是列索引）通过笛卡尔积处理重复的索引值默认是左连接（也可以设为内连接、外连接和右连接）merge ：DataFrame方法只能水平连接两个DataFrame对象对齐是靠被调用的DataFrame的列或行索引和另一个DataFrame的列或行索引通过笛卡尔积处理重复的索引值默认是内连接（也可以设为左连接、外连接、右连接）\n\n缺失数据处理keep_default_na = False 关闭NaN显示ffill 填充，用时间序列中空值的上一个非空值填充city_day.fillna(method=&#x27;ffill&#x27;,inplace=True) city_day[&#x27;Xylene&#x27;][50:65]用时间序列中空值的下一个非空值填充method=&#x27;bfill&#x27;线性差值方法limit_direction=&quot;both&quot;\n整理数据melt既可以用pd.melt, 也可使用dataframe.melt()\nframe dataframe 被 melt 的数据集名称在 pd.melt() 中使用id_vars tuple/list/ndarray \t可选项不需要被转换的列名，在转换后作为标识符列（不是索引列）value_vars tuple/list/ndarray \t可选项需要被转换的现有列如果未指明，除 id_vars 之外的其他列都被转换var_name string variable \t默认值自定义列名名称设置由 &#x27;value_vars&#x27; 组成的新的 column namevalue_name string value \t默认值自定义列名名称设置由 &#x27;value_vars&#x27; 的数据组成的新的 column namecol_level int/string \t可选项如果列是MultiIndex，则使用此级别数据整理（函数自动处理）pew_long = pd.melt(pew,id_vars=&#x27;religion&#x27;)pew_long\n处理查询冗余对于同一首歌曲来说，歌曲信息是完全一样的，可以考虑单独保存歌曲信息减少上表中保存的歌曲信息，可以节省存储空间，需要完整信息的时候，可以通过merge拼接数据我们可以把year,artist,track,time和date.entered放入一个新的dataframe中1.提取表信息，进行去重illboard_songs = bill_borad_long[[&#x27;year&#x27;,&#x27;artist&#x27;,&#x27;track&#x27;,&#x27;time&#x27;,&#x27;date.entered&#x27;]] billboard_songs = billboard_songs.drop_duplicates()billboard_songs2.为新拆分处理出来的数据添加ID列（添加ID）billboard_songs[&#x27;id&#x27;] = range(len(billboard_songs)) billboard_songs3.数据拆分成两个dataframe：billboard_songs和 billboard_ratings取出每周评分，去掉冗余部分billboard_ratings = bill_borad_long.merge(billboard_songs,on=[&#x27;year&#x27;,&#x27;artist&#x27;,&#x27;track&#x27;,&#x27;time&#x27;,&#x27;date.entered&#x27;]) billboard_ratings = billboard_ratings[[&#x27;id&#x27;,&#x27;week&#x27;,&#x27;rating&#x27;]] billboard_ratings4.用merage还原数据billboard_songs.merge(billboard_ratings,on=[&#x27;id&#x27;])\nstack整理数据用rename_axis给不同的行索引层级命名reset_index()，将结果变为DataFrame\nwide_to_long整理数据stubs = [&#x27;actor&#x27;, &#x27;actor_facebook_likes&#x27;]actor2_tidy = pd.wide_to_long(actor2, stubnames=stubs, i=[&#x27;movie_title&#x27;], j=&#x27;actor_num&#x27;, sep=&#x27;_&#x27;).reset_index() actor2_tidy.head()\nunstack 处理数据之前介绍了stack，unstack可以将stack的结果恢复\nstate_fruit.stack().unstack()\n\n\n自定义方法.apply(方法名)\n向量函数def avg_2_mod(x,y): \tif(x==20): \t\treturn (np.NaN) \telse:return (x+y)/2 avg_2_mod(df[&#x27;a&#x27;],df[&#x27;b&#x27;])上面函数中, x==20 , x 是向量, 但20是标量, 不能直接计算. 这个时候可以使用np.vectorize将函数向量化使用装饰器@np.vectorize def vec_avg_2_mod(x,y): \tif(x==20):\t\t return (np.NaN) \telse:\t\treturn (x+y)/2 vec_avg_2_mod(df[&#x27;a&#x27;],df[&#x27;b&#x27;])\nlambda函数df.apply(lambda x: x+1)\nPandas内置的聚合方法Pandas\t方法 Numpy函数 说明count \tnp.count_nonzero \t频率统计(不包含NaN值)size \t频率统计(包含NaN值)mean np.mean \t求平均值std np.std \t标准差min np.min \t最小值quantile() \tnp.percentile() \t分位数max np.max \t求最大值sum np.sum \t求和var np.var \t方差describe \t计数、平均值、标准差，最小值、分位数、最大值first \t返回第一行last \t返回最后一行nth 返回第N行(Python从0开始计数)\naggagg.(‘列名’:’方法名’).rename(‘原名’：’新名’)\n转换transform 转换，需要把DataFrame中的值传递给一个函数， 而后由该函数”转换”数据。aggregate(聚合) 返回单个聚合值，但transform 不会减少数据量\n# 计算z-score x - 平均值/标准差 def my_zscore(x): \treturn (x-x.mean())/x.std() #按年分组 计算z-score df.groupby(&#x27;year&#x27;).lifeExp.transform(my_zscore)\ntransform分组填充缺失值之前介绍了填充缺失值的各种方法，对于某些数据集，可以使用列的平均值来填充缺失值。某些情况下，可以考虑将列进行分组，分组之后取平均再填充缺失值tips_10 = pd.read_csv(&#x27;data/tips.csv&#x27;).sample(10,random_state = 42) tips_10"},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/","content":"算法分为：\n监督学习\n\n\n定义：输入数据是由输入特征值和目标值所组成\n函数的输出可以是连续的值（回归）\n或是输出有限个离散值（分类）\n\n\n\n\n无监督学习\n\n\n定义：输入数据是由输入特征值组成，没有目标值\n输入数据没有被标记，也没有确定的结果。样本数据类别未知\n需要根据样本间的相似性对样本集进行类别划分\n\n\n\n\n半监督学习\n\n\n定义训练集同时包含有标记样本数据和未标记样本数据\n\n\n强化学习\n\n\tIn\tOut\t目的\t案例监督学习(supervised learning)\t有标签\t有反馈\t 预测结果\t猫狗分类 房价预测无监督学习(unsupervised learning)\t无标签\t无反馈\t   发现潜在结构\t“物以类聚，人以群分”半监督学习(Semi-Supervised Learning) 部分  有标签，     部分无标签\t有反馈\t降低数据标记的难度\t强化学习(reinforcement learning) 决策流程及激励系统 一系列行动\t长期利益最大化\t学下棋\n\n\n\n工作流1.获取数据2.数据基本处理- 1.缩小数据集范围DataFrame.query()- 2.选取有用的时间特征- 3.将签到位置少于n个用户的删除3.特征工程- 特征提取- 特征预处理- 特征降维- 特征预处理(标准化)4.机器学习(模型训练)5.模型评估- 结果达到要求，上线服务- 没有达到要求，重新上面步骤\n"},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/","content":"(M行, N列)*(N行, L列) &#x3D; (M行, L列)C &#x3D; A x B\nc(1,1) &#x3D; （1行1 * 1列1）+ （1行2 *1列2）…c(1,2) &#x3D; （1行1 * 2列1）+ （1行2 *2列2）…矩阵乘法的性质矩阵的乘法不满足交换律：A×B≠B×A\n矩阵的乘法满足结合律。即：A×（B×C）&#x3D;（A×B）×C\n单位矩阵：在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的 1,我们称 这种矩阵为单位矩阵．它是个方阵，一般用 I 或者 E 表示，从 左上角到右下角的对角线（称为主对角线）上的元素均为 1 以外全都为 0\n矩阵乘法api：np.matmulnp.dot\nnp.matmul和np.dot的区别:二者都是矩阵乘法。 np.matmul中禁止矩阵与标量的乘法。 在矢量乘矢量的內积运算中，np.matmul与np.dot没有区别。\n"},{"url":"/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/DRF%E6%A1%86%E6%9E%B6/","content":"DRF框架就是RestFramework框架（rest_framework[导入的方式]）\nREF开发模式：\t前后端分离模式开发的\n\nRESTful\n\n\n域名  接口设计方法：【大型服务部署放在专有域名下（整个服务器提供此类服务）】\n\n https://api.example.com\n小型 子应用：\nhttps://example.org/api/\n\n\n\n版本（在app后面放版本号）\n\nhttps://www.example.com/api/1.0/foo\n\n路径(名词，复数)遵循restful风格：&#x2F;books&#x2F;\n\n#请求动作\n\n没pk（id）：get + &#x2F;books&#x2F; &#x3D;&#x3D;&gt; 获取全部对象post + &#x2F;books&#x2F; &#x3D;&#x3D;&gt; 新建一数据\n\n有pk：get + &#x2F;books&#x2F; &#x3D;&#x3D;&gt; 获取单一对象put + &#x2F;books&#x2F; &#x3D;&#x3D;&gt; 更新单一对象delete + &#x2F;bookds&#x2F; &#x3D;&#x3D;&gt; 删除单一对象\n\n过滤参数 过滤的参数一般是放在查询字符串中携带\n\n过滤的参数一般放在查询字符串中携带查询字符串 &#x3D; page\n\n\nget + /books/?page=1&amp;page_size = 5分页就是过滤，根据page个page_size查询字符串参数去分页（过滤）\n\n\n状态码\n\n200 获取数据成功201 新建、更新成功400 后端校验参数错误401  没身份（匿名用户）403  没有权限404 资源找不到 1（路由错了，路由映射错了）2 （根据pk查询数据库找不到）405 请求方式不被允许（视图类没有重写视图方法）500 后端代码错误"},{"url":"/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/git/","content":"版本查询:sit –version查看当前仓库的状态信息：git status将单个文件加入缓存区：git add(绿了)将所有文件加入缓存区：git add.提交这次变更：git commit -m(message-描述)查看日志：git log将缓存区拿出来：(绿变红)git reset\n生成密钥：ssh-keygen -t rsa查看公钥：cat ~&#x2F;.ssh&#x2F;id_rsa.pub主题部署上线：hexo deploy\n"},{"url":"/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/restful%20%E9%A3%8E%E6%A0%BC%EF%BC%8C%E5%AE%9A%E4%B9%89http%E6%8E%A5%E5%8F%A3%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","content":"查询书本列表数据get + &#x2F;books&#x2F;请求方式 GET请求路径 &#x2F;books&#x2F;请求参数 无请求返回 json\nclass Books(view):\tdef get(self, request):  \t\tbooks = books.objects.all()  \t\tbook_list = []  \t\tfro book in books:    \t\t\tbook_list.addend(&#123;        \t\t&#x27;id&#x27;: book.id,        \t\t&#x27;btitle&#x27; : book.btitle,    \t\t&#125;)    \t\tcontext =&#123;        \t\t&#x27;book_list&#x27;： book_list        \t&#125;   \treturn JsonResopnse(context, safe =False)\npost+ &#x2F;books&#x2F;请求方式 POST请求路径 &#x2F;books&#x2F;请求参数 data请求返回 json\ndef post(self, request):\t#提取参数\tbooks_info = json.loads(request.body.decode())\tbtile = books_info.get(&#x27;btile&#x27;)\tbp = books.get(&#x27;bp&#x27;)\t#校验\tif not ([bp,btile]):\t\treutrn JsonResopnse(&#123;&#x27;errmsg&#x27;: &#x27;缺少必传字段&#x27;&#125;, status = 400)\tif len(btile)&gt;20:\t\treturn JsonResposne(&#123;&#x27;errmsg&#x27;: &#x27;名字过长&#x27;&#125;)\t#逻辑业务\ttry:\t\tbook = BookInfo.objects.create(**book_info)\texcept Exception as e:\t\treturn (&#123;&#x27;errmsgg&#x27;: &#x27;内部错误&#x27;&#125;)\t#构建返回--restful风格约定更新或者新建之后一定要吧最新资源返回\treturn JsonResopnse(&#123;\t\t&#x27;id&#x27;: book.id&#125;)"},{"url":"/2025/09/11/mysql%E6%97%B6%E9%97%B4%E6%9F%A5%E8%AF%A2/mysq/newnote_1616765059970/","content":"\n\n\ndistinct可以去除重复数据行\n\n\n\nlike是模糊查询关键字%表示任意多个任意字符_表示一个任意字符例1：查询姓黄的学生:select * from students where name like &#x27;黄%&#x27;;例2：查询姓黄并且“名”是一个字的学生:select * from students where name like &#x27;黄_&#x27;;例3：查询姓黄或叫靖的学生:select * from students where name like &#x27;黄%&#x27; or name like &#x27;%靖&#x27;;\n\n\n\n\nbetween .. and .. 表示在一个连续的范围内查询in 表示在一个非连续的范围内查询例1：查询编号为3至8的学生:select * from students where id between 3 and 8;例2：查询编号不是3至8的男生:select * from students where (not id between 3 and 8) and gender=&#x27;男&#x27;;"},{"url":"/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/%E9%9A%8F%E7%AC%94/","content":"一、函数和方法的认知函数@classmethod下定义的func属于方法，@staticmethod下定义的func属于函数。而类class中定义的普通func要分是类调用还是类对象调用。函数是封装了一些独立的功能，可以直接调用，能将一些数据（参数）传递进去进行处理，然后返回一些数据（返回值），也可以没有返回值。可以直接在模块中进行定义使用。所有传递给函数的数据都是显式传递的。\n\n\n方法方法和函数类似，同样封装了独立的功能，但是方法是只能依靠类或者对象来调用的，表示针对性的操作。### 方法中的数据self和cls是隐式传递的，即方法的调用者；方法可以操作类内部的数据\n\n当类实例化对象后，如`apple对象`，再调用function时，普通func，如fun1，就被称为是`实例化方法`，定义在@staticmethod下的func，与class和实例化对象无关，所以依然属于`函数`,定义在@classmethod下的func，与class内部有关，属于类的方法。\n\n测试函数还是方法from types import FunctionType, MethodTypeprint(isinstance(lwd.func, FunctionType))  # Falseprint(isinstance(lwd.func, MethodType))   # True   #说明这是一个方法print(isinstance(Lwd.func, FunctionType))  # True   #说明这是一个函数print(isinstance(Lwd.func, MethodType))  # False\n重写管理器对象（自定义manager）class studentManager(models.Manager):  def get_queryset(self):    return super(studentManager,self).get_queryset().filter(isDelete=False)\n\n参数是类def xxx(cls,**yy):\tself &#x3D; cls(**yy)(实例化对象)\n取出请求方法同名的函数名赋值给handlerhandler&#x3D;getattr(self,request.method.lower((小写的意思)),self.http_method_not_allowed)return handler(request,*args,**kwargs)\n1. ### python cls self 讲解一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。而使用@staticmethod或@classmethod，就可以不需要实例化，直接类名.方法名()来调用。这有利于组织代码，把某些应该属于某个类的函数给放到那个类里去，同时有利于命名空间的整洁。\n\nclass A(object):    a &#x3D; ‘a’    @staticmethod    def foo1(name):        print ‘hello’, name    def foo2(self, name):        print ‘hello’, name    @classmethod    def foo3(cls, name):        print ‘hello’, name\n### 1. Mongodb数据库操作#### serilaizer：\nfrom rest_framework_mongoengine import serializers\nclass ListSerializer(serializers.DocumentSerializer):\nclass Meta:\n    model = Spit\n    fields = &quot;__all__&quot;\n\n#### views:\nfrom rest_framework_mongoengine.viewsets import ModelViewSet\nclass ListViewModelSet(ModelViewSet):    # queryset &#x3D; Spit.objects.all()需要转成    # def get_queryset(self):    #         return Spit.objects.all()才能提取\nserializer_class = ListSerializer\n\ndef get_queryset(self):\n    return Spit.objects.all()\n\n\n\n#Python 交换x ,y\nx , y\nint z=x; x=y, y=z\n可以优化为(加空格)\nx , y = y , x\n\n\n\n#根据数据库生成模型类\n\n\n\n创建一个项目，修改seting文件，在setting里面设置要连接的数据库\n\n运行下面代码可以自动生成models模型文件 \nPython manage.py inspectdb \n这样就可以在控制台的命令行中看到数据库的模型文件了\n\n把模型文件导入到app中 \n创建一个app \ndjango-admin.py startapp app \npython manage.py inspectdb &gt; app/models.py \nok模型文件已经生成好了。下面的工作就和之前一样了\n\n\n\n简单介绍工厂模式和单例模式\n工厂模式：\n\n　　介绍：\n\n　　　　工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程（new 关键字和具体的构造器）隐藏起来。用一个工厂方法来替代，对外提供的只是一个工厂方法，达到提高灵活性的目的。 　　\n\n　　优点：\n\n　　　　1.隐藏了new关键字和构造器 \n\n           　2.降低了这个对象与别的类之间的耦合度，提高了程序的可扩展性。 原因：当子类被别的类替代，或者构造器的参数发生变化的时候，只需改动工厂方法内的new即可，改动量降到了最低，直接用new关键字的话，需要改动的地方就很多了 \n\n           　3.把对象的设计和实现分割开来，从而代码扩展性强、灵活性高。 \n\n　　适用范围： \n      　　 1.在编码时不能预见需要创建哪一个种类的实例。 \n       　　2.一个类使用它的子类来创建对象。 \n       　　3.开发人员不希望创建了那个类的实例以及如何创建实例的信息暴露给外部程序。 \n     　　　　　除了上面提到的例子，工厂模式的实现方式还允许有一些小小的变化，例如： \n        　　　　基类可以是一个抽象类，在这种情况下，工厂类必须返回一个非抽象类。 \n       　　　　 基类提供了一些缺省方法，只有当这些缺省方法不能满足特殊需求的情况下才能在子类中重写这些方法。 \n        　　　　可以直接通过传递给工厂类的参数决定应该返回哪一个子类的实例。 \n\n　　 结构：用一个方法来代替new关键字和构造器。 \n\n \n\n单例模式：\n\n　　介绍：\n\n　　　　 1.声明一个私有的，静态的本类对象，但并不在声明的时候就初始化，因此，它的值为null。 \n        　　2.私有化构造器 \n        　　3.对外提供一个全局的，共有的，静态的，唯一的方法，用来获得该实例，但注意的是：必须要手动保持线程同步（synchronized） \n        　　4.在该方法里，判断对象是否为null，如果是null的话，表示这个类还没有被实例化，就会初始化这个对象，再返回如果不是null的话，就直接返回。\n\n　　优点：\n\n　　　　整个系统中的所有的类共用一个实例化对象，这样可以有效的节省资源。\n\n　　适用特点：\n\n　　　　它确保一个类在java虚拟机里只有一个实例，使一个类只有一个对象，整个系统共享这个对象。 \n\n　　结构：将构造变成私有的--&gt;做一个静态的生成对象的方法--&gt;造一个静态的存储对象--&gt;return 静态的对象\n\n\n"},{"url":"/2025/09/11/mysql%E6%97%B6%E9%97%B4%E6%9F%A5%E8%AF%A2/mysql/%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB/","content":"DQL:数据查询语言（凡是带有select 关键字的都是查询语句）select....\nDML：数据操作语言（凡是对表当中的数据进行增删改都是DML）insert delete updateinsert 增delete 删update 改\nDDL:数据定义语言（修改表结构）（凡是带有create、drop、alter的都是DDL，DDL主要操作的时表结构。不是表中的数据）create ： 新建，等同增drop：删除alter：修改\n\nTCL 事务控制语言（主要控制事务）事务提交：commit；事务回滚：rollback；\n\nDCL： 是数据控制语言。（）\n授权：grant撤销授权revoke"},{"url":"/2025/09/11/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/01/%E5%A4%8D%E4%B9%A0%E7%BB%83%E4%B9%A0%E9%9A%8F%E7%AC%94/","content":"1.1 变量即是容器1.2 变量赋值左赋值给右：变量名&#x3D;变量值python解释器是由自上而下的，上面定义的函数如相同的变量名，下面会覆盖上面的定义，索引相同。数据类型分为数字类型和非数字类型。数字类型：int,float,bool,complex非数字类型：str,list,tuple,set,dict查看type（变量名）1.2.1格式化输出:按照一定格式输出到控制台1.2.2 类型转换 int（x）转整数 float（x）转浮点数\tstr(x转字符串)1.2.3 算术运算符 + -  &#x2F; &#x2F;&#x2F; % 优先级*&gt;&#x2F;%&#x2F;&#x2F;&gt;+-1.3复合合运算符+&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; %&#x3D; **&#x3D;1.3操作系统：承上启下：向下管理硬件，向上支持软件python特点：解析性语言缺点效率低2.1比较运算符 &#x3D;&#x3D; !&#x3D; &gt;&#x3D;\t&lt;&#x3D;\t&lt; &gt;逻辑运算符and or not2.2判断语句：\tif…elif…else if嵌套随机数包： import random调用：num&#x3D;random.randint(1,3)【1，3】循环语句：while:i&#x3D;0while i&lt;10:pirnt(‘跑地%d圈’%(i+1))i+&#x3D;1累加sum&#x3D;0while i&lt;100:if i%2:sum+&#x3D;ii+&#x3D;1while循环嵌套2.3：break continuebreak 中断，跳出循环体continue 跳出本次循环就近原则作用2.4三目运算a if a&gt;b else b条件作为中间线，判断左输出a，右输出b 中间条件于变量隔着关键字3.列表[]：增删改查，排序增加\t列表.append（值）尾追加删除 列表.remove(值) 删除第一个出现的指定数据修改：列表【索引】&#x3D;值 数据不存在则报错查询：列表【索引】 不存在则报错len（列表）列表长度if值in列表 判断列表包不含包含值列表.sort（）\t升序列表+for循环遍历for…. lesewhile i&lt;len(list):bl&#x3D;list【i】print(bl)if…in &amp;for..in的区别判断 遍历3.2tuple元组() 只包含一个元素的话（a，）元组不能修改查询 元组【索引】len【元组】if 值 in 元组 值是否在元组里3.3字典{} 储存多个数据，描述物体相关信息用键值对储存”key”:”value”值可以任何类型，但key只能字符串，数字，元组key必须是唯一的增删改查增加：字典【键】&#x3D;值 dict1【“age”】&#x3D;20删除：字典.pop（key）改：字典【键】&#x3D;值查：字典【key】 key 不存在报错字典。get【key】 key不存在返回None遍历字典获取键值对：\tfor key，value in 字典.items()3.4字符串f-strings字符串新型格式化：print（f‘我叫{name}’，年龄‘{age}’）重点：查找替换分割拼接查找：find（目标字符串，开始索引，结束）※替换：字符串.replace(旧，新，全局替换次数)※分割：字符串.spilt(分隔符)※拼接：字符串.join(字符串列表)字符串逆序：【::-1】3.5列表可以通过集合的类型转换进行去重list（x） 转换列表tuple（x） 转换元组set（x） 转换集合3.6运算符：+合并\t*复制【1，2】2 &#x3D;【1，2，1，2】4.4return返回值函数一旦执行return后面代码不会再执行4.7global修改全局变量num&#x3D;10def （）：global num4.8不定长参数元组型不定长参数args 接收任意数量def func（*args）字典型不定长参数 **kwargsdef func（name，*kwargs）形参name不会被包装在字典里func（name&#x3D;“mike”，city&#x3D;‘sz’，age&#x3D;18）5.1组包和拆包：条件：变量数&#x3D;容器长度支持元组、列表、字典拆包5.2引用：查看引用：print（id（a））引用地址相同，说明指向同一个内存空间只要每运行一次程序，那么它的地址就会改变5.3可变与不可变类型可变类型：列表list\t集合set\t字典dict不可变类型：字符串str\t元组type 数值类型 int\tbool float5.4range创建整数列表对象 一般用在for循环用法与切片用法一样 range（1，5）\t[1，5)\t1-4列表推倒式: [结果 for 变量 in 可迭代对象 if 条件筛选]生成器表达式: (结果 for 变量 in 可迭代对象 if 条件筛选), 没有元组推倒式字典推倒式: {结果(k:v) for 变量 in 可迭代对象 if 条件筛选}集合推倒式: {结果(k) for 变量 in 可迭代对象 if 条件筛选} 自带去重功能5.5列表推导式每循环一次，将结果添加到列表中计算公式可以使用遍历出的数据for遍历出的数据必须满足if 判断，才会使用计算公式生成元素优点：不会将所有的值一次性加载到内存中，延迟计算，对大数据处理非常有用生成器可以使用yield关键字编写，也可以使用生成器表达式把【】改成（）5.6匿名函数lambda 【形参1】【形参2】：【单行表达式】or【函数调用】匿名函数不能使用while循环，for循环，只能编写单行表达式，或者函数调用不需要return 自动返回结果#无参有返回值：（）就是函数名字ret &#x3D;（lambda：1+1）（）print（ret）起函数名字：func &#x3D; lambda：1+1ret &#x3D; func（）print（ret）#有参有返回值ret &#x3D; （lambda a,b : a-b）(30,10)print(ret)func &#x3D;lambda a,b :a-bret &#x3D; func(30,10)print(ret)5.7递归函数函数内部调用自身一定要有出口def func(n):ret &#x3D; nfunc(n-1)return\tret_ret &#x3D; func(3)print(_ret)5.8\tenumerate delfor 配合enumerate 遍历容器时可以获得元素索引del删除列表元素del list[1]5.9文件版学生名片管理系统str（）eval（）（返回传入字符串内容结果，字符串里面看到像是什么，就转换成什么）6.1 文件打开与关闭只读：r \t写入: w格式：with open(‘123.txt , ‘’w’)as f:\t\t\t\tpass6.2写数据：\n"}]