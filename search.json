[{"url":"/2025/09/11/Ubuntu/vim%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%A6/","content":"取消vim末行模式下的数字\n全选（高亮显示）：按esc后，然后ggvG或者ggVG\n全部复制：按esc后，然后ggyG\n全部删除：按esc后，然后dG\nvim命令行模式下输入  ：set nu　　取消显示：在vim命令行模式下输入：  set nonu插入内容：\n　　　　i: 插入光标前一个字符\n　　　　I: 插入行首\n　　　　a: 插入光标后一个字符\n　　　　A: 插入行未\n　　　　o: 向下新开一行,插入行首\n　　　　O: 向上新开一行,插入行首\n　　移动光标:\n　　　　 h: 左移\n　　　　j: 下移 \n　　　　k: 上移 \n　　　　l: 右移\n　　　　M: 光标移动到屏幕中间行 \n　　　　L: 光标移动到屏幕最后一行行首 \n　　　　G: 移动到指定行,行号 -G\n　　　　w: 向后一次移动一个字 \n　　　　b: 向前一次移动一个字\n　　　　{: 按段移动,上移 \n　　　　}: 按段移动,下移\n　　　　Ctrl+d: 向下翻半屏 \n　　　　Ctrl+u: 向上翻半屏\n　　　　Ctrl+f: 向下翻一屏 \n　　　　Ctrl+b: 向上翻一屏\n　　　　gg: 光标移动文件开头 \n　　　　G: 光标移动到文件末尾\n　      删除命令:\n　　　　x: 删除光标后一个字符,相当于 Del \n　　　　X: 删除光标前一个字符,相当于 Backspace\n　　　　dd: 删除光标所在行,n dd 删除指定的行数 \n　　　　D: 删除光标后本行所有内容,包含光标所在字符 \n　　　　d0: 删除光标前本行所有内容,不包含光标所在字符\n　　　　dw: 删除光标开始位置的字,包含光标所在字符\n　　撤销命令:\n　　　　u: 一步一步撤销\n　　　 Ctrl+r: 反撤销\n　　重复命令:\n　　　　.: 重复上一次操作的命令\n　　文本行移动:\n　　       &gt;&gt;: 文本行右移 \n　　　   &lt;&lt;: 文本行左移　　  \n 复制粘贴:\n\n　　　　yy: 复制当前行,n yy 复制 n 行\n　　　　p: 在光标所在位置向下新开辟一行,粘贴\n　　可视模式:\n　　　　v: 按字符移动,选中文本 \n　　　V: 按行移动,选中文本可视模式可以配合 d, y, &gt;&gt;, &lt;&lt; 实现对文本块的删除,复制,左右移动\n　　替换操作:\n　　　　r: 替换当前字符 \n　　　　R: 替换当前行光标后的字符\n　　查找命令:\n　　　　&#x2F;: str查找　　　　n: 下一个　　　　N：上一个\n替换命令(并不常用)：\n　　　　把abc全部替换成123:     末行模式下，将当前文件中的所有abc替换成123　　:%s&#x2F;abc&#x2F;123&#x2F;g\n　　　　末行模式下，将第一行至第10行之间的abc替换成123    :1, 10s&#x2F;abc&#x2F;123&#x2F;g\n"},{"url":"/2025/09/11/conda/conda%20%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%85%A5/","content":"联网复制1.导出已有环境激活环境env_name(环境名称)\nconda activate env_name导出环境\nconda env export –file env_name.yml将env_name.yml复制到另一台机器上，导入\nconda env create -f env_name.yml复制到环境仅包含原来环境中使用conda install 安装的包。2. 导入pip安装的包(需进入虚拟机环境)导出安装库(源机器)\npip freeze &gt; requirements.txt导入安装库(目标机器)\npip install -r requirements.txt离线环境将envs目录下的env_name(环境名称)文件夹复制到目标机器上通过以下命令导入conda create -n env_name –clone .&#x2F;env_name –offline若显示以下结果，则表示导入成功conda虚拟环境复制_第1张图片\n"},{"url":"/2025/09/11/conda/conda%20%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%85%A52/","content":"conda本身的命令里是有移植这个选项的。假如前提是，在本地的conda里已经有一个AAA的环境，我想创建一个新环境跟它一模一样的叫BBB，那么这样一句就搞定了：\nconda create -n BBB –clone AAA1但是如果是跨计算机呢。\n其实是一样的。\n查询conda create命令的原来说明，是这样的：\n–clone ENVPath to (or name of) existing local environment.12–clone这个参数后面的不仅可以是环境的名字，也可以是环境的路径。\n所以，很自然地，我们可以把原来电脑上目标conda环境的目录复制到新电脑上，然后再用：\nconda create -n BBB –clone ~&#x2F;path1就直接一步安装了所有的包，完成了环境的移植。原来的电脑上的环境的地址可以用conda info -e 查询到。\n但是注意有个小的问题：移植过来的环境只是安装了你原来环境里用conda install等命令直接安装的包，你用pip之类装的东西没有移植过来，需要你重新安装。\n在服务器上想要使用别人搭好的环境，但是又怕自己对环境的修改更新会影响他人的使用，这个时候可以使用conda命令进行复制环境。首先假设已经安装了Anaconda。\n根据已有环境名复制生成新的环境假设已有环境名为A，需要生成的环境名为B：\nconda create -n B –clone A1根据已有环境路径复制生成新的环境假设已有环境路径为D:\\A，需要生成的新的环境名为B：\nconda create -n B –clone D:\\A1生成的新的环境的位置在anaconda的安装路径下，一般情况在D:\\Anaconda3\\envs\\文件夹下。\n"},{"url":"/2025/09/11/conda/conda%20%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%85%A53/","content":"虚拟环境配置统一虚拟环境，适用于python等高级语言环境隔离做人工智能，深度挖掘时会用到dokcer 里嵌套安装conda2、更新包管理镜像源：\nconda config –add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config –set show_channel_urls yes\n3、更新所有包：conda update –all\n4、安装包：conda install xxx，更新包：conda update xxx，删除包：conda remove，已安装包列表：conda list\n5、创建环境：conda create -n env_name list of packages，list of packages 是要安装在环境中的包的列表\n6、创建特定版本python的环境：conda create -n py3 python&#x3D;3 或 conda create -n py2 python&#x3D;2 或 conda create -n py33 python&#x3D;3.3conda create –prefix&#x3D;”D:\\my_python\\envs\\my_py_env”  python&#x3D;3.6.3\n7、进入环境：activate my_env，离开deactivate\n8、删除环境：conda env remove -n env_name\n9、列出环境：conda env list\n10、导出环境：conda env export &gt; environment.yaml，通过环境文件创建环境：conda env create -f environment.yaml\n"},{"url":"/2025/09/11/conda/conda/","content":"查看虚拟环境 conda info -e\n2019-05-16 update: 这个道理跟家里的电视机是一样一样的，安装conda就相当于买了一台电视机，但是有电视了不意味着你就能看节目了，你要手动添加频道才能看你想看的电视节目。官方channel: (先不要急着添加这两个哦,只要添加下面的清华的4个镜像地址就足够了的)：\nconda config –add channels biocondaconda config –add channels conda-forge官方的话这两个channel应该就够了的。\n2020-06-14 update：但是其实现在用国内的镜像比较多，官方的频道相较而言速度较慢。但也不是绝对的，有小伙伴跟我说他使用官方的频道也很流畅，所以见仁见智啦。另外，不建议加入大量的相同的频道，如添加了官方的bioconda之后又添加清华的bioconda镜像，没有必要，而且会拖慢速度。\n2019-06-12 update：最近在装raxml-ng的时候发现了一个新的channel叫genomedk，各位也可以添加到condarc里去 👇\n这个频道有的时候会引起网络错误, 网络不稳定的朋友不建议加.conda config –add channels genomedk顺便安利一个我hoptop学长的教程：如何搭建一个本地的conda镜像（包含bioconda）供各位爱折腾的高端玩家。2019-06-17 update: 清华恢复了conda 的镜像了！详情请看下面：Anaconda 镜像即将恢复借花献佛给大家复习一遍如何添加清华的镜像channels: 来源 → 生信媛: 喜大普奔: Anaconda的清华镜像又可以用了\nconda config –add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config –add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config –add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/conda config –add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/2020-06-14 update: 为了分担清华源镜像的压力，最近北京外国语大学也开启了镜像站点，同样是由清华TUNA团队维护的，如果有小伙伴遇到清华源速度很慢的情况的话，可以考虑换成北外的镜像。新闻传送门：https://mirrors.tuna.tsinghua.edu.cn/news/bfsu-mirror/镜像传送门：https://mirrors.bfsu.edu.cn/help/anaconda/2020-08-05 update: 为了方便大家(当然主要是自己偷懒用), 把北外的链接也给写出来, 这样就可以直接复制粘贴了当然两者取其一就可以了, 不用重复添加.另外, 我查看了中科大的镜像https://mirrors.ustc.edu.cn/anaconda, 点击这个地址会直接跳转到清华tuna的镜像站点. 所以目前看起来国内是只有清华和北外两个镜像站点可用了如果有小伙伴知道还有别的镜像可以用的话欢迎在下面留言或者私信我鸭!\nconda config –add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/bioconda/conda config –add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/conda-forge/conda config –add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/free/conda config –add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/main/下面这个我没用过, 但是看起来像是R的频道, 可以添加一下试试看.conda config –add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/r/如果你需要其他的更多的频道,请访问这个地址👉: https://mirrors.bfsu.edu.cn/help/anaconda/ 里面有详细的指导哒\n2020-08-10 update: 在生信技能树的群里由群友@合肥-生信-gzcdo 提供了两个新的conda的国内镜像源\nhttps://mirrors.nju.edu.cn/anaconda/https://mirrors.sjtug.sjtu.edu.cn/anaconda/\n各位朋友也可以试试看这两个镜像呀!~\n显示安装的频道\n conda config –set show_channel_urls yes查看已经添加的channels\nconda config –get channels已添加的channel在哪里查看\nvim ~&#x2F;.condarc利用conda安装生物信息软件安装命令: conda install gatk搜索需要的安装包:提供一个网址,用于事先查找想安装的软件存不存在conda available packages2020-06-14 update: 链接已挂，请选择用下面的conda search命令或者开头提供的更新的网址当然, 也可以用这个命令进行搜索（会稍微慢一点）\n conda search gatk安装完成后，可以用“which 软件名”来查看该软件安装的位置：\n which gatk如需要安装特定的版本:conda install 软件名&#x3D;版本号conda install gatk&#x3D;3.7这时conda会先卸载已安装版本，然后重新安装指定版本。\n查看已安装软件:\nconda list更新指定软件:\nconda update gatk卸载指定软件:\nconda remove gatk退出conda环境退出也很简单，之前我们是. .&#x2F;activate 或者 (. ~&#x2F;miniconda3&#x2F;bin&#x2F;activate)现在退出只要:\n. .&#x2F;deactivate\n或者用conda deactivate就退出当前的环境了\n创建软件的软链接（非必须步骤）跟着命令一路敲到这里的小旁友们估计发现了，现在退出conda环境之后之前安装的软件全都GG了，敲命令没法执行了！怎么办呢！其实只要把安装好的软件软连接到一个处在环境变量里的位置就可以使用了。三步走：\n第一步，创建一个文件夹我一般的习惯是在&#x2F;home目录下创建一个.soft文件夹第二步，将这个文件夹添加到环境变量中export PATH&#x3D;”&#x2F;.soft:$PATH”第三步，软链接ln -s ~&#x2F;miniconda3&#x2F;bin&#x2F;gatk ~&#x2F;.soft这样就可以运行啦如果还是不行建议试试初始化一下bashrc：. .&#x2F;bashrc\n创建conda环境（常用步骤，强烈推荐）之前创建的时候显示的是（base）这是conda的基本环境，有些软件依赖的是python2的版本，当你还是使用你的base的时候你的base里的python会被自动降级，有可能会引发别的软件的报错，所以，可以给一些特别的软件一些特别的关照，比如创建一个单独的环境。在conda环境下，输入conda env list（或者输入conda info –envs也是一样滴）查看当前存在的环境：\nconda env list\n这是我相当常用的一条命令了，建议记一记目前的环境\n目前只有一个base\nconda create -n python2 python&#x3D;2\n-n: 设置新的环境的名字python&#x3D;2 指定新环境的python的版本，非必须参数这里也可以用一个-y参数，可以直接跳过安装的确认过程。conda会创建一个新的python2的环境，并且会很温馨的提示你只要输入conda activate python2就可以启动这个环境了\n新的环境退出环境如上面的截图提到的，只要\nconda deactivate2019-6-28 update: 如何删除和重命名一个已存在的环境\n删除环境删除也很容易的\nconda remove -n myenv –all就可以退出当前环境。掌握了创建和删除我们就可以实现重命名的操作了\n重命名环境实际上conda并没有提供这样的功能，但是可以曲线救国，原理是先克隆一个原来的环境，命名成想要的名字，再把原来的环境删掉即可参考自：conda 创建&#x2F;删除&#x2F;重命名 环境接下来演示把一个原来叫做py2的环境重新命名成python2：\nconda create -n python2 –clone py2conda remove -n py2 –all骚操作：allias简化启动（非必须步骤）image.png\nlinux提供了一个给大家偷懒的命令叫alias，只要在你的.bashrc里设置一下就好了，我添加了一条叫做condaup的命令，这样就可以免去每次敲. &#x2F;miniconda&#x2F;bin&#x2F;dactivate的麻烦，一步搞定技术宅改变世界！image.png报错信息集锦2020-08-06 update: 我最近用conda总是发生一些奇怪的问题, 所以想把报错的信息及解决方式给收集整理一下.\n报错1: 网络错误\nCollecting package metadata (current_repodata.json): failed\nCondaHTTPError: HTTP 000 CONNECTION FAILED for url https://conda.anaconda.org/genomedk/linux-64/current_repodata.jsonElapsed: -\nAn HTTP error occurred when trying to retrieve this URL.HTTP errors are often intermittent, and a simple retry will get you on your way.u’https://conda.anaconda.org/genomedk/linux-64‘一般这种问题就只要重新运行一下上一条命令就可以了. 有的时候网络不稳定而已.\n"},{"url":"/2025/09/11/conda/conda%E5%90%AF%E5%8A%A8%E6%8F%92%E4%BB%B6%E5%91%BD%E4%BB%A4/","content":"redis 启动redis-server.exe\n绑定端口号redis-cli.exe -h 127.0.0.1 -p 6379\n"},{"url":"/2025/09/11/conda/conda%E5%BF%85%E8%A6%81%E6%93%8D%E4%BD%9C/","content":"进入虚拟环境 source activate env_name \n安装命令: conda install pytest搜索 conda search pytest安装完成后，可以用“which 软件名”来查看该软件安装的位置： which gatk如需要安装特定的版本:conda install 软件名&#x3D;版本号conda install gatk&#x3D;3.7\n查看已安装软件:conda list\n更新指定软件:conda update gatk\n卸载指定软件:conda remove gatk\n退出conda环境. .&#x2F;deactivate\n或者用conda deactivate\n重命名环境conda create -n python2 –clone py2conda remove -n py2 –all\n"},{"url":"/2025/09/11/conda/requirements.txt%20%20%E7%8E%AF%E5%A2%83%E8%8E%B7%E5%8F%96%EF%BC%88%E5%AF%BC%E5%87%BA%EF%BC%89/","content":"导出 \npip freeze &gt; requirements.txt\n导入 \npip install -r requirements.txt\n"},{"url":"/2025/09/11/dokcer/docker%20%E5%88%9B%E5%BB%BA/","content":"docker run -itd –name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;1548324254 mysql&#x2F;mysql-server\ndocker run -p 3306:3306 –name mysql ^-v &#x2F;d&#x2F;mysql&#x2F;docker-mysql&#x2F;conf:&#x2F;etc&#x2F;mysql ^-v &#x2F;d&#x2F;mysql&#x2F;docker-mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql ^-v &#x2F;d&#x2F;mysql&#x2F;docker-mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql ^-e MYSQL_ROOT_PASSWORD&#x3D;1548324254 ^-d mysql&#x2F;mysql-server\n\n拉取镜像docker pull mysql:5.7创建容器并映射路径docker run -p 3306:3306 –name mysql ^-v &#x2F;e&#x2F;mysql&#x2F;docker-mysql&#x2F;conf:&#x2F;etc&#x2F;mysql ^-v &#x2F;e&#x2F;mysql&#x2F;docker-mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql ^-v &#x2F;e&#x2F;mysql&#x2F;docker-mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql ^-e MYSQL_ROOT_PASSWORD&#x3D;123456 ^-d mysql:5.7\n^为win cmd 中的换行符   -v宿主机路径：mysql路径&#x2F;e&#x2F;mysql&#x2F;docker-mysql&#x2F;conf 路径代表win中 E:\\mysql\\docker-mysql\\confMYSQL_ROOT_PASSWORD&#x3D;123456  代表root密码\nlinux中路径映射为：\nsudo docker run -p 3306:3306 –name mysql -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:5.7\n进入容器，进入mysql ，修改远程访问权限docker exec -it mysql bash   进入容器mysql -u root -p    进入mysqlGRANT ALL PRIVILEGES ON . TO ‘root‘@’%’ IDENTIFIED BY ‘123456’ WITH GRANT OPTION;flush privileges;   刷新权限exit 退出mysql  exit  退出容器宿主机连接mysql\nDocker常用命令新建容器\ndocker run -d –name 自定义容器名 镜像ID或镜像名展示当前运行的容器\ndocker ps展示所有容器\ndocker ps -a展示所有本地镜像\ndocker images运行容器\ndocker start 容器名或容器ID停止运行容器\ndocker stop 容器名或容器ID删除容器\ndocker rm -f 容器名或容器ID进入容器内容bash\ndocker exec -it 容器名或容器ID bash#退出容器命令:exit查看容器ip\ndocker inspect 容器名或id关闭docker服务\nsystemctl stop docker关闭docker服务\ndocker inspect mycentos3重要  重要  重要在win上别忘了加路径：\n"},{"url":"/2025/09/11/dokcer/docker%E4%BB%93%E5%BA%93/","content":"本地的镜像推送到DockerHub上，这里的xianhu要和登录时的username一致：[root@xxx ~]# docker push xianhu&#x2F;centos:git    # 成功推送[root@xxx ~]# docker push xxx&#x2F;centos:git    # 失败The push refers to a repository [docker.io&#x2F;xxx&#x2F;centos]unauthorized: authentication required\n以后别人就可以从你的仓库中下载合适的镜像了。\n[root@xxx ~]# docker pull xianhu&#x2F;centos:git\n创建容器之后做更改，之后commit生成镜像，然后push到仓库中。更新Dockerfile。在工作时一般建议这种方式，更简洁明了。\n创建一个用于Flask开发的Python环境，包含Git、Python3、Flask以及其他依赖包等。[root@xxx ~]# docker pull centos[root@xxx ~]# docker run -it centos:latest &#x2F;bin&#x2F;bash\n此时进入容器，安装Python3、Git、Flask及其依赖包等，安装完成后exit退出[root@xxx ~]# docker commit -m “Flask” -a “xianhu” container_id xianhu&#x2F;flask:v1[root@xxx ~]# docker push xianhu&#x2F;flask:v1\n作者：笑虎链接：https://zhuanlan.zhihu.com/p/23599229来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n"},{"url":"/2025/09/11/dokcer/%E5%88%A9%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/","content":"说明该镜像以哪个镜像为基础FROM centos:latest\n构建者的基本信息MAINTAINER xianhu\n在build这个镜像时执行的操作RUN yum updateRUN yum install -y git\n拷贝本地文件到镜像中COPY .&#x2F;* &#x2F;usr&#x2F;share&#x2F;gitdir&#x2F;\n有了Dockerfile之后，就可以利用build命令构建镜像了：\n[root@xxx ~]# docker build -t&#x3D;”xianhu&#x2F;centos:gitdir” .\n上就是构建自己镜像的两种方法。其中也涉及到了容器的一些操作。如果想删除容器或者镜像，可以使用rm命令，注意：删除镜像前必须先删除以此镜像为基础的容器。[root@xxx ~]# docker rm container_name&#x2F;container_id[root@xxx ~]# docker rmi image_name&#x2F;image_id\n[root@xxx ~]# docker save -o centos.tar xianhu&#x2F;centos:git    # 保存镜像, -o也可以是–output[root@xxx ~]# docker load -i centos.tar    # 加载镜像, -i也可以是–input\n作者：笑虎链接：https://zhuanlan.zhihu.com/p/23599229来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n"},{"url":"/2025/09/11/dokcer/docker%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E5%8F%82%E6%95%B0/","content":"端口映射:P :随机映射 p:指定映射-P 创建  端口映射POTRTSp 0.0.0.0：32768——》80/tcp\t\t== 宿主机（Ubuntu）端口-》容器端口\nhost模式：容器和宿主机共享网络直接采用宿主机的网络，不是单独分配--network=host\n"},{"url":"/2025/09/11/dokcer/%E5%91%BD%E4%BB%A4/","content":"[root@xxx ~]# docker search centos    # 查看centos镜像是否存在[root@xxx ~]# docker pull centos    # 利用pull命令获取镜像\ndocker images    # 查看当前系统中的images信息\ndocker run -it centos:latest &#x2F;bin&#x2F;bash # 启动一个容器git –version    # 此时的容器中没有gitbash: git: command not found\nyum install git    # 利用yum安装git\n#运行容器docker run -itd –name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 mysql\ngit –version   # 此时的容器中已经装有git了git version 1.8.3.1\ndocker ps -a\n这里将容器转化为一个镜像，即执行commit操作，完成后可使用docker images查看docker commit -m “centos with git” -a “qixianhu” 72f1a8a0e394 xianhu&#x2F;centos:git\n"},{"url":"/2025/09/11/dokcer/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"启动[root@xxx ~]# docker run -it centos:latest &#x2F;bin&#x2F;bash这里-it是两个参数：-i和-t。前者表示打开并保持stdout，后者表示分配一个终端（pseudo-tty）。此时如果使用exit退出，则容器的状态处于Exit，而不是后台运行。如果想让容器一直运行，而不是停止，可以使用快捷键 ctrl+p ctrl+q 退出，此时容器的状态为Up。除了这两个参数之外，run命令还有很多其他参数。其中比较有用的是-d后台运行：[root@xxx ~]# docker run centos:latest &#x2F;bin&#x2F;bash -c “while true; do echo hello; sleep 1; done”[root@xxx ~]# docker run -d centos:latest &#x2F;bin&#x2F;bash -c “while true; do echo hello; sleep 1; done”\n启动、停止、重启容器命令：[root@xxx ~]# docker start container_name&#x2F;container_id[root@xxx ~]# docker stop container_name&#x2F;container_id[root@xxx ~]# docker restart container_name&#x2F;container_id\n后台启动一个容器后，如果想进入到这个容器，可以使用attach命令：[root@xxx ~]# docker attach container_name&#x2F;container_id\n删除：[root@xxx ~]# docker rm container_name&#x2F;container_id\n"},{"url":"/2025/09/11/dokcer/%E7%82%BC%E4%B8%B9%E6%9C%AF%E5%A3%AB/","content":"一般炼丹都在服务器上，很少有人在本机跑代码的。之前自己捣鼓怎么用本地的编辑器配上远程服务器的环境来营造一个最舒乎的姿势。最开始用VS Code的SFTP插件，但是用着还是不顺手，因为不能用远程的环境，最后还是选择了强大的PyCharm。下面的这个教程最开始只是自己用，后来写了一篇博客分享给实验室的人，没想到大家都开始用上了。这次专门写一篇更详细的放到知乎供有缘人使用。开始之前你可以对比以下条件来确定自己是否真的需要这样做：使用PyCharm作为主力IDE写Python而不是其他（我非常推荐大家用）深度学习炼丹师（当然你可以不是，但如果是，你会更舒服）服务器在远程或者局域网（局域网的体验最佳）使用Docker（能够熟练使用最佳）当你配置完成之后，你将能在本地PyCharm IDE上使用远程服务器的Python解释器和环境进行调试和运行，同时能够很方便的将代码在本地和服务器上进行同步。OK，废话不多说，正式开始我们的PyCharm+Docker的远程环境配置之旅。首先你需要满足以下两个必备条件：使用PyCharm专业版，记住一定是专业版（社区版不提供远程服务）在服务器上安装docker和nvidia-docker1. 新建docker container首先按照如下命令新建一个docker容器（关于docker的使用这里不废话，建议不熟悉的童鞋先去学一下如何使用docker，教程很多）：sudo nvidia-docker run -it -p [host_port]:[container_port](do not use 8888) –name:[container_name] [image_name] -v [container_path]:[host_path] &#x2F;bin&#x2F;bash举个栗子：sudo nvidia-docker run -p 5592:5592 -p 5593:5593 -p 8022:22 –name&#x3D;”liuzhen_tf” -v ~&#x2F;workspace&#x2F;liuzhen&#x2F;remote_workspace:&#x2F;workspace&#x2F;liuzhen&#x2F;remote_workspace -it tensorflow&#x2F;tensorflow:latest-gpu &#x2F;bin&#x2F;bash正确执行完之后，现在我们就处在新建的docker容器里了（端口映射，容器名，镜像和路径映射这些换成你自己的就行，但是一定要留一个端口映射到容器22端口，因为SFTP默认使用22端口）。2. 配置SSH服务接着我们在刚刚新建的容器里配置SSH服务，首先安装openssh-server:$ apt update$ apt install -y openssh-server然后建立一个配置文件夹并进行必要的配置：$ mkdir &#x2F;var&#x2F;run&#x2F;sshd$ echo ‘root:passwd’ | chpasswd\n这里使用你自己想设置的用户名和密码，但是一定要记住！$ sed -i ‘s&#x2F;PermitRootLogin prohibit-password&#x2F;PermitRootLogin yes&#x2F;‘ &#x2F;etc&#x2F;ssh&#x2F;sshd_config$ sed ‘s@session\\srequired\\spam_loginuid.so@session optional pam_loginuid.so@g’ -i &#x2F;etc&#x2F;pam.d&#x2F;sshd$ echo “export VISIBLE&#x3D;now” &gt;&gt; &#x2F;etc&#x2F;profile重启SSH激活配置：$ service ssh restart在服务器（宿主机）上（不是服务器的docker里）测试刚刚新建docker容器中哪个端口转发到了服务器的22端口：$ sudo docker port [your_container_name] 22\n如果前面的配置生效了，你会看到如下输出0.0.0.0:8022最后测试能否用SSH连接到远程docker：$ ssh root@[your_host_ip] -p 8022密码是你前面自己设置的到这里说明服务器的docker端已经完成配置。3. 在PyCharm里配置部署环境打开PyCharmTools &gt; Deployment &gt; Configuration, 新建一个SFTP服务器，名字自己取：输入如下图配置，注意这里的端口是你刚刚设置的映射到容器22端口的宿主机中的端口，我这里使用的是8022，账号密码是你刚刚自己设置的，这里的Root Path设置一个远程docker容器里的路径:配置完点击Test SFTP connection,如果成功就恭喜你，可以进行下一步了。最后在Mappings中配置路径，这里的路径是你本地存放代码的路径，与刚刚配置的Root Path相互映射（意思是Mapping里本机的路径映射到远程的Root Path），方便以后在本地和远程docker中进行代码和其他文件同步。4. 在PyCharm里配置远程解释器点击PyCharm的File &gt; Setting &gt; Project &gt; Project Interpreter右边的设置按钮新建一个项目的远程解释器：配置完成以后在项目解释器界面就会出现如下图所示，可以看到此时已经完成远程解释器的本地化：配置完成以后需要等本地和远程的环境同步一下，到这里，恭喜你，可以用最舒服的姿势。。。写代码了。配置完成以后的日常是这样的：左边是本地的文件，修改之后可以随时右键deployment-&gt;upload到远程主机，或者直接在本地调试运行；最右边是远程主机的文件，假如直接在远程修改了文件刷新一下同样可以右键下载到本地，但是我不建议这样做，因为这样很容易带来冲突（毕竟没有很好的版本控制）。目前最好的实践是在局域网的服务器上，时延低，同步速度快。常见问题：最常见的问题就是docker容器停了以后里面的SSH服务也会相应停止，因此当你发现自己某一天连不上的时候，记得去docker里重启一下ssh服务：$ service ssh restart感谢 @丁果 对这个问题提出的解决方案：“可以在run的时候加上–restart&#x3D;always，同时ssh启动的写到dockerfile里去。”2. 在容器中执行apt update的时候可能会出现0% working 的问题"},{"url":"/2025/09/11/flask/Flask%E5%9F%BA%E7%A1%80/","content":"App 等于整个项目\nflask 的request 的是从包导入，是全局变量。怎么区分？原理：线程控制，通过线程id来区分\nrequest.remote_userrequest.remote_addr\nrequest获取方法# 类型声明mydict = None  # type:dict# mydict.update()# mydict.get()@app.route(&#x27;/user&#x27;, methods=[&quot;get&quot;, &quot;post&quot;])def hello_world():    # ==========[request基础属性]=============    # 请求url地址    # print(request.url)    # 发送请求的用户和ip    # print(request.remote_user)    # print(request.remote_addr)    # 请求的方法    # 大写的字符串    # print(request.method)    # 请求头信息-字典    # print(request.headers)    # print(request.headers[&quot;Host&quot;])    # print(request.headers.get(&quot;Host&quot;, &quot;默认值&quot;))    # ==============[request获取请求参数]====================    # 1.提取路径参数    # 127.0.0.1:5000/user_id/666    # 语法: &lt;转换器名称:变量名称&gt;    # 2.提取查询字符串参数    # 127.0.0.1:5000/user/?name=xiaoming&amp;age=18   [get]    # 语法：request.args  类型：字典    # params_dict = request.args    # print(params_dict.get(&quot;name&quot;))    # print(params_dict.get(&quot;age&quot;))    # 3.提取请求体参数    # 127.0.0.1:5000/user  请求体字典：&#123;&quot;name&quot;: &quot;james&quot;, &quot;age&quot;: 35&#125;  [post]    # 语法：request.form    # params_dict = request.form    # print(params_dict.get(&quot;name&quot;))    # print(params_dict.get(&quot;age&quot;))    # 4.原始bytes类型参数 [了解]    # 语法：request.data    # print(request.data)    # 5.提取json字符串参数    # 127.0.0.1:5000/user/   请求体json字符串：&#123;&quot;name&quot;: &quot;kobe&quot;, &quot;age&quot;: 43&#125;    # 语法：request.json    # 底层已经将json字符串转换成字典    # params_dict = request.json    # print(params_dict.get(&quot;name&quot;))    # print(params_dict.get(&quot;age&quot;))    # 6.提取文件类型的参数    # 127.0.0.1:5000/user/   &#123;&quot;img&quot;: &quot;文件数据&quot;&#125;    # 语法：request.files    file = request.files.get(&quot;img&quot;)  # type:FileStorage    # 读取二进制文件数据    # 注意：一旦读取完毕 数据被清空了    # print(file.read())    # 保存图片到本地    # TODO: 图片存储到云平台    file.save(&quot;./2.png&quot;)    return &#x27;Hello World!&#x27;@app.route(&#x27;/index&#x27;)def index():    return &#x27;index page&#x27;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n导包# 1.导包\tfrom flask import Flask  # 2.创建flask应用对象app\tapp = Flask(__name__)  # 3.自定义视图函数绑定路由信息\t@app.route(&#x27;/&#x27;)\tdef index():    \treturn &#x27;Hello World&#x27; # 4.运行flask应用程序\t\t app.run()  # 查看路由信息属性：app.url_map\n3.flask 初始化参数1. __name__（重点必传）认为当前文件所有在目录就是项目目录，会在这个目录下寻找静态文件路径（图片，js,css），模板文件路径(html)2. static_ul_path静态文件访问路径前缀，，默认为：/static/文件名称3. static_folder(可以不传,知道作用就好):静态文件存储的文件夹，，默认为 static4.template_folder模板文件存储的文件夹，可以不传，默认为 templates\n1-app.run()的参数&amp;配置信息读取# Flask旧版本的运行方式\t通过修改app.run()函数的host，port参数，指定运行的ip地址和端口号。# 读取配置信息\tapp.config.get(key)app.config(&quot;key&quot;)\n2-Flask新版本(1.x)运行方案–终端运行\n总结：#0.代码中可以省略：app.run() 这行代码#1.使用环境变量的形式指明那个文件需要被运行export FLASK_APP=flask文件名称 #3.设置运行模式：(非必须,可以不指明，默认是production生产模块）export FLASK_ENV=production  运行在生产模式，未指明则默认为此方式export FLASK_ENV=development 运行在开发模式 默认开启debug模式#2.使用命令启动：默认运行在127.0.0.1:5000端口flask run   #2.1指明ip和端口flask run -h 0.0.0.0 -p 8000# 注意：FLASK_APP  FLASK_ENV  production development 固定写法 不能出错\n\n3.路由# 总结：(重点)1.修改@app.route(&#x27;路由地址&#x27;, methods=[&#x27;post&#x27;, &#x27;get&#x27;])的参数达到修改访问url：\t目的：不同的url引导到对应的视图函数1.1 查询路由和视图函数的绑定关系\t app.url_map 2.转换器：\t作用：提取路由url`路径`上面的参数\t语法：&lt;参数类型:形参&gt;注意：参数类型`暂时`理解成对应类型\n4-指定请求方式&amp;使用 PostMan 对请求进行测试# 总结：修改请求方式：\t我们可以根据需求修改对应的请求方式，完成不同的业务需求语法：app.route(路径,methods=[&quot;POST&quot;,&quot;GET&quot;])注意：methods是一个列表。请求方法大小写均可。\n6.返回JSON格式数据[重点]总结：当需要给客户端返回json类型的数据的时候，可以借助jsonify函数将python字典转换成json字符串语法格式：\tjsonify(字典)作用：\t1.将字典转换成json字符串\t2.将返回值包装成resonse对象\t3.将·数据类型·设置成application/json格式\n\n\n\n7-重定向# 总结：\t概念：当你访问某一url路由的时候，不是给你引导到当前url对应的网页而是跳转到了另一个url对应的网页。\t# 重定向函数：redirect(url地址)url_for(视图函数名称)\n\n\n\n8-自定义响应信息resp =make_response(响应体)resp.headers[key] = valueresp.set_cookie()resp.status_code = 200\n\n\n\n9-状态保持-cookie# 设置响应头的set_cookie字段  value必须是str/bytes类型\tresponse.set_cookie(&#x27;per_page&#x27;, &#x27;10&#x27;, max_age=86400)  # 本质是将max_age=0response.delete_cookie(&#x27;per_page&#x27;)# 直接获取到字典形式的cookie数据\trequest.cookies.get(&#x27;per_page&#x27;)\n\n\n\n10 状态保持 sessionfrom flask import sessionsession 本质不是全局变量，线程隔离，线程id区分# 注意：flask中使用session需要设置加密混淆字符串# 盐app.secret_key = &quot;saldhjhaldk(*i&quot;# 给flask中的session设置有效时长 [1天]# flask默认是：31天过期app.permanent_session_lifetime = timedelta(days=1)session[&quot;user_name&quot;] = &quot;laowang&quot;# 运行设置有效时长session.permanent = True# 删除session# session.pop(key) 删除一条# session.clear() 删除全部\n11-JWT12-异常处理abort(http错误状态码)# 捕获http错误@app.errorhandler(404)# 还可以捕获系统内置错误@app.errorhandler(ZeroDivisionError)\n\n\n\n\n\n请求钩子[重点]总结：1.当访问一路由：127.0.0.1：5000/  浏览器会发送一个请求给flask后端： request 2.当请求发送过来的时候有四个时机：\t1.第一次请求之前 before_first_request\t2.每次请求之前 before_request\t3.每次请求之后 after_request\t4.每次请求之后是否有错误 teardown_request\t@app.before_request     执行时机：每一次请求之前触发，视图函数执行之前触发    作用：拦截请求，封ip，token用户权限认证@app.before_first_request    执行时机：项目第一次启动就会触发，而且仅会执行一次    作用：项目初始化工作@app.after_request    执行时机：每次在视图函数执行完毕的时候触发[没有错误]，要接受一个响应对象    作用：拦截响应，设置cookie，设置响应状态码 响应头信息    @app.teardown_request    执行时机：每次在视图函数执行完毕后触发[无论是否有错误], 接受一个异常对象    作用：异常处理，收尾工作\n数据库配置：1. 用工厂方法在app下的__init__.py下创建链接\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2025/09/11/flask/Flask%E5%9F%BA%E7%A1%802/","content":"列表提取与元组提取注意点：如果是底层配置需求（有错需要警告的话）就用方法[‘’]提取，空就会报错如果是无关大雅的外层需求，可以用get.(‘’)来提取，空也不会报错\n蓝图（注意避免循环导包）from flask import Blueprint, url_for# 1.创建蓝图对象home_bp = Blueprint(&quot;hone&quot;, __name__, url_prefix = &#x27;/home&#x27;)# 在蓝图中使用钩子函数[作用域：整个home模块]@home_bp.before_requestdef process_request():\tprint (&quot;before_request调用了&quot;)from .views import *\n\n\n\n上下文(数据容器)1.请求上下文:request, sessiondef hello_world():    # =======[请求上下文]==========    print(request.url)    session[&quot;username&quot;] = &quot;xiaoming&quot;    print(session.get(&quot;username&quot;))2.应用上下文:current_app    # ========[应用上下文]============    # current_app == app 当前运行的app    # 别的模块不方便导入app，够不着app的时候可以current_app    print(app.config.get(&quot;JSON_AS_ASCII&quot;))    print(app.config.get(&quot;SECRET_KEY&quot;))    print(current_app.config.get(&quot;JSON_AS_ASCII&quot;))    print(current_app.config.get(&quot;SECRET_KEY&quot;))理解：1.上下文不是全局变量，web是并发调用，全局变量是线程共享2.上下文是线程隔离（LocalStack类型, 本质是字典）# 问题在Flask程序未运行的情况下，调试代码时需要使用current_app、g、request这些对象，会不会有问题？该如何使用？# 解决方案\t \t手动开启应用上下文 【重点】     with app.app_context():            current_app            手动开启请求上下文    with app.request_context(environ):      # 模拟解析客户端请求之后的wsgi字典数据    environ = &#123;&#x27;wsgi.version&#x27;:(1,0), &#x27;wsgi.input&#x27;: &#x27;&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;, &#x27;PATH_INFO&#x27;: &#x27;/&#x27;, &#x27;SERVER_NAME&#x27;: &#x27;itcast server&#x27;, &#x27;wsgi.url_scheme&#x27;: &#x27;http&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;&#125; \n\n\n\ng对象与请求钩子的综合案例# 需求：构建用户身份认证机制# 1.每次进入视图函数之前对用户身份进行认证(jwt session cookie)，将用户信息保存到g对象中，方便在别的函数使用用户信息# 2.对于特定视图可以提供强制要求用户登录的限制# 分析    每次进入视图函数之前对用户身份进行认证，并保存用户信息 --&gt; 钩子函数    提供强制要求用户登录的限制 ---&gt; 装饰器   # 数据如何传递？\tg对象# 执行流程：发送请求 --&gt; 钩子函数(登录使用g变量保存用户信息，没有登录g变量保存None) --&gt; 视图函数发送请求 --&gt; 钩子函数 --&gt; 装饰器  --&gt; 视图函数 --&gt; 获取用户信息\n\n\ng对象与请求钩子\nfrom flask import Flask, session, g, requestimport functoolsapp = Flask(__name__)app.secret_key = &quot;alksdjalkdjlkas***&quot;# 需求：限制视图函数的访问权限# eg: 个人中心，评论，点赞接口必须先登录，才能访问视图函数# 方案：在钩子函数中统一提取用户信息，并且使用g变量存储，再将用户是否登录的业务逻辑代码封装到装饰器中[减少代码冗余]@app.before_requestdef get_userinfo():    # 注意：必须用get获取字典的键值对信息    g.user_id = session.get(&quot;user_id&quot;)    g.user_name = session.get(&quot;user_name&quot;)    # TODO:    # token = request.headers.get(&quot;token&quot;)    # token校验 -- payload -- 用户信息 -- 登录装饰器判断是否登录 -- 视图函数# 主动寻求装饰# app.before_request(get_userinfo)# 登录装饰器def login_required(view_func):    # 防止装饰器修改被装饰函数名和文档信息    @functools.wraps(view_func)    def wrapper(*args, **kwargs):        # 判断用户是否登录        if g.user_id and g.user_name:            # 进入视图函数            return view_func(*args, **kwargs)        else:            # 未登录            return &quot;invliad user&quot;, 401    return wrapper@app.route(&#x27;/login&#x27;)def login():    # 状态保持    session[&quot;user_id&quot;] = 66    session[&quot;user_name&quot;] = &quot;james&quot;    return &#x27;login success&#x27;@app.route(&#x27;/index&#x27;)def index():    # 提取用户信息    if g.user_id and g.user_name:        return &quot;欢迎回来：&#123;&#125; &quot;.format(g.user_name)    else:        return &#x27;&lt;a href=&quot;/login&quot;&gt;去登录&lt;/a&gt;&#x27;# 注意：装饰顺序 先构建请求，再判断是否有登录@app.route(&#x27;/profile&#x27;)@login_requireddef profile():    # 判断用户是否有登录    print(g.user_name)    return &quot;profile page&quot;@app.route(&#x27;/comment&#x27;)@login_requireddef comment():    # 判断用户是否有登录    print(g.user_name)    return &quot;profile page&quot;if __name__ == &#x27;__main__&#x27;:    app.run(debug=True, port=8000)\n工厂方法# 需求：将app创建封装到工厂方法中def create_app(config_name):    # 1.创建app    app = Flask(__name__)    # 2.读取配置类中的配置信息    config_class = config_dict[config_name]    app.config.from_object(config_class)    # 3.读取环境变量中私有配置信息    # 后加载的同名配置信息会覆盖之前的配置信息    app.config.from_envvar(&quot;CONFIG&quot;, silent=True)    # 4.返回app    return app# 开发模式下的app对象app = create_app(&quot;dev&quot;)\n\n配置文件\n# 使用面向对象的方式封装多套配置信息class BaseConfig(object):    &quot;&quot;&quot;    配置类基类    以类属性的方式添加配置信息    &quot;&quot;&quot;    DEBUG = True    SECRET_KEY = &quot;python666&quot;class DevelopmentConfig(BaseConfig):    &quot;&quot;&quot;开发阶段配置信息&quot;&quot;&quot;    DEBUG = True    # redis 配置信息 【自定义】    REDIS_HOST = &quot;127.0.0.1&quot;    REDIS_PORT = 6379class ProductionConfig(BaseConfig):    &quot;&quot;&quot;上线配置信息&quot;&quot;&quot;    # 减少io 减少服务器压力    DEBUG = False    # redis 配置信息 【自定义】    REDIS_HOST = &quot;192.168.1.3&quot;    REDIS_MASTER_PORT = 6379    REDIS_SLAVE_PORT = 6380class TestingConfig(BaseConfig):    &quot;&quot;&quot;测试配置信息&quot;&quot;&quot;    # 提示代码错误    Testing = True    # redis 配置信息    REDIS_HOST = &quot;127.0.0.1&quot;    REDIS_PORT = 6379# 暴露外界调用的接口config_dict = &#123;    &quot;dev&quot;: DevelopmentConfig,    &quot;pro&quot;: ProductionConfig,    &quot;test&quot;: TestingConfig&#125;\n\n\n单例设计模式class Singleton(object):    # 对象初始化    # def __init__(self):    #     pass    # cls == Singleton    def __new__(cls, *args, **kwargs):        # 第一次：cls上没有_instance 进入if判断创建对象        # 以后的每一次：cls上有instance 返回的是第一次创建的对象        if not hasattr(cls, &quot;_instance&quot;):            # 第一次类中没有_instance属性 进入if判断，创建对象，保存_instance属性中            # super(Singleton, cls).__new__(*args, **kwargs) 调用父类的__new__创建对象            # 动态属性赋值            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)        return cls._instance\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2025/09/11/flask/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/","content":"优化查询user.query.options(load_only(user.id))\n\n增加数据（增加数据主要需要三步操作）\n创建模型对象模型对象 &#x3D; 模型类(字段名&#x3D;字段值)将模型对象添加到会话中组件对象.session.add(模型对象)提交会话组件对象.session.commit()# 1.创建模型对象    user1 = User(name=&#x27;zs&#x27;, age=20)    # user1.name = &#x27;zs&#x27;    # user1.age = 20    # 2.将模型对象添加到会话中     db.session.add(user1)    # 添加多条记录    # db.session.add_all([user1, user2, user3])    # 3.提交会话 (会提交事务)    # sqlalchemy会自动创建隐式事务    # 事务失败会自动回滚    db.session.commit()    return &quot;index&quot;\n\n查询User.query.(查询方法)User.query.all()\n\n删除数据1. 先查询, 再删除2. 基于过滤条件的删除@app.route(&#x27;/del&#x27;)def delete():    &quot;&quot;&quot;删除数据&quot;&quot;&quot;    # 方式1: 先查后删除    goods = Goods.query.filter(Goods.name == &#x27;方便面&#x27;).first()    # 删除数据    db.session.delete(goods)    # 提交会话 增删改都要提交会话    db.session.commit()    return &quot;index&quot;\n方法二# 方式2: delete子查询Goods.query.filter(Goods.name == &#x27;方便面&#x27;).delete()# 提交会话db.session.commit()\n\n刷新数据Session 被设计为数据操作的执行者, 会先将操作产生的数据保存到内存中在执行 flush刷新操作 后, 数据操作才会同步到数据库中有两种情况下会 隐式执行刷新操作:提交会话执行查询操作 (包括 update 和 delete 子查询)开发者也可以 手动执行刷新操作 session.flush()\n执行迁移命令export FLASK_APP=hm_数据迁移.py  # 设置环境变量指定启动文件flask db init  # 生成迁移文件夹flask db migrate  # ⽣成迁移版本, 保存到迁移文件夹中flask db upgrade  # 执行迁移"},{"url":"/2025/09/11/flask/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/","content":"# app/__init__.py ...from flask_migrate import Migrate...def register_extensions(app):    &quot;&quot;&quot;组件初始化&quot;&quot;&quot;    ...    # 数据迁移组件初始化    Migrate(app, db)    # 导入模型类    from models import user\nWindows中没有这个命令，应该采用SET命令\n"},{"url":"/2025/09/11/flask/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","content":"导出虚拟环境所有的第三方包pip freeze &gt; requirements.txt\n一次性安装pip install -r requirements.txt  -i 源\n"},{"url":"/2025/09/11/flask/flask%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/","content":"1. 蓝图（注意避免循环导包）2. 工厂方法3. 单例设计模式4. 取消ascii（啊斯卡编码）# 在flask_restful中取消中文转换成ascii编码app.config[&quot;RESTFUL_JSON&quot;] = &#123;&quot;ensure_ascii&quot;: False&#125;# 在flask框架中app.config[&quot;JSON_AS_ASCII&quot;] = Flask\n所有装饰器装饰顺序为靠近函数的先执行内容执行顺序从上到下\n工厂模式链接数据库from flask import Flaskfrom settings import config_dictfrom flask_sqlalchemy import SQLAlchemy# 数据库的第二种创建方式：# 创建数据库对象，但是还未关联app对象，不会执行init_app方法进行初始化操作,等待工厂方法创建出app对象，再延后关联# db数据库必须定义成全局变量，方便别的模块调用db = SQLAlchemy()# 设计模式：MVC MVT MVVM 工厂设计模式，单例设计模式，中间人设计思想-生产者消费者模式，装饰器模式,...# https://yq.aliyun.com/topic/122# 需求：将app创建封装到工厂方法中def create_app(config_name):    # 1.创建app    app = Flask(__name__)    # 2.读取配置类中的配置信息    config_class = config_dict[config_name]    app.config.from_object(config_class)    # 3.读取环境变量中私有配置信息    # 后加载的同名配置信息会覆盖之前的配置信息    app.config.from_envvar(&quot;CONFIG&quot;, silent=True)    # 懒加载 延后加载    db.init_app(app)    # 4.返回app    return app# 开发模式下的app对象app = create_app(&quot;dev&quot;)# 生产模式下的app对象# app = create_app(&quot;pro&quot;)print(db)@app.route(&#x27;/&#x27;)def hello_world():    print(app.config[&quot;REDIS_HOST&quot;])    return &#x27;Hello World!&#x27;if __name__ == &#x27;__main__&#x27;:    app.run(debug=True, port=8000)\n用装饰器拦截放回字典定制json格式from flask import Flaskfrom flask_restful import Api, Resourceapp = Flask(__name__)# 1.将app对象包装创建api对象 [用于管理类视图(资源)]api = Api(app)&quot;&quot;&quot;需求：&#123;    &quot;name&quot;: &quot;james&quot;,    &quot;team&quot;: &quot;lakers&quot;&#125;定制返回的json格式：&#123;    &quot;message&quot;: &quot;OK&quot; 或 &quot;ERROR Message&quot;,    &quot;data&quot;: &#123;            &quot;name&quot;: &quot;james&quot;,            &quot;team&quot;: &quot;lakers&quot;    &#125;&#125;方案1：修改底层output_json的源代码 [不推荐]    # json定制化    if &quot;message&quot; not in data:        data = &#123;            &quot;message&quot;: &quot;OK&quot;,            &quot;data&quot;: data        &#125;方案2：使用装饰器拦截返回的字典，定制json格式，返回响应 [推荐]&quot;&quot;&quot;from utils import output_json# 主动寻求装饰api.representation(mediatype=&quot;application/json&quot;)(output_json)# 2.定义类视图  继承Resourceclass DemoResource(Resource):    def get(self):        # 类视图响应的content-type默认变为json形式        # 类视图的返回值可以是字典, 会被自动转为json字符串        my_dict = &#123;            &quot;name&quot;: &quot;james&quot;,            &quot;team&quot;: &quot;lakers&quot;        &#125;        return my_dict    def post(self):        my_dict = &#123;            &quot;name&quot;: &quot;james&quot;,            &quot;team&quot;: &quot;lakers&quot;,            &quot;message&quot;: &quot;invalid user&quot;        &#125;        return my_dict# 3.api对象给类视图添加路由api.add_resource(DemoResource, &#x27;/&#x27;)if __name__ == &#x27;__main__&#x27;:    print(app.url_map)    app.run(debug=True)"},{"url":"/2025/09/11/flask/%E9%93%BE%E6%8E%A5mysql/","content":"在Mysql命令行中更改时区\n点开最右侧 Advanced，找到 serverTimezone，在右侧value处填写 GMT，保存即可！(或填写 Asia&#x2F;Shanghai)Copymysql &gt; SET time_zone &#x3D; ‘+8:00’; # 此为北京时，我们所在东8区Copymysql&gt; flush privileges; # 立即生效\n"},{"url":"/2025/09/11/javaScipt/JavaScript/","content":"8.1JS获取标签元素，操作标签属性（css属性,标签属性，内容）alert() (执行相应的操作并且弹出对话框)\nvar定义的变量会向前申明（提前申明）\n8.2条件语句if\n比较运算符&#x3D;&#x3D;\t&#x3D;&#x3D;&#x3D;\t!&#x3D;\t&gt;\t&lt;\t&gt;&#x3D;\t&lt;&#x3D;注意：&#x3D;&#x3D;&#x3D; 判断值与类型如果x&#x3D;5   判断x&#x3D;&#x3D;&#x3D;5为ture ，x&#x3D;&#x3D;&#x3D;”5”为false\n逻辑运算符:&amp;&amp; and\t||\tor\t!\tnot\n8.3获取标签元素内置对象document的方法getElementByld\nvar oDiv=document.getElementById(&quot;div1&quot;)alert(oDiv)&lt;/script&gt;&lt;div id=&quot;div1&quot;&gt;this is div&lt;/div&gt;\n\n8.4改属性&#x2F;&#x2F;js获取标签入口代码（必须写在匿名函数中  ）html:class–&gt;js:className   html:font-size—&gt;js:对象.style.fontSize\nwindow.onload(页面内容加载后立即执行此函数)=function（）（没有函数名，只作用于这一次）&#123;\tvar oInput = document.getElementById(&quot;input1&quot;);\tvar oA = document.getElementById(&quot;link01&quot;);//获取标签\talert(oInput.value);\talert(oInput.name);\talert(oA.className); //设置标签属性:对象名.属性名//a的属性class ,通过对象访问时，使用名字classNameoA.className = &quot;sty02&quot;;（格式记住时对象.属性名=“新的css属性名&quot;）oA.style.fontSize = &quot;50px&quot;;&#125;\n\n8.5读取或者改标签包裹的内容对象.innerHTML\nwindow.onload = function()&#123;\tvar oDiv = document.getElementById(&quot;div1&quot;);\talert(oDiv.innnerHTML);\toDiv.innerHTML  =&quot;&lt;ul&gt;&lt;/ul&gt;&quot;&#125;\n8.6数组创建：实例化对象创建\nvar  alist = new Array(1,2,3); \n字面量方式创建\nvar alist2=[1,2,3,&#x27;abc&#x27;];\n多维数组\nvar alist = [[1,2,3],[&#x27;a&#x27;,&#x27;b&#x27;]];\n数组的操作\n var alist = [1,2,3,4];alert(alist.length);数组的尾部添加与尾部提取var alist = [1,2,3,4];//尾部添加一个5alist.push(5)//弹出1，2，3，4，5alert(alist);//尾部提取alist.pop();//弹出1，2，3，4alert(alist);\n\n\n根据下标添加和删除元素arr.splice(start,num,element1,….,elementN)参数解析start ：必需，开始删除的索引num：可选，删除数组元素的个数elementN：可选，start索引位置要插入的新元素.删除\nvar colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];colors.splice(0,1)alert(colors);//green,blue添加colors.splice(1,0,&quot;yellow&quot;,&quot;orange&quot;);alert(colors);//green,yellow,organge,blue删除添加colors.splice(1,1,&quot;red&quot;,&quot;purple&quot;);alert(colors)//green,red,purple,orange,blue\n\n\n8.7循环语句for循环\t\twhile循环 \tdo-while循环\nvar array = [1,4,5];for循环for(var index = 0; index&lt;array.length;index++)&#123;\tvar result = array[index];\talert(result);&#125;\nwhile循环var index = 0;while(index&lt;arrray.length)&#123;\tvar result = array[index];\tconsole.log(访问内容。跟aler弹框不同，这是用来调试用的,看代码需要进入页面的Console页面)(alist[index]);\tindex++;&#125;\ndo while循环var index = 0;do&#123;\tvar result = array[index];\talert(result);\tindex++;&#125;while(index&lt;array.length);\n8.8字符串拼接”+”\n var i=100;var i2=200;var i3=&quot;123&quot;alert(i+i2);//300alert(i2+i3);//200123\n8.9定时器在一段特定的时间后执行某段代码创建方式2种：1.setTimeout(func[,delay,param1,param2,…]):以指定的时间间隔（以毫米计算）调用一次函数的定时器\n2.settlnterval(func[,delay,param1,param2,…]):以指定的时间间隔（毫米）重复调用一个函数的计时器\n&lt;s&gt;\tfunction hello()&#123;\t\talert(&#x27;hello&#x27;);&#125;\tsetInterval(hell,1000);(每隔一秒调用函数一次，1000毫秒=1秒);&lt;/s&gt;\n清除定时器2种\n清除只执行一次的定时器clearTimeout(timeoutID)\n清除反复调用的定时器clearInterval(timeoutID)\n&lt;s&gt;\tfunction hello()&#123;\t\talert(&#x27;hello&#x27;);\t\tclearTimeout(t1)&#125;\tt1=setTimeout(hello,500)&lt;/s&gt;\n\n8.10链接\n\n\n$()是jQuery库中实现的函数，把你写的js对象（函数），转换成jQ自定义的对象（jq函数里面做了window.onload的工作，页面加载完成事件）优化：（使用jQ入口写法更快，比window.onload快）\n写法：\n$(function()&#123;\tvar\t$div = $(&quot;#div1&quot;);\talert(&quot;jquery:&quot; +$div);&#125;);\n\n\n8.11属性选择器\n$(&quot;input[name=username]&quot;)\n\n8.12选择器转移\n&lt;script&gt;\t$(function()&#123;\tvar $div =$(&#x27;#div01&#x27;)\t$(&#x27;#div&#x27;).prev();//表示选择的上一级\t//$div.prev().css(&#123;&quot;color&quot;:&quot;red&quot;&#125;);($元素.关键字.css(&#123;&quot;color&quot;:&quot;red&quot;&#125;))\t$(&quot;#div&quot;).prevAll() ;//选择的元素上面的所有同级元素\t//$div.prevAll().css(&#123;&quot;color&quot;:&quot;blue&quot;&#125;);\t$(&quot;#div&quot;).next() ;//下一个同级元素\t//$div.next().css(&#123;&quot;color&quot;:&quot;red&quot;&#125;);\t$(&quot;#div&quot;).next()；//选择的元素下面的所有同级元素\t$(&quot;#div&quot;).parent();//表示选择的元素的父元素\t$(&quot;#div&quot;).children();//选择的元素的所有子元素\t$(&quot;#div&quot;).siblings();//选择的元素的其他同级元素\t$(&quot;#div&quot;).find(&#x27;.myClass&#x27;);//选择的id是box元素的class=myClass的元素&#125;)\t&lt;/script&gt;&lt;div&gt;\t&lt;h2&gt;这是第一个h2标签&lt;h2&gt;\t&lt;p&gt;这是第一个段落&lt;/p&gt;\t&lt;div id=&quot;div01&quot;&gt;这是一个&lt;span&gt;div&lt;/span&gt;&lt;span class=&quot;sp02&quot;&gt;第二个span&lt;/span&gt;&lt;/div&gt;\t&lt;h2&gt;这是第二个h2标签&lt;/h2&gt;\t&lt;p&gt;这是第二个段落&lt;/p&gt;&lt;/div&gt;\n\n8.13jq获取和设置标签内容‘’’\n\n\t$(function(){\n\t\tvar $div = $(\"#div1\");\n\t\t//获取标签内容\n\t\tconsole.log($div.html())\n\t\t//设置标签内容：删除原理内容\n\t\t$div.html(\"hello world\");\n\t\t\n\t\t//追加标签内容\n\t\t$div.append(\"hi\")\n\t\n})\n\n\n\n\t\n\t\thello\n\t\n\n\n\n8.14prop获取属性值和设置属性值与对象.css不同的是.css直接改css,prop直接改标签符的属性prop 方法:获取元素属性：对象.prop（“标签属性名”）设置元素属性：对象.prop（“标签属性名”：“属性值”,…）\nval方法：获取元素属性：对象.val()设置元素属性：对象.val(“value值”)\ncss方法：获取样式属性:对象.css(“样式属性名”)设置样式属性：对象.css({“样式属性名”：“属性值”})\n8.15常见事件：click():点击事件blur():失去焦点focus():获取焦点mouseover():鼠标进入mouseout():鼠标离开ready():页面加载完成\n8.16事件代理原理：利用底层原理（冒泡原理）：事件会向它的父级一层一层传递把事件加到父级上，通过判断事件的来源，执行相应的子元素的操作\n作用：事件代理可以减少绑定，提高性能，让新子元素共享操作\n$(cuntion()&#123;\t$list = $(&#x27;#list&#x27;);\t$list.delegate(&#x27;li&#x27;,&#x27;click&#x27;,function()&#123;\t\t$(this).css(&#123;background:&#x27;red&#x27;&#125;)\t&#125;)&#125;)&lt;ul id=&quot;list&quot;&gt;\t&lt;li&gt;1&lt;/li&gt;&lt;/ul&gt;\n\n8.17jsonjson类似于js对象的字符串，是一种数据格式json有两种格式1.对象格式 2.数组格式json转换js对象：\nvar sjson = &#x27;&#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:10&#125;&#x27;;var oPerson = JSON.parse(sjon);alert(oPerson.name)alert(operson.age)\n\n8.18ajax前后台通讯获取数据的jQuery方法特点：异步（多线程），局部刷新（优化）\n&lt;script&gt;\t$(function()&#123;\t\t$.get(&quot;http://t.weather.sojson.com/api/weather/city/101010100&quot;,\t\tfunction(data,status)&#123;\t\t\tconsole.log(data);\t\t\tconsole.log(status);\t\t\talest(dat);\t\t\t&#125;).error(function()&#123;\t\t\t\talert(&#x27;网络异常&#x27;);\t\t\t&#125;);\t&#125;);\t$.post(&quot;test.php&quot;,&#123;&quot;func&quot;:&quot;getNameAndTime&quot;&#125;,function(data)&#123;\t\talert(data.name);\t\tconsole.log(data.time);\t\t\t&#125;,&quot;json&quot;).error(function()&#123;\t\talert(&quot;网络异常&quot;);\t&#125;)&lt;/script&gt;\n\n$.get和$.post方法的参数说明:\n$.get(url,data,success(data, status, xhr),dataType).error(func)$.post(url,data,success(data, status, xhr),dataType).error(func)\nurl 请求地址data 设置发送给服务器的数据，没有参数不需要设置success 设置请求成功后的回调函数data 请求的结果数据status 请求的状态信息, 比如: “success”xhr 底层发送http请求XMLHttpRequest对象dataType 设置返回的数据格式“xml”“html”“text”“json”error 表示错误异常处理func 错误异常回调函数\n概括：js获取标签与操作\nwindow.onload &#x3D; function(){…}var oDiv &#x3D;document.getElementbyId(“div1”);\n****js调用js：\ndocument.write(&quot;&lt;script language=javascript src=&#x27;/js/import.js&#x27;&gt;&lt;/script&gt;&quot;);document.write(&quot;&lt;script language=jQuery src=&quot;js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;&quot;)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2025/09/11/javaScipt/miniweb%E6%A1%86%E6%9E%B6/","content":"了解：静态资源:可以提前准备的，不经常发生变化的资源动态资源：不饿能提前准备经常发生变化的资源web框架：为web服务器提供动态资源的程序WSGI协议：web服务器和web框架之间进行协同工作的一个规则\n"},{"url":"/2025/09/11/python%E5%A4%8D%E4%B9%A0/python%20%E5%A4%8D%E4%B9%A0day01/","content":"1.python 魔法方法1.对象构造方法1."},{"url":"/2025/09/11/python%E5%A4%8D%E4%B9%A0/%E4%BC%98%E5%8C%96/","content":"6.6 关于 Python 程序的运行方面，有什么手段能提升性能？(2018-3-30-lxy)1、使用多进程，充分利用机器的多核性能2、对于性能影响较大的部分代码，可以使用 C 或 C++编写3、对于 IO 阻塞造成的性能影响，可以使用 IO 多路复用来解决4、尽量使用 Python 的内建函数5、尽量使用局部变量\n字典排序1.1 现有字典 d=&#123;‘a’:24，‘g’:52，‘i’:12，‘k’:33&#125;请按字典中的 value值进行排序？ (2018-3-30-lxy)sorted(d.items()，key = lambda x:x[1]) 。\n高级切片方法字典排序str1 = &quot;k:1|k1:2|k2:3|k3:4&quot;def str2dict(str1):\tdict1 = &#123;&#125;for iterms in str1.split(&#x27;|&#x27;):key，value = iterms.split(&#x27;:&#x27;)dict1[key] = valuereturn dict1\nalist排序alist [&#123;&#x27;name&#x27;:&#x27;a&#x27;，&#x27;age&#x27;:20&#125;，&#123;&#x27;name&#x27;:&#x27;b&#x27;，&#x27;age&#x27;:30&#125;，&#123;&#x27;name&#x27;:&#x27;c&#x27;，&#x27;age&#x27;:25&#125;] def sort_by_age(list1): return sorted(alist，key=lambda x:x[&#x27;age&#x27;]，reverse=True)"},{"url":"/2025/09/11/%E4%BA%91%E7%8E%AF%E5%A2%83/%E4%BA%91%E7%8E%AF%E5%A2%83/","content":"https://www.bistudio.com.cn/cloudDetail?cloud_id=1\n"},{"url":"/2025/09/11/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/newnote_1602030880118/","content":"\n"},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Matplotib/","content":"中文显示from pylab import mplmpl.rcParams[&quot;font.sans-serif&quot;]=[&quot;SimHei&quot;]mpl.rcParams[&quot;axes.unicode_minu&quot;]= False\n添加网格显示plt.grid(True, linestyle=&quot;--&quot;,alpha=0.5)\n\n添加描述信息plt.xlable(&quot;时间&quot;)plt.ylable(&quot;温度&quot;)plt.title(&quot;中午的温度变化图&quot;，fontsize=20)\n图像保存plt.savefig(&quot;test.png&quot;)\n画图流程\nimport matplotlib.pyplot as pltimport randomfrom pylab import mpl# 设置显示中文字体from pylab import mplmpl.rcParams[&quot;font.sans-serif&quot;] = [&quot;SimHei&quot;]# 设置正常显示符号mpl.rcParams[&quot;axes.unicode_minus&quot;] = False# 0.准备数据x = range(60)y_shanghai = [random.uniform(15, 18) for i in x]# 1.创建画布plt.figure(figsize=(20, 8), dpi=100)# 2.绘制图像plt.plot(x, y_shanghai)# 2.1 添加x,y轴刻度# 构造x,y轴刻度标签x_ticks_label = [&quot;11点&#123;&#125;分&quot;.format(i) for i in x]y_ticks = range(40)# 刻度显示plt.xticks(x[::5], x_ticks_label[::5])plt.yticks(y_ticks[::5])# 2.2 添加网格显示plt.grid(True, linestyle=&quot;--&quot;, alpha=0.5)# 2.3 添加描述信息plt.xlabel(&quot;时间&quot;)plt.ylabel(&quot;温度&quot;)plt.title(&quot;中午11点--12点某城市温度变化图&quot;, fontsize=20)# 2.4 图像保存plt.savefig(&quot;./test.png&quot;)# 3.图像显示plt.show()\n\n一图多线多次plot\n# 增加北京的温度数据y_beijing = [random.uniform(1, 3) for i in x]# 绘制折线图plt.plot(x, y_shanghai)# 使用多次plot可以画多个折线plt.plot(x, y_beijing, color=&#x27;r&#x27;, linestyle=&#x27;--&#x27;)\n各图形及其语法折线图\napi: plt plot(x,y)\n散点图\napi: plt.scatter(x,y)\n\n柱状图\napi：plt.bar(x, width, align=&#x27;center&#x27;, **kwargs)Parameters:    x : 需要传递的数据width : 柱状图的宽度align : 每个柱状图的位置对齐方式    &#123;‘center’, ‘edge’&#125;, optional, default: ‘center’**kwargs :color:选择柱状图的颜色dadatwer\n直方图\napi: matplotilb.pyplot.hist(x,bins=None)Parameters:    x : 需要传递的数据bins : 组距\n饼图\napi: plt.pie(x,labels=,atuopct=,colors)Parameters:  x:数量，自动算百分比labels:每部分名称autopct:占比显示指定%1.2f%%colors:每部分颜色\n"},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Numpy/","content":"生成数组a = np.array([[1,2,3],[4,5,6]])# 从现有的数组当中创建a1 = np.array(a)# 相当于索引的形式，并没有真正的创建一个新的a2 = np.asarray(a)\n 关于array和asarray的不同\n等于创建一个软链接当数组赋值给另外一个变量后，array：修改变量不会改变asarray： 会跟着改变\n\n\n生成各种不同的数组\n生成固定范围的数组np.linspace (start, stop, num, endpoint)参数:start:序列的起始值stop:序列的终止值num:要生成的等间隔样例数量，默认为50endpoint:序列中是否包含stop值，默认为ture等差数组np.arange(start,stop, step, dtype)参数step:步长,默认值为1np.arange(10, 50, 2)等比数组np.logspace(start,stop, num)num:要生成的等比数列数量，默认为50 生成随机数组np.random   \n\n正态分布创建方法\n准正态分布中返回一个或多个样本值np.random.randn(d0, d1, …, dn)np.random.normal(loc=0.0, scale=1.0, size=None)loc：float​ 此概率分布的均值（对应着整个分布的中心centre）scale：float​ 此概率分布的标准差（对应于分布的宽度，scale越大越矮胖，scale越小，越瘦高）size：int or tuple of ints​ 输出的shape，默认为None，只输出一个值返回指定形状的标准正态分布的数组。np.random.standard_normal(size=None)\n\n均匀分布np.random.rand(d0, d1, ..., dn)返回一组均匀分布的数。从一个均匀分布[low,high)中随机采样，注意定义域是左闭右开，即包含low，不包含high.np.random.uniform(low=0.0, high=1.0, size=None均匀分布中随机采样，生成一个整数或N维整数数组np.random.randint(low, high=None, size=None, dtype=&quot;l&quot;)取数范围：若high不为None时，取[low,high)之间随机整数，否则取值[0,low)之间随机整数。\n\n形状修改返回一个具有相同数据域，但shape不一样的视图行、列不进行互换ndarray.reshape(shape, order)修改数组本身的形状（需要保持元素个数前后相同）行、列不进行互换ndaarray.resize(new_shape)数组的转置将数组的行、列进行互换ndaarray.T\n\n类型修改返回修改了类型之后的数组stock_change.astype(np.int32)构造包含数组中原始数据字节的Python字节  arr = np.array([[[1, 2, 3], [4, 5, 6]], [[12, 3, 34], [5, 6, 7]]])arr.tostring()\n返回给定的形状哥类型的新数组，用0填充numpy.zeros(shape，dtype&#x3D;float，order &#x3D; ‘C’)\n返回给定形状和类型的新数组，用0填充。参数：\tshape：int 或 int 的元组 \t新阵列的形状，例如：（2，3）或2。 \tdtype：数据类型，可选 \t数组的所需数据类型，例如numpy.int8。默认是numpy.float64 \torder：&#123;&#x27;C&#x27;，&#x27;F&#x27;&#125;，可选，默认：&#x27;C&#x27; \t是否在内容中以行（C）或列（F）顺序存储多维数据。返回：\tout：ndarray \t具有给定形状，类型和顺序的0的数组。np.zeros((2,3))Out[2]: array([[ 0.,  0.,  0.],       [ 0.,  0.,  0.]])\n\n\n分组频数计算\nmean() 取平均值nunique方法计算pandas Series的唯一值计算（去重）value_counts方法获取pandas Series的频数统计\n\nto_numeric 函数变量转换为数值类型（int，float）\nDataFrame每一列的数据类型必须相同，当有些数据中有缺失，但不是NaN时（如missing,null等），会使整列数据变成字符串类型而不是数值型，这个时候可以使用to_numeric处理pd.to_numeric(tips_sub_miss[&#x27;total_bill&#x27;])to_numeric函数有一个参数errors,它决定了当该函数遇到无法转换的数值时该如何处理默认情况下,该值为raise,如果to_numeric遇到无法转换的值时,会抛错coerce: 如果to_numeric遇到无法转换的值时,会返回NaNignore: 如果to_numeric遇到无法转换的值时会放弃转换,什么都不做pd.to_numeric(tips_sub_miss[&#x27;total_bill&#x27;],errors = &#x27;ignore&#x27;)to_numeric向下转型to_numeric函数还有一个downcast参数, downcast接受的参数为 &#x27;integer&#x27;,&#x27;signed&#x27;,&#x27;float&#x27;,&#x27;unsigned&#x27;downcast参数设置为float之后, total_bill的数据类型由float64变为float32pd.to_numeric(tips_sub_miss[&#x27;total_bill&#x27;],errors = &#x27;coerce&#x27;,downcast=&#x27;float&#x27;)\n\n分类数据(category)Pandas 有一种类别数据, category,用于对分类值进行编码\n转换为category类型tips[&#x27;sex&#x27;] = tips[&#x27;sex&#x27;].astype(&#x27;str&#x27;) tips.info()\nPandas 数据类型转换Pandas除了数值型的int 和 float类型外，还有object ，category，bool，datetime类型可以通过as_type 和 to_numeric 函数进行数据类型转换Pandas 分类数据类型category类型，可以用来进行排序，并且可以自定义排序顺序CategoricalDtype可以用来定义顺序\n"},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ndarray%E8%BF%90%E7%AE%97/","content":"逻辑运算# 随机生成10名同学，5门功课的数据score = np.random.randint(40, 100,(10,5))print(score)# 切片 取出最后4名同学的成绩，用逻辑判断test_score = score[6:, 0:5]# 逻辑判断print(test_score &gt; 60)# 布尔索引(满足条件替换)print(test_score[test_score &gt; 60] =1)判断or&amp;and# 判断前两名同学的成绩[0:2, :]是否全及格&gt;&gt;&gt; np.all(score[0:2, :] &gt; 60)Falsenp.any()# 判断前两名同学的成绩[0:2, :]是否有大于90分的&gt;&gt;&gt; np.any(score[0:2, :] &gt; 80)True\n\n三目运算# 判断前四名学生,前四门课程中，成绩中大于60的置为1，否则为0temp = score[:4, :4]np.where(temp &gt; 60, 1, 0)# 判断前四名学生,前四门课程中，成绩中大于60且小于90的换为1，否则为0np.where(np.logical_and(temp &gt; 60, temp &lt; 90), 1, 0)# 判断前四名学生,前四门课程中，成绩中大于90或小于60的换为1，否则为0np.where(np.logical_or(temp &gt; 90, temp &lt; 60), 1, 0)\n\n数组运算时的广播机制：\n数组在进行矢量化运算时，要求数组的形状是相等的。"},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/pandas/","content":"创建Series\nimport pandas as pd s = pd.Series([&#x27;banana&#x27;,42])\n创建DataFrame\nname_list = pd.DataFrame(\t&#123;\t\t&#x27;Name&#x27;:[&#x27;Tome&#x27;,&#x27;Bob&#x27;], \t\t&#x27;Occupation&#x27;:[&#x27;Teacher&#x27;,&#x27;IT Engineer&#x27;], \t\t&#x27;age&#x27;:[28,36]\t&#125;)\nSeries 常用操作loc\t使用索引值取子集iloc \t使用索引位置取子集dtype或dtypes Series\t内容的类型T \tSeries的转置矩阵shape \t数据的维数size \tSeries中元素的数量values \tSeries的值.value_counts()\t\t统计value数量director.count() \t返回非空值describe() \t打印描述信息\nSeries的一些方法方法 \t说明append \t连接两个或多个Seriescorr \t计算与另一个Series的相关系数cov\t 计算与另一个Series的协方差describe 计算常见统计量drop_duplicates \t返回去重之后的Seriesequals \t\t判断两个Series是否相同get_values \t获取Series的值，作用与values属性相同hist \t绘制直方图isin Series\t中是否包含某些值min \t返回最小值max\t返回最大值mean\t返回算术平均值median\t返回中位数mode \t返回众数quantile \t返回指定位置的分位数replace \t用指定值代替Series中的值sample\t 返回Series的随机采样值sort_values \t对值进行排序to_frame\t把Series转换为DataFrameunique \t\t去重返回数组\n两个Series之间计算，如果Series元素个数相同，则将两个Series对应元素进行计算；元素不同则缺失用NaN表示\nDataFramendim 查看数集的维度set_index 修改索引drop 删除列to_pickle 保存read_pickle 读取to_csv  保存成csv文件格式：(&#x27;output/scientists_df.tsv&#x27;,sep=&#x27;\\t&#x27;)to_clipboard 把数据保存到系统剪贴板，方便粘贴to_dict 把数据转换成Python字典to_hdf 把数据保存为HDF格式to_html 把数据转换成HTMLto_json 把数据转换成JSON字符串to_sql 把数据保存到SQL数据库nlargest(100,&#x27;imdb_score&#x27;)0.1统计数值列，并进行转置college.describe().T统计多方式数值.describe()nlargest方法显示出某列的排序nlargest(100,&#x27;imdb_score&#x27;).head()传入一个字典agg(&#x27;key&#x27;:&#x27;value&#x27;)\n聚合重点agg\n数据链接concat\t把dataframe(简单叠堆)ignore_index = True\t忽略后面DataFrame的索引添加列（默认添加行），传入参数 axis = columnscol_concat = pd.concat([df1,df2,df3],axis=1)向DataFrame添加一列，不需要调用函数，通过dataframe[&#x27;列名&#x27;] = [&#x27;值&#x27;] 即可\n链接数据库pd.read_sql_table从数据库中读取表，第一个参数是表名，第二个参数是数据库连接对象\nhow = ’left‘ 对应SQL中的 left outer 保留左侧表中的所有keyhow = ’right‘ 对应SQL中的 right outer 保留右侧表中的所有keyhow = &#x27;outer&#x27; 对应SQL中的 full outer 保留左右两侧侧表中的所有keyhow = &#x27;inner&#x27; 对应SQL中的 inner 只保留左右两侧都有的key转换：to_timedelta 将Milliseconds列转变为timedelta数据类型dt.floor(&#x27;s&#x27;) dt.floor() 时间类型数据，按指定单位截断数据DataFrame的assign方法：创建新列.assignjoin合并，依据两个DataFrame的行索引，如果合并的两个数据有相同的列名，需要通过lsuffix，和rsuffix，指定合并后的列名的前缀stocks_2016.join(stocks_2017, lsuffix=&#x27;_2016&#x27;, rsuffix=&#x27;_2017&#x27;, how=&#x27;outer&#x27;)concat, join, 和merge的区别concat ：Pandas函数可以垂直和水平地连接两个或多个pandas对象只用索引对齐默认是外连接（也可以设为内连接）join ：DataFrame方法只能水平连接两个或多个pandas对象对齐是靠被调用的DataFrame的列索引或行索引和另一个对象的行索引（不能是列索引）通过笛卡尔积处理重复的索引值默认是左连接（也可以设为内连接、外连接和右连接）merge ：DataFrame方法只能水平连接两个DataFrame对象对齐是靠被调用的DataFrame的列或行索引和另一个DataFrame的列或行索引通过笛卡尔积处理重复的索引值默认是内连接（也可以设为左连接、外连接、右连接）\n\n缺失数据处理keep_default_na = False 关闭NaN显示ffill 填充，用时间序列中空值的上一个非空值填充city_day.fillna(method=&#x27;ffill&#x27;,inplace=True) city_day[&#x27;Xylene&#x27;][50:65]用时间序列中空值的下一个非空值填充method=&#x27;bfill&#x27;线性差值方法limit_direction=&quot;both&quot;\n整理数据melt既可以用pd.melt, 也可使用dataframe.melt()\nframe dataframe 被 melt 的数据集名称在 pd.melt() 中使用id_vars tuple/list/ndarray \t可选项不需要被转换的列名，在转换后作为标识符列（不是索引列）value_vars tuple/list/ndarray \t可选项需要被转换的现有列如果未指明，除 id_vars 之外的其他列都被转换var_name string variable \t默认值自定义列名名称设置由 &#x27;value_vars&#x27; 组成的新的 column namevalue_name string value \t默认值自定义列名名称设置由 &#x27;value_vars&#x27; 的数据组成的新的 column namecol_level int/string \t可选项如果列是MultiIndex，则使用此级别数据整理（函数自动处理）pew_long = pd.melt(pew,id_vars=&#x27;religion&#x27;)pew_long\n处理查询冗余对于同一首歌曲来说，歌曲信息是完全一样的，可以考虑单独保存歌曲信息减少上表中保存的歌曲信息，可以节省存储空间，需要完整信息的时候，可以通过merge拼接数据我们可以把year,artist,track,time和date.entered放入一个新的dataframe中1.提取表信息，进行去重illboard_songs = bill_borad_long[[&#x27;year&#x27;,&#x27;artist&#x27;,&#x27;track&#x27;,&#x27;time&#x27;,&#x27;date.entered&#x27;]] billboard_songs = billboard_songs.drop_duplicates()billboard_songs2.为新拆分处理出来的数据添加ID列（添加ID）billboard_songs[&#x27;id&#x27;] = range(len(billboard_songs)) billboard_songs3.数据拆分成两个dataframe：billboard_songs和 billboard_ratings取出每周评分，去掉冗余部分billboard_ratings = bill_borad_long.merge(billboard_songs,on=[&#x27;year&#x27;,&#x27;artist&#x27;,&#x27;track&#x27;,&#x27;time&#x27;,&#x27;date.entered&#x27;]) billboard_ratings = billboard_ratings[[&#x27;id&#x27;,&#x27;week&#x27;,&#x27;rating&#x27;]] billboard_ratings4.用merage还原数据billboard_songs.merge(billboard_ratings,on=[&#x27;id&#x27;])\nstack整理数据用rename_axis给不同的行索引层级命名reset_index()，将结果变为DataFrame\nwide_to_long整理数据stubs = [&#x27;actor&#x27;, &#x27;actor_facebook_likes&#x27;]actor2_tidy = pd.wide_to_long(actor2, stubnames=stubs, i=[&#x27;movie_title&#x27;], j=&#x27;actor_num&#x27;, sep=&#x27;_&#x27;).reset_index() actor2_tidy.head()\nunstack 处理数据之前介绍了stack，unstack可以将stack的结果恢复\nstate_fruit.stack().unstack()\n\n\n自定义方法.apply(方法名)\n向量函数def avg_2_mod(x,y): \tif(x==20): \t\treturn (np.NaN) \telse:return (x+y)/2 avg_2_mod(df[&#x27;a&#x27;],df[&#x27;b&#x27;])上面函数中, x==20 , x 是向量, 但20是标量, 不能直接计算. 这个时候可以使用np.vectorize将函数向量化使用装饰器@np.vectorize def vec_avg_2_mod(x,y): \tif(x==20):\t\t return (np.NaN) \telse:\t\treturn (x+y)/2 vec_avg_2_mod(df[&#x27;a&#x27;],df[&#x27;b&#x27;])\nlambda函数df.apply(lambda x: x+1)\nPandas内置的聚合方法Pandas\t方法 Numpy函数 说明count \tnp.count_nonzero \t频率统计(不包含NaN值)size \t频率统计(包含NaN值)mean np.mean \t求平均值std np.std \t标准差min np.min \t最小值quantile() \tnp.percentile() \t分位数max np.max \t求最大值sum np.sum \t求和var np.var \t方差describe \t计数、平均值、标准差，最小值、分位数、最大值first \t返回第一行last \t返回最后一行nth 返回第N行(Python从0开始计数)\naggagg.(‘列名’:’方法名’).rename(‘原名’：’新名’)\n转换transform 转换，需要把DataFrame中的值传递给一个函数， 而后由该函数”转换”数据。aggregate(聚合) 返回单个聚合值，但transform 不会减少数据量\n# 计算z-score x - 平均值/标准差 def my_zscore(x): \treturn (x-x.mean())/x.std() #按年分组 计算z-score df.groupby(&#x27;year&#x27;).lifeExp.transform(my_zscore)\ntransform分组填充缺失值之前介绍了填充缺失值的各种方法，对于某些数据集，可以使用列的平均值来填充缺失值。某些情况下，可以考虑将列进行分组，分组之后取平均再填充缺失值tips_10 = pd.read_csv(&#x27;data/tips.csv&#x27;).sample(10,random_state = 42) tips_10"},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/","content":"算法分为：\n监督学习\n\n\n定义：输入数据是由输入特征值和目标值所组成\n函数的输出可以是连续的值（回归）\n或是输出有限个离散值（分类）\n\n\n\n\n无监督学习\n\n\n定义：输入数据是由输入特征值组成，没有目标值\n输入数据没有被标记，也没有确定的结果。样本数据类别未知\n需要根据样本间的相似性对样本集进行类别划分\n\n\n\n\n半监督学习\n\n\n定义训练集同时包含有标记样本数据和未标记样本数据\n\n\n强化学习\n\n\tIn\tOut\t目的\t案例监督学习(supervised learning)\t有标签\t有反馈\t 预测结果\t猫狗分类 房价预测无监督学习(unsupervised learning)\t无标签\t无反馈\t   发现潜在结构\t“物以类聚，人以群分”半监督学习(Semi-Supervised Learning) 部分  有标签，     部分无标签\t有反馈\t降低数据标记的难度\t强化学习(reinforcement learning) 决策流程及激励系统 一系列行动\t长期利益最大化\t学下棋\n\n\n\n工作流1.获取数据2.数据基本处理- 1.缩小数据集范围DataFrame.query()- 2.选取有用的时间特征- 3.将签到位置少于n个用户的删除3.特征工程- 特征提取- 特征预处理- 特征降维- 特征预处理(标准化)4.机器学习(模型训练)5.模型评估- 结果达到要求，上线服务- 没有达到要求，重新上面步骤\n"},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/","content":"(M行, N列)*(N行, L列) &#x3D; (M行, L列)C &#x3D; A x B\nc(1,1) &#x3D; （1行1 * 1列1）+ （1行2 *1列2）…c(1,2) &#x3D; （1行1 * 2列1）+ （1行2 *2列2）…矩阵乘法的性质矩阵的乘法不满足交换律：A×B≠B×A\n矩阵的乘法满足结合律。即：A×（B×C）&#x3D;（A×B）×C\n单位矩阵：在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的 1,我们称 这种矩阵为单位矩阵．它是个方阵，一般用 I 或者 E 表示，从 左上角到右下角的对角线（称为主对角线）上的元素均为 1 以外全都为 0\n矩阵乘法api：np.matmulnp.dot\nnp.matmul和np.dot的区别:二者都是矩阵乘法。 np.matmul中禁止矩阵与标量的乘法。 在矢量乘矢量的內积运算中，np.matmul与np.dot没有区别。\n"},{"url":"/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/DRF%E6%A1%86%E6%9E%B6/","content":"DRF框架就是RestFramework框架（rest_framework[导入的方式]）\nREF开发模式：\t前后端分离模式开发的\n\nRESTful\n\n\n域名  接口设计方法：【大型服务部署放在专有域名下（整个服务器提供此类服务）】\n\n https://api.example.com\n小型 子应用：\nhttps://example.org/api/\n\n\n\n版本（在app后面放版本号）\n\nhttps://www.example.com/api/1.0/foo\n\n路径(名词，复数)遵循restful风格：&#x2F;books&#x2F;\n\n#请求动作\n\n没pk（id）：get + &#x2F;books&#x2F; &#x3D;&#x3D;&gt; 获取全部对象post + &#x2F;books&#x2F; &#x3D;&#x3D;&gt; 新建一数据\n\n有pk：get + &#x2F;books&#x2F; &#x3D;&#x3D;&gt; 获取单一对象put + &#x2F;books&#x2F; &#x3D;&#x3D;&gt; 更新单一对象delete + &#x2F;bookds&#x2F; &#x3D;&#x3D;&gt; 删除单一对象\n\n过滤参数 过滤的参数一般是放在查询字符串中携带\n\n过滤的参数一般放在查询字符串中携带查询字符串 &#x3D; page\n\n\nget + /books/?page=1&amp;page_size = 5分页就是过滤，根据page个page_size查询字符串参数去分页（过滤）\n\n\n状态码\n\n200 获取数据成功201 新建、更新成功400 后端校验参数错误401  没身份（匿名用户）403  没有权限404 资源找不到 1（路由错了，路由映射错了）2 （根据pk查询数据库找不到）405 请求方式不被允许（视图类没有重写视图方法）500 后端代码错误"},{"url":"/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/git/","content":"版本查询:sit –version查看当前仓库的状态信息：git status将单个文件加入缓存区：git add(绿了)将所有文件加入缓存区：git add.提交这次变更：git commit -m(message-描述)查看日志：git log将缓存区拿出来：(绿变红)git reset\n生成密钥：ssh-keygen -t rsa查看公钥：cat ~&#x2F;.ssh&#x2F;id_rsa.pub主题部署上线：hexo deploy\n"},{"url":"/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/restful%20%E9%A3%8E%E6%A0%BC%EF%BC%8C%E5%AE%9A%E4%B9%89http%E6%8E%A5%E5%8F%A3%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","content":"查询书本列表数据get + &#x2F;books&#x2F;请求方式 GET请求路径 &#x2F;books&#x2F;请求参数 无请求返回 json\nclass Books(view):\tdef get(self, request):  \t\tbooks = books.objects.all()  \t\tbook_list = []  \t\tfro book in books:    \t\t\tbook_list.addend(&#123;        \t\t&#x27;id&#x27;: book.id,        \t\t&#x27;btitle&#x27; : book.btitle,    \t\t&#125;)    \t\tcontext =&#123;        \t\t&#x27;book_list&#x27;： book_list        \t&#125;   \treturn JsonResopnse(context, safe =False)\npost+ &#x2F;books&#x2F;请求方式 POST请求路径 &#x2F;books&#x2F;请求参数 data请求返回 json\ndef post(self, request):\t#提取参数\tbooks_info = json.loads(request.body.decode())\tbtile = books_info.get(&#x27;btile&#x27;)\tbp = books.get(&#x27;bp&#x27;)\t#校验\tif not ([bp,btile]):\t\treutrn JsonResopnse(&#123;&#x27;errmsg&#x27;: &#x27;缺少必传字段&#x27;&#125;, status = 400)\tif len(btile)&gt;20:\t\treturn JsonResposne(&#123;&#x27;errmsg&#x27;: &#x27;名字过长&#x27;&#125;)\t#逻辑业务\ttry:\t\tbook = BookInfo.objects.create(**book_info)\texcept Exception as e:\t\treturn (&#123;&#x27;errmsgg&#x27;: &#x27;内部错误&#x27;&#125;)\t#构建返回--restful风格约定更新或者新建之后一定要吧最新资源返回\treturn JsonResopnse(&#123;\t\t&#x27;id&#x27;: book.id&#125;)"},{"url":"/2025/09/11/%E9%9A%8F%E7%AC%94%E6%9C%AA%E6%95%B4%E7%90%86/%E9%9A%8F%E7%AC%94/","content":"一、函数和方法的认知函数@classmethod下定义的func属于方法，@staticmethod下定义的func属于函数。而类class中定义的普通func要分是类调用还是类对象调用。函数是封装了一些独立的功能，可以直接调用，能将一些数据（参数）传递进去进行处理，然后返回一些数据（返回值），也可以没有返回值。可以直接在模块中进行定义使用。所有传递给函数的数据都是显式传递的。\n\n\n方法方法和函数类似，同样封装了独立的功能，但是方法是只能依靠类或者对象来调用的，表示针对性的操作。### 方法中的数据self和cls是隐式传递的，即方法的调用者；方法可以操作类内部的数据\n\n当类实例化对象后，如`apple对象`，再调用function时，普通func，如fun1，就被称为是`实例化方法`，定义在@staticmethod下的func，与class和实例化对象无关，所以依然属于`函数`,定义在@classmethod下的func，与class内部有关，属于类的方法。\n\n测试函数还是方法from types import FunctionType, MethodTypeprint(isinstance(lwd.func, FunctionType))  # Falseprint(isinstance(lwd.func, MethodType))   # True   #说明这是一个方法print(isinstance(Lwd.func, FunctionType))  # True   #说明这是一个函数print(isinstance(Lwd.func, MethodType))  # False\n重写管理器对象（自定义manager）class studentManager(models.Manager):  def get_queryset(self):    return super(studentManager,self).get_queryset().filter(isDelete=False)\n\n参数是类def xxx(cls,**yy):\tself &#x3D; cls(**yy)(实例化对象)\n取出请求方法同名的函数名赋值给handlerhandler&#x3D;getattr(self,request.method.lower((小写的意思)),self.http_method_not_allowed)return handler(request,*args,**kwargs)\n1. ### python cls self 讲解一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。而使用@staticmethod或@classmethod，就可以不需要实例化，直接类名.方法名()来调用。这有利于组织代码，把某些应该属于某个类的函数给放到那个类里去，同时有利于命名空间的整洁。\n\nclass A(object):    a &#x3D; ‘a’    @staticmethod    def foo1(name):        print ‘hello’, name    def foo2(self, name):        print ‘hello’, name    @classmethod    def foo3(cls, name):        print ‘hello’, name\n### 1. Mongodb数据库操作#### serilaizer：\nfrom rest_framework_mongoengine import serializers\nclass ListSerializer(serializers.DocumentSerializer):\nclass Meta:\n    model = Spit\n    fields = &quot;__all__&quot;\n\n#### views:\nfrom rest_framework_mongoengine.viewsets import ModelViewSet\nclass ListViewModelSet(ModelViewSet):    # queryset &#x3D; Spit.objects.all()需要转成    # def get_queryset(self):    #         return Spit.objects.all()才能提取\nserializer_class = ListSerializer\n\ndef get_queryset(self):\n    return Spit.objects.all()\n\n\n\n#Python 交换x ,y\nx , y\nint z=x; x=y, y=z\n可以优化为(加空格)\nx , y = y , x\n\n\n\n#根据数据库生成模型类\n\n\n\n创建一个项目，修改seting文件，在setting里面设置要连接的数据库\n\n运行下面代码可以自动生成models模型文件 \nPython manage.py inspectdb \n这样就可以在控制台的命令行中看到数据库的模型文件了\n\n把模型文件导入到app中 \n创建一个app \ndjango-admin.py startapp app \npython manage.py inspectdb &gt; app/models.py \nok模型文件已经生成好了。下面的工作就和之前一样了\n\n\n\n简单介绍工厂模式和单例模式\n工厂模式：\n\n　　介绍：\n\n　　　　工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程（new 关键字和具体的构造器）隐藏起来。用一个工厂方法来替代，对外提供的只是一个工厂方法，达到提高灵活性的目的。 　　\n\n　　优点：\n\n　　　　1.隐藏了new关键字和构造器 \n\n           　2.降低了这个对象与别的类之间的耦合度，提高了程序的可扩展性。 原因：当子类被别的类替代，或者构造器的参数发生变化的时候，只需改动工厂方法内的new即可，改动量降到了最低，直接用new关键字的话，需要改动的地方就很多了 \n\n           　3.把对象的设计和实现分割开来，从而代码扩展性强、灵活性高。 \n\n　　适用范围： \n      　　 1.在编码时不能预见需要创建哪一个种类的实例。 \n       　　2.一个类使用它的子类来创建对象。 \n       　　3.开发人员不希望创建了那个类的实例以及如何创建实例的信息暴露给外部程序。 \n     　　　　　除了上面提到的例子，工厂模式的实现方式还允许有一些小小的变化，例如： \n        　　　　基类可以是一个抽象类，在这种情况下，工厂类必须返回一个非抽象类。 \n       　　　　 基类提供了一些缺省方法，只有当这些缺省方法不能满足特殊需求的情况下才能在子类中重写这些方法。 \n        　　　　可以直接通过传递给工厂类的参数决定应该返回哪一个子类的实例。 \n\n　　 结构：用一个方法来代替new关键字和构造器。 \n\n \n\n单例模式：\n\n　　介绍：\n\n　　　　 1.声明一个私有的，静态的本类对象，但并不在声明的时候就初始化，因此，它的值为null。 \n        　　2.私有化构造器 \n        　　3.对外提供一个全局的，共有的，静态的，唯一的方法，用来获得该实例，但注意的是：必须要手动保持线程同步（synchronized） \n        　　4.在该方法里，判断对象是否为null，如果是null的话，表示这个类还没有被实例化，就会初始化这个对象，再返回如果不是null的话，就直接返回。\n\n　　优点：\n\n　　　　整个系统中的所有的类共用一个实例化对象，这样可以有效的节省资源。\n\n　　适用特点：\n\n　　　　它确保一个类在java虚拟机里只有一个实例，使一个类只有一个对象，整个系统共享这个对象。 \n\n　　结构：将构造变成私有的--&gt;做一个静态的生成对象的方法--&gt;造一个静态的存储对象--&gt;return 静态的对象\n\n\n"},{"url":"/2025/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/kaikeba/","content":"mean(平均值)热数据\nsns.heatmap(dataframe.corr(), annot=True, fmt=&#x27;.1f&#x27;)\n(例子用于理解)对比两个最小值的均值（第一个age 提取出年龄）（[:2]（把排好序的的两个拿出））\nnp.mean([age for name ,age in sorted(person_and_age.items(), key = lambda e: e[1])[:2]])\n对比两个最小值的均值【:topn】(最前的两个数值)history_price(数据)e[0](取 面积：价格 的面积)\ndef find_price_by_similar(history_price,query_x, topn=3):\tmost_similar_items = sorted(history_price.items(), key= lambda e: (e[0] - query_x)**2)[:topn]\tmost_similar_prices = [price for rm, price in most_similar_items]\taverage_prices = np.mean(most_similar_prices)\treturn average_prices\n\n回归预测结果产生的是一个数值，分类产生一个类别KNN&#x3D;&#x3D;&gt;K-Neighbor-Nearest\n拟合效果 是获取最优的k，b的问题\n损失函数：Loss越接近0，越准确\n𝑓(𝑟𝑚)=𝑘∗𝑟𝑚+𝑏Random Approach𝐿𝑜𝑠𝑠(𝑘,𝑏)=1𝑛∑𝑖∈𝑁(𝑦𝑖^−𝑦𝑖)2 𝐿𝑜𝑠𝑠(𝑘,𝑏)=1𝑛∑𝑖∈𝑁((𝑘∗𝑟𝑚𝑖+𝑏)−𝑦𝑖)2\n怎么获取最优的k&amp;b？1.直接用微积分的方法做计算（最小二乘法）（简单才用，基本不用）2.用随机模拟的方法来做（随机生成一堆数）也叫：蒙特卡洛模拟\ndef loss(y_hat, y):    return np.mean((y_hat - y) ** 2)import randommin_loss = float(&#x27;inf&#x27;)best_k, bes_b = None, Nonefor step in range(1000):    min_v, max_v = -100, 100    k, b = random.randrange(min_v, max_v), random.randrange(min_v, max_v)    y_hats = [k * rm_i  + b for rm_i in x]    current_loss = loss(y_hats, y)        if current_loss &lt; min_loss:        min_loss = current_loss        best_k, best_b = k, b        print(&#x27;在第&#123;&#125;步，我们获得了函数 f(rm) = &#123;&#125; * rm + &#123;&#125;, 此时loss是: &#123;&#125;&#x27;.format(step, k, b, current_loss))\n蒙特卡洛模拟Supervisor𝐿𝑜𝑠𝑠(𝑘,𝑏)=1/𝑛*∑𝑖∈𝑁((𝑘∗𝑟𝑚𝑖+𝑏)−𝑦𝑖)2∂𝑙𝑜𝑠𝑠(𝑘,𝑏)/∂𝑘=2/𝑛*∑𝑖∈𝑁(𝑘∗𝑟𝑚𝑖+𝑏−𝑦𝑖)∗𝑟𝑚𝑖∂𝑙𝑜𝑠𝑠(𝑘,𝑏)/∂𝑏=2/𝑛*∑𝑖∈𝑁(𝑘∗𝑟𝑚𝑖+𝑏−𝑦𝑖)\ndef partial_k(k, b, x, y):    return 2 * np.mean((k * x + b - y) * x)def partial_b(k, b, x, y):    return 2 * np.mean(k * x + b - y)k_history, b_history = [], []loss_history = []k, b = random.random(), random.random()min_loss = float(&#x27;inf&#x27;)best_k, bes_b = None, Nonelearning_rate = 1e-2for step in range(2000):    k, b = k + (-1 * partial_k(k, b, x, y) * learning_rate), b + (-1 * partial_b(k, b, x, y) * learning_rate)    y_hats = k * x + b    current_loss = loss(y_hats, y)        if current_loss &lt; min_loss:        min_loss = current_loss        best_k, best_b = k, b        k_history.append(best_k)        b_history.append(best_b)        loss_history.append(current_loss)        print(&#x27;在第&#123;&#125;步，我们获得了函数 f(rm) = &#123;&#125; * rm + &#123;&#125;, 此时loss是: &#123;&#125;&#x27;.format(step, k, b, current_loss))\n\n深度学习的核心 ： 通过梯度下降的方法，获得一组参数，是的loss最小loss偏导式 + 梯度下降\n将课堂代码中的L2-Loss 变成L1Loss 并且实现梯度下降\n𝐿2−𝐿𝑜𝑠𝑠(𝑦,𝑦̂ )=1/𝑛*∑(𝑦̂ −𝑦)2 𝐿1−𝐿𝑜𝑠𝑠(𝑦,𝑦̂ )=1/𝑛*∑|(𝑦̂ −𝑦)|\n"},{"url":"/2025/09/11/mysql%E6%97%B6%E9%97%B4%E6%9F%A5%E8%AF%A2/mysql/%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB/","content":"DQL:数据查询语言（凡是带有select 关键字的都是查询语句）select....\nDML：数据操作语言（凡是对表当中的数据进行增删改都是DML）insert delete updateinsert 增delete 删update 改\nDDL:数据定义语言（修改表结构）（凡是带有create、drop、alter的都是DDL，DDL主要操作的时表结构。不是表中的数据）create ： 新建，等同增drop：删除alter：修改\n\nTCL 事务控制语言（主要控制事务）事务提交：commit；事务回滚：rollback；\n\nDCL： 是数据控制语言。（）\n授权：grant撤销授权revoke"},{"url":"/2025/09/11/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/01/%E5%A4%8D%E4%B9%A0%E7%BB%83%E4%B9%A0%E9%9A%8F%E7%AC%94/","content":"1.1 变量即是容器1.2 变量赋值左赋值给右：变量名&#x3D;变量值python解释器是由自上而下的，上面定义的函数如相同的变量名，下面会覆盖上面的定义，索引相同。数据类型分为数字类型和非数字类型。数字类型：int,float,bool,complex非数字类型：str,list,tuple,set,dict查看type（变量名）1.2.1格式化输出:按照一定格式输出到控制台1.2.2 类型转换 int（x）转整数 float（x）转浮点数\tstr(x转字符串)1.2.3 算术运算符 + -  &#x2F; &#x2F;&#x2F; % 优先级*&gt;&#x2F;%&#x2F;&#x2F;&gt;+-1.3复合合运算符+&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; %&#x3D; **&#x3D;1.3操作系统：承上启下：向下管理硬件，向上支持软件python特点：解析性语言缺点效率低2.1比较运算符 &#x3D;&#x3D; !&#x3D; &gt;&#x3D;\t&lt;&#x3D;\t&lt; &gt;逻辑运算符and or not2.2判断语句：\tif…elif…else if嵌套随机数包： import random调用：num&#x3D;random.randint(1,3)【1，3】循环语句：while:i&#x3D;0while i&lt;10:pirnt(‘跑地%d圈’%(i+1))i+&#x3D;1累加sum&#x3D;0while i&lt;100:if i%2:sum+&#x3D;ii+&#x3D;1while循环嵌套2.3：break continuebreak 中断，跳出循环体continue 跳出本次循环就近原则作用2.4三目运算a if a&gt;b else b条件作为中间线，判断左输出a，右输出b 中间条件于变量隔着关键字3.列表[]：增删改查，排序增加\t列表.append（值）尾追加删除 列表.remove(值) 删除第一个出现的指定数据修改：列表【索引】&#x3D;值 数据不存在则报错查询：列表【索引】 不存在则报错len（列表）列表长度if值in列表 判断列表包不含包含值列表.sort（）\t升序列表+for循环遍历for…. lesewhile i&lt;len(list):bl&#x3D;list【i】print(bl)if…in &amp;for..in的区别判断 遍历3.2tuple元组() 只包含一个元素的话（a，）元组不能修改查询 元组【索引】len【元组】if 值 in 元组 值是否在元组里3.3字典{} 储存多个数据，描述物体相关信息用键值对储存”key”:”value”值可以任何类型，但key只能字符串，数字，元组key必须是唯一的增删改查增加：字典【键】&#x3D;值 dict1【“age”】&#x3D;20删除：字典.pop（key）改：字典【键】&#x3D;值查：字典【key】 key 不存在报错字典。get【key】 key不存在返回None遍历字典获取键值对：\tfor key，value in 字典.items()3.4字符串f-strings字符串新型格式化：print（f‘我叫{name}’，年龄‘{age}’）重点：查找替换分割拼接查找：find（目标字符串，开始索引，结束）※替换：字符串.replace(旧，新，全局替换次数)※分割：字符串.spilt(分隔符)※拼接：字符串.join(字符串列表)字符串逆序：【::-1】3.5列表可以通过集合的类型转换进行去重list（x） 转换列表tuple（x） 转换元组set（x） 转换集合3.6运算符：+合并\t*复制【1，2】2 &#x3D;【1，2，1，2】4.4return返回值函数一旦执行return后面代码不会再执行4.7global修改全局变量num&#x3D;10def （）：global num4.8不定长参数元组型不定长参数args 接收任意数量def func（*args）字典型不定长参数 **kwargsdef func（name，*kwargs）形参name不会被包装在字典里func（name&#x3D;“mike”，city&#x3D;‘sz’，age&#x3D;18）5.1组包和拆包：条件：变量数&#x3D;容器长度支持元组、列表、字典拆包5.2引用：查看引用：print（id（a））引用地址相同，说明指向同一个内存空间只要每运行一次程序，那么它的地址就会改变5.3可变与不可变类型可变类型：列表list\t集合set\t字典dict不可变类型：字符串str\t元组type 数值类型 int\tbool float5.4range创建整数列表对象 一般用在for循环用法与切片用法一样 range（1，5）\t[1，5)\t1-4列表推倒式: [结果 for 变量 in 可迭代对象 if 条件筛选]生成器表达式: (结果 for 变量 in 可迭代对象 if 条件筛选), 没有元组推倒式字典推倒式: {结果(k:v) for 变量 in 可迭代对象 if 条件筛选}集合推倒式: {结果(k) for 变量 in 可迭代对象 if 条件筛选} 自带去重功能5.5列表推导式每循环一次，将结果添加到列表中计算公式可以使用遍历出的数据for遍历出的数据必须满足if 判断，才会使用计算公式生成元素优点：不会将所有的值一次性加载到内存中，延迟计算，对大数据处理非常有用生成器可以使用yield关键字编写，也可以使用生成器表达式把【】改成（）5.6匿名函数lambda 【形参1】【形参2】：【单行表达式】or【函数调用】匿名函数不能使用while循环，for循环，只能编写单行表达式，或者函数调用不需要return 自动返回结果#无参有返回值：（）就是函数名字ret &#x3D;（lambda：1+1）（）print（ret）起函数名字：func &#x3D; lambda：1+1ret &#x3D; func（）print（ret）#有参有返回值ret &#x3D; （lambda a,b : a-b）(30,10)print(ret)func &#x3D;lambda a,b :a-bret &#x3D; func(30,10)print(ret)5.7递归函数函数内部调用自身一定要有出口def func(n):ret &#x3D; nfunc(n-1)return\tret_ret &#x3D; func(3)print(_ret)5.8\tenumerate delfor 配合enumerate 遍历容器时可以获得元素索引del删除列表元素del list[1]5.9文件版学生名片管理系统str（）eval（）（返回传入字符串内容结果，字符串里面看到像是什么，就转换成什么）6.1 文件打开与关闭只读：r \t写入: w格式：with open(‘123.txt , ‘’w’)as f:\t\t\t\tpass6.2写数据：\n"},{"url":"/2025/09/11/%E6%B5%8B%E8%AF%95/day1/","content":""},{"url":"/2025/09/11/mysql%E6%97%B6%E9%97%B4%E6%9F%A5%E8%AF%A2/mysq/newnote_1616765059970/","content":"\n\n\ndistinct可以去除重复数据行\n\n\n\nlike是模糊查询关键字%表示任意多个任意字符_表示一个任意字符例1：查询姓黄的学生:select * from students where name like &#x27;黄%&#x27;;例2：查询姓黄并且“名”是一个字的学生:select * from students where name like &#x27;黄_&#x27;;例3：查询姓黄或叫靖的学生:select * from students where name like &#x27;黄%&#x27; or name like &#x27;%靖&#x27;;\n\n\n\n\nbetween .. and .. 表示在一个连续的范围内查询in 表示在一个非连续的范围内查询例1：查询编号为3至8的学生:select * from students where id between 3 and 8;例2：查询编号不是3至8的男生:select * from students where (not id between 3 and 8) and gender=&#x27;男&#x27;;"}]